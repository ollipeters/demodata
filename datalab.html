<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>DataLab</title>

  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    body { font-family: 'Inter', sans-serif; }
    #dashboard-nav { position: fixed; top: 0; left: 50%; transform: translateX(-50%); z-index: 100; }
    html.in-iframe { font-size: 11px; }

    /* Match existing button look used across the project (see steuerung.html) */
    .phase-btn {
      background-color: transparent;
      color: #4b5563; /* text-gray-600 */
      border: 1px solid #d1d5db; /* border-gray-300 */
      transition: all 0.2s ease;
    }
    .phase-btn:hover {
      background-color: #f9fafb; /* bg-gray-50 */
      border-color: #9ca3af; /* border-gray-400 */
    }
    .phase-btn.active {
      background-color: #0A3F86;
      color: #ffffff;
      border-color: #0A3F86;
    }
  </style>
</head>
<body class="bg-gray-100 text-gray-800">

  <script>
    if (new URLSearchParams(window.location.search).get('view') === 'iframe') {
      document.documentElement.classList.add('in-iframe');
    }
  </script>

  <!-- Navbar (matching other pages) -->
  <nav id="dashboard-nav" class="mt-4 bg-white/80 backdrop-blur-lg rounded-full shadow-lg border border-gray-200/80">
    <div class="px-6 py-2 flex items-center space-x-8">
      <a href="dashboard.html" class="text-sm font-medium text-gray-500 hover:text-blue-600">KPI</a>
      <a href="spielanalyse.html" class="text-sm font-medium text-gray-500 hover:text-blue-600">Spielanalyse</a>
      <a href="gegneranalyse.html" class="text-sm font-medium text-gray-500 hover:text-blue-600">Gegneranalyse</a>
      <a href="steuerung.html" class="text-sm font-medium text-gray-500 hover:text-blue-600">Steuerung</a>
      <a href="datalab.html" class="text-sm font-semibold text-[#0A3F86] transition-colors">DataLab</a>
    </div>
  </nav>

  <!-- Empty starter layout -->
  <div class="h-screen overflow-hidden flex justify-center pt-24 pb-6">
    <main class="w-full max-w-screen-2xl p-6 h-full box-border">
      <div class="bg-white rounded-lg shadow-sm border border-gray-200 w-full h-full flex overflow-hidden" id="main-content-container">

        <!-- Left sidebar navigation -->
        <aside class="w-64 shrink-0 border-r border-gray-200 bg-white p-4">
          <nav class="space-y-1">
            <a href="#" data-section="gamification" class="block px-3 py-2 rounded-md text-sm font-medium text-gray-700 hover:bg-gray-100">Gamification</a>
            <a href="#" data-section="spieler-matrix" class="block px-3 py-2 rounded-md text-sm font-medium text-gray-700 hover:bg-gray-100">Spieler-Matrix</a>
          </nav>
        </aside>

        <!-- Main content (still intentionally empty) -->
        <section class="flex-1 min-w-0 p-6 flex flex-col">
          <div id="datalab-view" class="flex-1 min-h-0"></div>
        </section>

      </div>
    </main>
  </div>

  <script>
    const TEAM_ID_HSV = 38;
    const state = {
      activeSection: 'spieler-matrix',
      matrix: {
        loading: false,
        error: null,
        matchesLoaded: 0,
        players: [],
        basePlayers: [],
        playersByMetric: {},
        activeMetric: 'net-minutes',
        metrics: {
          'net-minutes': new Map(),
          'successful-passes': new Map(),
          'xg': new Map(),
          'successful-playtime': new Map(),
        },
      }
    };

    function buildPlayersSortedByMetric(basePlayers, pairValues) {
      const totals = new Map();
      for (const p of basePlayers) totals.set(p.id, 0);
      for (const [k, v] of pairValues.entries()) {
        const [aStr, bStr] = String(k).split('|');
        const a = Number(aStr);
        const b = Number(bStr);
        if (!Number.isFinite(a) || !Number.isFinite(b)) continue;
        const n = Number(v) || 0;
        if (!n) continue;
        totals.set(a, (totals.get(a) || 0) + n);
        totals.set(b, (totals.get(b) || 0) + n);
      }

      const out = basePlayers.map(p => ({ ...p, _metricTotal: totals.get(p.id) || 0 }));
      out.sort((a, b) => {
        if (a._metricTotal !== b._metricTotal) return b._metricTotal - a._metricTotal;
        return a.displayName.localeCompare(b.displayName, 'de');
      });
      for (const p of out) delete p._metricTotal;
      return out;
    }

    function parseScore(scoreStr) {
      const m = String(scoreStr || '').match(/(\d+)\s*:\s*(\d+)/);
      if (!m) return null;
      return { home: Number(m[1]), away: Number(m[2]) };
    }

    function getFirstLeadMinute(matchCentreData, teamId) {
      const hTeamId = matchCentreData?.home?.teamId;
      const aTeamId = matchCentreData?.away?.teamId;
      const oppTeamId = (hTeamId === teamId) ? aTeamId : ((aTeamId === teamId) ? hTeamId : null);
      if (!oppTeamId) return null;

      const events = matchCentreData?.events;
      if (!Array.isArray(events) || events.length === 0) return null;

      const goalEvents = events
        .filter(e => (e?.type?.displayName === 'Goal' || Number(e?.type?.value) === 16) && Number.isFinite(Number(e?.teamId)))
        .slice()
        .sort((a, b) => {
          const am = Number(a?.expandedMinute ?? a?.minute ?? 0);
          const bm = Number(b?.expandedMinute ?? b?.minute ?? 0);
          if (am !== bm) return am - bm;
          const as = Number(a?.second ?? 0);
          const bs = Number(b?.second ?? 0);
          return as - bs;
        });

      let goalsFor = 0;
      let goalsAgainst = 0;

      for (const ev of goalEvents) {
        const tid = Number(ev.teamId);
        if (tid === teamId) goalsFor += 1;
        else if (tid === oppTeamId) goalsAgainst += 1;
        else continue;

        if (goalsFor > goalsAgainst) {
          const m = Number(ev.expandedMinute ?? ev.minute);
          return Number.isFinite(m) ? m : 0;
        }
      }

      return null;
    }

    function getSurname(fullName) {
      const s = String(fullName || '').trim();
      if (!s) return '';
      const parts = s.split(/\s+/).filter(Boolean);
      return parts.length ? parts[parts.length - 1] : s;
    }

    function escapeHtml(value) {
      return String(value)
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#039;');
    }

    function setActiveSidebar(section) {
      document.querySelectorAll('aside [data-section]').forEach(a => {
        const isActive = a.getAttribute('data-section') === section;
        a.classList.toggle('bg-gray-100', isActive);
        a.classList.toggle('text-gray-900', isActive);
        a.classList.toggle('text-gray-700', !isActive);
      });
    }

    function render() {
      setActiveSidebar(state.activeSection);
      const root = document.getElementById('datalab-view');
      if (!root) return;

      if (state.activeSection === 'spieler-matrix') {
        root.innerHTML = renderSpielerMatrixView();
        if (!state.matrix.loading && state.matrix.players.length === 0 && !state.matrix.error) {
          void loadSpielerMatrix();
        }

        // Fit matrix (no scrolling) after DOM updates.
        requestAnimationFrame(() => requestAnimationFrame(applyMatrixFit));
        return;
      }

      // Keep other sections intentionally minimal/empty.
      root.innerHTML = '';
    }

    function renderSpielerMatrixView() {
      const { loading, error, matchesLoaded, players, activeMetric } = state.matrix;

      const hint = (window.location.protocol === 'file:')
        ? '<div class="text-sm text-gray-600">Hinweis: Für das Laden der JSON-Dateien bitte über einen lokalen Server öffnen (z.B. VS Code Live Server), da <code class="font-mono">file://</code> Fetch blockiert.</div>'
        : '';

      const status = loading
        ? '<div class="text-sm text-gray-600">Lade Daten…</div>'
        : (error
          ? `<div class="text-sm text-red-600">${escapeHtml(error)}</div>`
          : `<div class="text-sm text-gray-600">Spiele geladen: ${matchesLoaded}</div>`);

      const table = (players.length > 0 && !loading && !error)
        ? renderMatrixTable()
        : '';

      const metricButtons = `
        <div class="grid grid-cols-2 gap-2">
          <button type="button" data-matrix-metric="net-minutes" class="phase-btn ${activeMetric === 'net-minutes' ? 'active' : ''} w-full px-3 py-1 rounded-md text-xs font-medium text-left">Netto-Spielzeit</button>
          <button type="button" data-matrix-metric="successful-passes" class="phase-btn ${activeMetric === 'successful-passes' ? 'active' : ''} w-full px-3 py-1 rounded-md text-xs font-medium text-left">Erfolgreiche Pässe</button>
          <button type="button" data-matrix-metric="xg" class="phase-btn ${activeMetric === 'xg' ? 'active' : ''} w-full px-3 py-1 rounded-md text-xs font-medium text-left">xG</button>
          <button type="button" data-matrix-metric="successful-playtime" class="phase-btn ${activeMetric === 'successful-playtime' ? 'active' : ''} w-full px-3 py-1 rounded-md text-xs font-medium text-left">erfolgreiche Spielzeit</button>
        </div>
      `;

      return `
        <div class="flex flex-col gap-4 h-full">
          <div class="flex items-start justify-between gap-4">
            <div>
              <h2 class="text-lg font-semibold">Spieler-Matrix</h2>
              ${hint}
            </div>
          </div>
          <div class="flex-1 min-h-0 flex gap-0">
            <div class="flex-1 min-w-0 flex flex-col gap-2">
              ${status}
              <div class="flex-1 min-h-0">${table}</div>
            </div>
            <aside class="w-96 shrink-0">
              ${metricButtons}
            </aside>
          </div>
        </div>
      `;
    }

    function renderMatrixTable() {
      const players = state.matrix.players;
      const metricKey = state.matrix.activeMetric;
      const pairValues = state.matrix.metrics?.[metricKey] || new Map();

      let maxMinutes = 0;
      for (const v of pairValues.values()) {
        if (typeof v === 'number' && v > maxMinutes) maxMinutes = v;
      }

      function heatClass(minutes) {
        if (!maxMinutes || !minutes) return '';
        const r = minutes / maxMinutes;

        // Keep low values visually white; bucket the rest into Tailwind greens.
        if (r < 0.15) return '';
        if (r < 0.30) return 'bg-green-50';
        if (r < 0.45) return 'bg-green-100';
        if (r < 0.60) return 'bg-green-200';
        if (r < 0.75) return 'bg-green-300';
        if (r < 0.90) return 'bg-green-400';
        return 'bg-green-500 text-white';
      }

      const headerCells = players.map(p => {
        const label = escapeHtml(p.displayName);
        return `
          <th class="border border-gray-200 align-bottom" style="width: 26px; min-width: 26px;">
            <div class="h-16 w-6 relative">
              <div class="absolute bottom-1 left-1 origin-bottom-left -rotate-45 text-[10px] font-semibold text-gray-700 whitespace-nowrap">${label}</div>
            </div>
          </th>
        `;
      }).join('');

      const rows = players.map((rowP, i) => {
        const cells = players.map((colP, j) => {
          if (i === j) {
            return '<td class="border border-gray-200 bg-gray-200"></td>';
          }
          const a = rowP.id;
          const b = colP.id;
          const key = a < b ? `${a}|${b}` : `${b}|${a}`;
          const value = pairValues.get(key) ?? 0;
          const n = Number(value) || 0;
          const rounded = (metricKey === 'xg')
            ? (Math.round(n * 100) / 100)
            : (metricKey === 'successful-passes')
              ? Math.round(n)
              : Math.round(n);
          const heat = heatClass(Number(value) || 0);
          const cls = `border border-gray-200 px-1 py-1 text-[10px] text-center ${heat || 'text-gray-800'}`;
          return `<td class="${cls}">${rounded}</td>`;
        }).join('');

        return `
          <tr>
            <th class="border border-gray-200 px-1 py-1 text-[10px] font-semibold text-gray-700 whitespace-nowrap">${escapeHtml(rowP.displayName)}</th>
            ${cells}
          </tr>
        `;
      }).join('');

      return `
        <div class="h-full overflow-hidden bg-white" id="matrix-fit-container">
          <div id="matrix-scale" class="origin-top-left">
            <table class="border-collapse" id="matrix-table">
            <thead>
              <tr>
                <th class="border border-gray-200 px-1 py-1 text-[10px] font-semibold text-gray-700 whitespace-nowrap">Spieler</th>
                ${headerCells}
              </tr>
            </thead>
            <tbody>
              ${rows}
            </tbody>
            </table>
          </div>
        </div>
      `;
    }

    function applyMatrixFit() {
      if (state.activeSection !== 'spieler-matrix') return;
      const container = document.getElementById('matrix-fit-container');
      const scaler = document.getElementById('matrix-scale');
      const table = document.getElementById('matrix-table');
      if (!container || !scaler || !table) return;

      // Reset scale to measure natural size
      scaler.style.transform = 'scale(1)';

      const pad = 8;
      const availableW = Math.max(0, container.clientWidth - pad);
      const availableH = Math.max(0, container.clientHeight - pad);
      const tableW = table.offsetWidth;
      const tableH = table.offsetHeight;
      if (!tableW || !tableH || !availableW || !availableH) return;

      const scale = Math.min(1, availableW / tableW, availableH / tableH);
      scaler.style.transform = `scale(${scale})`;
    }

    async function loadSpielerMatrix() {
      state.matrix.loading = true;
      state.matrix.error = null;
      state.matrix.matchesLoaded = 0;
      state.matrix.players = [];
      state.matrix.basePlayers = [];
      state.matrix.playersByMetric = {};
      state.matrix.metrics = {
        'net-minutes': new Map(),
        'successful-passes': new Map(),
        'xg': new Map(),
        'successful-playtime': new Map(),
      };
      render();

      try {
        const matchFiles = await loadHSVMatchFiles();

        // Same dataset used in Spielanalyse/Gegneranalyse.
        // We only need a lightweight index for HSV team totals per match.
        const processed = await fetchJson('processed_data.json');
        const processedByMatch = new Map();
        if (Array.isArray(processed)) {
          for (const row of processed) {
            if (!row || row.team !== 'Hamburg') continue;
            // Prefer full match rows only (half==0 is used as full match in this dataset).
            if (row.half != null && Number(row.half) !== 0) continue;
            const mid = String(row.match_id || '');
            if (!mid) continue;
            const cur = processedByMatch.get(mid) || { xg: 0, passes_successful: 0, byPlayer: new Map() };
            const xg = Number(row.xg ?? 0);
            if (Number.isFinite(xg)) cur.xg += xg;
            const ps = Number(row.passes_successful ?? 0);
            if (Number.isFinite(ps)) cur.passes_successful += ps;

            const playerName = String(row.player || '').trim();
            if (playerName) {
              const pCur = cur.byPlayer.get(playerName) || { minutes: 0, passes_successful: 0, xg: 0 };
              const m = Number(row.minutes_played ?? 0);
              if (Number.isFinite(m)) pCur.minutes += m;
              if (Number.isFinite(ps)) pCur.passes_successful += ps;
              if (Number.isFinite(xg)) pCur.xg += xg;
              cur.byPlayer.set(playerName, pCur);
            }

            processedByMatch.set(mid, cur);
          }
        }

        const playerIdToName = new Map();
        const pairNetMinutes = new Map();
        const pairSuccessfulPlaytime = new Map();
        const pairSuccessfulPasses = new Map();
        const pairXg = new Map();
        const playersOnField = new Set();

        for (const relPath of matchFiles) {
          const match = await fetchJson(`Data/whoscored/${relPath}`);
          const matchCentreData = match?.raw?.matchCentreData;
          if (!matchCentreData) continue;

          const dict = matchCentreData.playerIdNameDictionary || {};
          for (const [idStr, name] of Object.entries(dict)) {
            const id = Number(idStr);
            if (!Number.isFinite(id)) continue;
            if (!playerIdToName.has(id)) playerIdToName.set(id, name);
          }

          const hTeamId = matchCentreData?.home?.teamId;
          const aTeamId = matchCentreData?.away?.teamId;
          const side = (hTeamId === TEAM_ID_HSV) ? 'home' : ((aTeamId === TEAM_ID_HSV) ? 'away' : null);
          if (!side) continue;

          // Erfolgreiche Spielzeit = gemeinsame Minuten, bevor HSV in Führung geht.
          const leadMinute = getFirstLeadMinute(matchCentreData, TEAM_ID_HSV);

          const formations = matchCentreData?.[side]?.formations || [];

          // Map to processed_data.json match_id (file stem).
          const fileStem = String(relPath || '').split('/').pop() || '';
          const matchKey = fileStem.endsWith('.json') ? fileStem.slice(0, -5) : fileStem;
          const proc = processedByMatch.get(matchKey) || null;
          const matchXg = proc ? Number(proc.xg || 0) : 0;

          // First pass: compute per-player minutes and store segment on-pitch lists.
          const minutesByPlayer = new Map();
          const segments = [];
          let matchDuration = 0;

          for (const seg of formations) {
            const start = Number(seg?.startMinuteExpanded);
            const end = Number(seg?.endMinuteExpanded);
            if (!Number.isFinite(start) || !Number.isFinite(end) || end <= start) continue;
            const delta = end - start;
            matchDuration += delta;

            const ids = Array.isArray(seg?.playerIds) ? seg.playerIds : [];
            const slots = Array.isArray(seg?.formationSlots) ? seg.formationSlots : [];

            const onPitch = [];
            for (let idx = 0; idx < Math.min(ids.length, slots.length); idx++) {
              const slot = Number(slots[idx]);
              const pid = Number(ids[idx]);
              if (!Number.isFinite(slot) || slot === 0) continue;
              if (!Number.isFinite(pid)) continue;
              onPitch.push(pid);
              playersOnField.add(pid);
              minutesByPlayer.set(pid, (minutesByPlayer.get(pid) || 0) + delta);
            }

            segments.push({ start, end, delta, onPitch });

            const preLeadDelta = (Number.isFinite(leadMinute))
              ? Math.max(0, Math.min(end, leadMinute) - start)
              : 0;

            // Add co-minutes for each unordered pair on the pitch during this segment.
            for (let i = 0; i < onPitch.length; i++) {
              for (let j = i + 1; j < onPitch.length; j++) {
                const a = onPitch[i];
                const b = onPitch[j];
                const key = a < b ? `${a}|${b}` : `${b}|${a}`;
                pairNetMinutes.set(key, (pairNetMinutes.get(key) || 0) + delta);
                if (preLeadDelta) {
                  pairSuccessfulPlaytime.set(key, (pairSuccessfulPlaytime.get(key) || 0) + preLeadDelta);
                }
              }
            }
          }

          // Build per-player successful pass rate for this match using processed_data.json
          // (same source as Spielanalyse/Gegneranalyse). Fallback: 0.
          const passRateByPlayer = new Map();
          for (const [pid, mins] of minutesByPlayer.entries()) {
            const fullName = playerIdToName.get(pid) || '';
            const row = proc && fullName ? proc.byPlayer.get(fullName) : null;
            const pMinutes = row ? Number(row.minutes || 0) : 0;
            const pPasses = row ? Number(row.passes_successful || 0) : 0;
            const rate = (pMinutes > 0) ? (pPasses / pMinutes) : 0;
            // Use on-pitch minutes if processed minutes missing.
            const safeRate = (Number.isFinite(rate) && rate >= 0) ? rate : 0;
            passRateByPlayer.set(pid, safeRate);
          }

          const xgPerMinute = (matchDuration > 0 && Number.isFinite(matchXg) && matchXg > 0)
            ? (matchXg / matchDuration)
            : 0;

          // Second pass: approximate successful passes while players share the pitch.
          for (const seg of segments) {
            const delta = seg.delta;
            const onPitch = seg.onPitch;
            const segXg = xgPerMinute ? (xgPerMinute * delta) : 0;
            for (let i = 0; i < onPitch.length; i++) {
              for (let j = i + 1; j < onPitch.length; j++) {
                const a = onPitch[i];
                const b = onPitch[j];
                const key = a < b ? `${a}|${b}` : `${b}|${a}`;
                const ra = passRateByPlayer.get(a) || 0;
                const rb = passRateByPlayer.get(b) || 0;
                const add = ((ra + rb) / 2) * delta;
                if (add) pairSuccessfulPasses.set(key, (pairSuccessfulPasses.get(key) || 0) + add);
                if (segXg) pairXg.set(key, (pairXg.get(key) || 0) + segXg);
              }
            }
          }

          state.matrix.matchesLoaded += 1;
          // lightweight progress re-render
          render();
        }

        const players = Array.from(playersOnField).map(id => ({
          id,
          name: playerIdToName.get(id) || `#${id}`
        }));
        for (const p of players) {
          p.displayName = getSurname(p.name);
        }
        const basePlayers = players.slice().sort((a, b) => a.displayName.localeCompare(b.displayName, 'de'));

        // Finalize: round minutes to integers
        const roundedPairNet = new Map();
        for (const [k, v] of pairNetMinutes.entries()) {
          roundedPairNet.set(k, Math.round(v));
        }

        const roundedPairSuccessfulPlaytime = new Map();
        for (const [k, v] of pairSuccessfulPlaytime.entries()) {
          roundedPairSuccessfulPlaytime.set(k, Math.round(v));
        }

        const roundedPairSuccessfulPasses = new Map();
        for (const [k, v] of pairSuccessfulPasses.entries()) {
          roundedPairSuccessfulPasses.set(k, Math.round(v));
        }

        const roundedPairXg = new Map();
        for (const [k, v] of pairXg.entries()) {
          const x = Number(v) || 0;
          roundedPairXg.set(k, Math.round(x * 100) / 100);
        }

        const metrics = {
          'net-minutes': roundedPairNet,
          'successful-passes': roundedPairSuccessfulPasses,
          'xg': roundedPairXg,
          'successful-playtime': roundedPairSuccessfulPlaytime,
        };

        const playersByMetric = {
          'net-minutes': buildPlayersSortedByMetric(basePlayers, metrics['net-minutes']),
          'successful-passes': buildPlayersSortedByMetric(basePlayers, metrics['successful-passes']),
          'xg': buildPlayersSortedByMetric(basePlayers, metrics['xg']),
          'successful-playtime': buildPlayersSortedByMetric(basePlayers, metrics['successful-playtime']),
        };

        state.matrix.basePlayers = basePlayers;
        state.matrix.playersByMetric = playersByMetric;
        state.matrix.metrics = metrics;
        state.matrix.players = playersByMetric[state.matrix.activeMetric] || basePlayers;
      } catch (e) {
        state.matrix.error = (e && e.message) ? e.message : String(e);
      } finally {
        state.matrix.loading = false;
        render();
      }
    }

    async function loadHSVMatchFiles() {
      const idx = await fetchJson('Data/whoscored/index.json');
      const files = idx?.teams?.['hamburger-sv']?.savedFiles;
      if (!Array.isArray(files) || files.length === 0) {
        throw new Error('Keine HSV-Spiele in Data/whoscored/index.json gefunden.');
      }
      return files;
    }

    async function fetchJson(url) {
      const res = await fetch(url);
      if (!res.ok) throw new Error(`Fehler beim Laden: ${url} (${res.status})`);
      return await res.json();
    }

    // Sidebar wiring
    document.querySelectorAll('aside [data-section]').forEach(a => {
      a.addEventListener('click', (ev) => {
        ev.preventDefault();
        state.activeSection = a.getAttribute('data-section');
        render();
      });
    });

    // Metric buttons (event delegation since the view re-renders)
    document.addEventListener('click', (ev) => {
      const btn = ev.target.closest('[data-matrix-metric]');
      if (!btn) return;
      ev.preventDefault();
      const metric = btn.getAttribute('data-matrix-metric');
      if (!metric) return;
      state.matrix.activeMetric = metric;
      if (state.matrix.playersByMetric && state.matrix.playersByMetric[metric]) {
        state.matrix.players = state.matrix.playersByMetric[metric];
      }
      render();
    });

    window.addEventListener('resize', () => {
      requestAnimationFrame(() => requestAnimationFrame(applyMatrixFit));
    });

    // Initial render
    render();
  </script>

</body>
</html>
