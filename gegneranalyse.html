<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gegneranalyse Dashboard - Hochkant</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="pitch_visualization.js?v=10"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        #dashboard-nav { position: fixed; top: 0; left: 50%; transform: translateX(-50%); z-index: 100; }
        html.in-iframe { font-size: 11px; }

        /* Prevent flash of unstyled content before Tailwind is ready */
        .hidden { display: none !important; }

        /* App Loading Overlay (shown on first load / navigation) */
        #app-loading {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            /* Keep layout visible under the loader (same behavior as Spielanalyse) */
            background: rgba(243, 244, 246, 0.55); /* gray-100 */
            z-index: 200;
        }

        /* Loading layout mode (match Spielanalyse first-load behavior: no empty side boxes) */
        #main-grid.loading-mode {
            grid-template-columns: minmax(0,1fr) 24rem minmax(0,1fr);
        }
        #main-grid.loading-mode #info-links,
        #main-grid.loading-mode #info-rechts {
            display: none;
        }
        #main-grid.loading-mode #action-container {
            grid-column: 1 / -1;
            max-width: none;
            width: 100%;
            margin-left: 0;
            margin-right: 0;
        }

        /* Übersicht: nur Center-Panel (Match Stats) */
        #main-grid.overview-mode {
            grid-template-columns: minmax(0,1fr) 24rem minmax(0,1fr);
        }
        #main-grid.overview-mode #info-links,
        #main-grid.overview-mode #info-rechts {
            display: none;
        }
        #main-grid.overview-mode #action-container {
            grid-column: 1 / -1;
            max-width: none;
            width: 100%;
            margin-left: 0;
            margin-right: 0;
        }
        #app-loading .loading-card {
            background: #ffffff;
            border: 1px solid #e5e7eb; /* gray-200 */
            border-radius: 0.75rem;
            padding: 1rem 1.25rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            display: inline-flex;
            align-items: center;
            gap: 0.75rem;
        }
        #app-loading .spinner {
            width: 22px;
            height: 22px;
            border-radius: 9999px;
            border: 3px solid #d1d5db; /* gray-300 */
            border-top-color: #0A3F86;
            animation: appSpin 0.8s linear infinite;
        }
        @keyframes appSpin {
            to { transform: rotate(360deg); }
        }


        
        .canvas-container {
            position: relative;
            width: 100%;
            padding-top: 154.4%; /* Seitenverhältnis für Hochkant: 105 (Höhe) / 68 (Breite) */
            background-color: #f9fafb; /* bg-gray-50 */
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            cursor: crosshair;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
         /* Aktiver Phasen-Button (Modernes Design) */
        .phase-btn {
            background-color: transparent;
            color: #4b5563; /* text-gray-600 */
            border: 1px solid #d1d5db; /* border-gray-300 */
            transition: all 0.2s ease;
        }
        .phase-btn:hover {
            background-color: #f9fafb; /* bg-gray-50 */
            border-color: #9ca3af; /* border-gray-400 */
        }
        .phase-btn.active {
            background-color: #0A3F86;
            color: #ffffff; /* text-white */
            border-color: #0A3F86;
        }

        /* Slightly smaller buttons inside the three left info boxes so content fits. */
        #left-box-1 .phase-btn,
        #left-box-2 .phase-btn,
        #left-box-3 .phase-btn {
            font-size: 0.68rem !important; /* ~10% smaller than text-xs */
            padding-top: 0.2rem !important;
            padding-bottom: 0.2rem !important;
            padding-left: 1.1rem !important;
            padding-right: 1.1rem !important;
        }
        /* Aktiver Button für Spiel-Filter (minimalistisch) */
        .game-filter-btn.active {
            color: #2563eb; /* text-blue-600 */
            font-weight: 600;
        }
        /* Styling für das Akkordeon in der Info-Box */
        .accordion-header .chevron {
            transition: transform 0.2s ease-in-out;
        }
        .accordion-item.open .accordion-header .chevron {
            transform: rotate(90deg);
        }
        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
            padding-left: 1rem;
            padding-right: 1rem;
        }
        /* Open state: let content expand without inline JS measurements */
        .accordion-item.open > .accordion-content {
            max-height: 9999px; /* large enough for content; transition still applies */
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

<!-- App Loading Overlay (shown until first render completes) -->
<div id="app-loading" aria-live="polite" aria-busy="true">
    <div class="loading-card">
        <div class="spinner" aria-hidden="true"></div>
        <div class="text-sm font-medium text-gray-700" data-loading-text>Lade Daten…</div>
    </div>
</div>

<script>
    if (new URLSearchParams(window.location.search).get('view') === 'iframe') {
        document.documentElement.classList.add('in-iframe');
    }
</script>

<!-- Navbar -->
<nav id="dashboard-nav" class="mt-4 bg-white/80 backdrop-blur-lg rounded-full shadow-lg border border-gray-200/80">
    <div class="px-6 py-2 flex items-center space-x-8">
        <a href="dashboard.html" class="text-sm font-medium text-gray-500 hover:text-blue-600">KPI</a>
        <a href="spielanalyse.html" class="text-sm font-medium text-gray-500 hover:text-blue-600">Spielanalyse</a>
        <div class="relative">
            <button id="gegneranalyse-btn" class="text-sm font-semibold text-[#0A3F86] transition-colors flex items-center">
                Gegneranalyse
            </button>
            <div id="gegneranalyse-dropdown" class="hidden absolute z-30 mt-3 -translate-x-1/2 left-1/2 w-64 rounded-md bg-white shadow-lg border border-gray-200">
                <div class="p-2">
                    <label for="team-select" class="block text-xs font-medium text-gray-500 mb-1">Team auswählen</label>
                    <select id="team-select" class="w-full rounded-md border border-gray-300 bg-white py-2 pl-3 pr-10 text-left text-sm shadow-sm focus:ring-blue-500 focus:border-blue-500">
                        <!-- Optionen werden per JS hinzugefügt -->
                    </select>
                </div>
            </div>
        </div>
        <a href="steuerung.html" class="text-sm font-medium text-gray-500 hover:text-blue-600">Steuerung</a>
        <a href="datalab.html" class="text-sm font-medium text-gray-500 hover:text-blue-600">DataLab</a>
    </div>
</nav>

<!-- Zentrierter Hauptinhalt -->
<div class="h-screen overflow-hidden flex justify-center pt-24 pb-6">
    <main class="w-full max-w-screen-2xl p-6 h-full box-border">
        <div class="bg-white p-6 rounded-lg shadow-sm border border-gray-200 w-full" id="main-content-container">
            
                <!-- Titel und Spiel-Auswahl in einer Zeile (JETZT OBEN) -->
                <div class="mb-6 flex items-center">
                    
                    <!-- Links: Titel -->
                    <div class="flex-1 text-left">
                        <h2 id="analysis-title" class="text-xl font-semibold">Lade…</h2>
                    </div>
                    
                    <!-- Mitte: Phasen-Buttons -->
                    <div id="phase-button-container" class="flex space-x-2 rounded-lg">
                        <button id="btn-uebersicht" class="phase-btn active px-5 py-1 rounded-md text-xs font-medium">
                            Übersicht
                        </button>
                        <button id="btn-mit-ball" class="phase-btn px-5 py-1 rounded-md text-xs font-medium">
                            Mit dem Ball
                        </button>
                        <button id="btn-gegen-ball" class="phase-btn px-5 py-1 rounded-md text-xs font-medium">
                            Gegen den Ball
                        </button>
                        <button id="btn-standards" class="phase-btn px-5 py-1 rounded-md text-xs font-medium">
                            Standards
                        </button>
                        <button id="btn-physisch" class="phase-btn px-5 py-1 rounded-md text-xs font-medium">
                            Physisch
                        </button>
                    </div>

                    <!-- Rechts: Spiel-Auswahl (Minimalistisch) -->
                    <div class="flex-1 flex justify-end items-center space-x-2">
                        <button class="game-filter-btn px-2 py-0.5 rounded-md text-xs font-medium text-gray-600 hover:text-blue-600" data-count="1">1S</button>
                        <button class="game-filter-btn px-2 py-0.5 rounded-md text-xs font-medium text-gray-600 hover:text-blue-600" data-count="3">3S</button>
                        <button class="game-filter-btn px-2 py-0.5 rounded-md text-xs font-medium text-gray-600 hover:text-blue-600" data-count="5">5S</button>
                        <button class="game-filter-btn active px-2 py-0.5 rounded-md text-xs font-medium text-gray-600" data-count="10">10S</button>
                    </div>
                </div>
                
                <!-- 3-Spalten-Layout -->
                <div id="main-grid" class="grid grid-rows-1 grid-cols-[minmax(0,1fr)_24rem_minmax(0,1fr)] gap-6 loading-mode">
                    
                    <!-- Info Links: Zeige nur die Standards-Box bei Standards-Phase, sonst die drei Boxen -->
                    <div id="info-links" class="h-full phase-fade flex flex-col gap-4" hidden>
                        <div id="left-box-1" class="border rounded-lg p-4 overflow-y-auto max-h-[24vh] phase-fade">
                            <h3 id="left-title-1" class="font-semibold mb-2 text-gray-700">Spielaufbau</h3>
                            <div id="info-content-aufbau" class="text-sm">
                                <p class="text-gray-500">Platzhalter für Text...</p>
                            </div>
                        </div>

                        <div id="left-box-2" class="border rounded-lg p-4 overflow-y-auto max-h-[24vh] phase-fade">
                            <h3 id="left-title-2" class="font-semibold mb-2 text-gray-700">Spielkontrolle</h3>
                            <div id="info-content-kontrolle" class="text-sm">
                                <p class="text-gray-500">Platzhalter für Text...</p>
                            </div>
                        </div>

                        <div id="left-box-3" class="border rounded-lg p-4 overflow-y-auto max-h-[24vh] phase-fade">
                            <h3 id="left-title-3" class="font-semibold mb-2 text-gray-700">Zum Tor</h3>
                            <div id="info-content-zumtor" class="text-sm">
                                <p class="text-gray-500">Platzhalter für Text...</p>
                            </div>
                        </div>

                        <div id="standards-info-box" class="border rounded-lg p-4 overflow-y-auto max-h-[60vh] phase-fade">
                            <h3 id="standards-title" class="font-semibold mb-2 text-gray-700">Standards</h3>
                            <!-- Standards Mode Toggle: For vs Against (always exactly one active) -->
                            <div class="mb-2">
                                <div id="standards-mode-toggle" class="w-full inline-flex rounded-md border border-gray-300 overflow-hidden">
                                    <button type="button" data-standards-mode="mit-ball" class="px-3 py-0.5 text-xs font-medium bg-white text-gray-700 hover:bg-gray-50 w-1/2">Mit dem Ball</button>
                                    <button type="button" data-standards-mode="gegen-ball" class="px-3 py-0.5 text-xs font-medium bg-white text-gray-700 hover:bg-gray-50 border-l border-gray-300 w-1/2">Gegen den Ball</button>
                                </div>
                            </div>
                            <div class="mb-2 grid grid-cols-3 gap-2">
                                <button type="button" data-corner-tab="eckball" class="phase-btn active px-5 py-1 rounded-md text-xs font-medium">Eckball</button>
                                <button type="button" data-corner-tab="einwurf" class="phase-btn px-5 py-1 rounded-md text-xs font-medium">Einwurf</button>
                                <button type="button" data-corner-tab="freistoss" class="phase-btn px-5 py-1 rounded-md text-xs font-medium">Freistoß</button>
                            </div>
                            <div id="standards-info-content" class="text-sm">
                                <div id="corner-info-content"></div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Canvas-Container (Mitte, kleiner) -->
                    <div id="action-container" class="max-w-sm mx-auto w-full h-full">
                        <!-- ÜBERSICHT-ONLY: The Athletic Match Stats (ohne Vergleich) -->
                        <div id="overview-only-container" class="hidden w-full h-full" hidden>
                            <div class="w-full h-full flex items-start justify-start">
                                <div class="w-full px-0">
                                    <div class="w-full bg-white rounded-lg p-4 h-full min-h-0">
                                        <div class="grid grid-cols-[minmax(0,1fr)_24rem_minmax(0,1fr)] gap-6 items-start h-full min-h-0">
                                            <div id="overview-player-matrix" class="text-sm min-h-0 h-3/4 flex flex-col overflow-hidden pb-4"></div>

                                            <div class="flex flex-col items-center h-full min-h-0">
                                                <div id="overview-possession-wrap" class="relative flex items-center justify-center">
                                                    <div class="absolute left-[-64px] top-1 bottom-1 flex items-center" style="z-index:10; pointer-events:none;">
                                                        <div class="text-[10px] text-gray-500 font-medium tracking-wide" style="writing-mode: vertical-rl; transform: rotate(180deg);">Ballbesitz</div>
                                                    </div>
                                                    <div id="overview-possession-bar" class="absolute left-[-40px] top-1 bottom-1 w-8 rounded-full overflow-hidden" style="display:none; z-index:10;">
                                                        <div id="overview-possession-bar-away" class="w-full flex justify-center items-end pb-2" style="height:50%; background:#ef4444;">
                                                            <div id="overview-possession-bar-away-label" class="text-white font-semibold text-lg leading-none">-</div>
                                                        </div>
                                                        <div id="overview-possession-bar-home" class="w-full flex justify-center items-start pt-2" style="height:50%; background:#0A3F86;">
                                                            <div id="overview-possession-bar-home-label" class="text-white font-semibold text-lg leading-none">-</div>
                                                        </div>
                                                    </div>

                                                    <div id="overview-fieldtilt-bar" class="absolute right-[-40px] top-1 bottom-1 w-8 rounded-full overflow-hidden" style="display:none; z-index:10;">
                                                        <div id="overview-fieldtilt-bar-away" class="w-full flex justify-center items-end pb-2" style="height:50%; background:#ef4444;">
                                                            <div id="overview-fieldtilt-bar-away-label" class="text-white font-semibold text-lg leading-none">-</div>
                                                        </div>
                                                        <div id="overview-fieldtilt-bar-home" class="w-full flex justify-center items-start pt-2" style="height:50%; background:#0A3F86;">
                                                            <div id="overview-fieldtilt-bar-home-label" class="text-white font-semibold text-lg leading-none">-</div>
                                                        </div>
                                                    </div>
                                                    <div class="absolute right-[-64px] top-1 bottom-1 flex items-center" style="z-index:10; pointer-events:none;">
                                                        <div class="text-[10px] text-gray-500 font-medium tracking-wide" style="writing-mode: vertical-rl;">Field Tilt</div>
                                                    </div>
                                                    <div class="relative overflow-hidden" style="width: 240px; height: calc(240px * 105 / 68); aspect-ratio: 68 / 105;">
                                                        <canvas id="overview-possession-canvas" class="absolute inset-0 w-full h-full"></canvas>
                                                    </div>
                                                </div>
                                                <div id="overview-possession-legend" class="mt-2 text-[10px] text-gray-600"></div>
                                                <div id="overview-matchstats" class="mt-4 space-y-2 flex flex-col items-center"></div>
                                            </div>

                                            <div class="min-h-0 pl-24">
                                                <div id="overview-sequences-chart" class="w-full min-h-0"></div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div id="regular-center-container" class="w-full h-full">
                        <div class="flip-scene w-full h-full">
                            <div id="physisch-flip-card" class="flip-card">
                                <!-- FRONT: Spielfeld (Standard) -->
                                <div class="flip-face flip-front">
                                    <!-- VIEW: Pitch (default) -->
                                    <div id="center-view-pitch">
                                        <div class="canvas-container">
                                            <canvas id="action-canvas"></canvas>
                                        </div>
                                        <div id="coords-display" class="text-center text-xs text-gray-400 mt-1 h-4"></div>
                                        <div id="ballbesitz-legend" class="hidden text-center text-[10px] text-gray-600 mt-1"></div>
                                        <!-- Globaler View-Switch für alle Kennzahlen -->
                                        <div id="global-view-switch" class="mt-2 flex items-center justify-center gap-2">
                                            <div class="inline-flex rounded-md border border-gray-300 overflow-hidden">
                                                <button id="btn-global-detail" class="px-3 py-0.5 text-xs font-medium bg-white text-gray-700 hover:bg-gray-50">Detail</button>
                                                <button id="btn-global-zones" class="px-3 py-0.5 text-xs font-medium bg-white text-gray-700 hover:bg-gray-50 border-l border-gray-300">Zonen</button>
                                            </div>
                                        </div>
                                    </div>

                                    <!-- VIEW: Field Tilt (matches pitch_test card layout) -->
                                    <div id="center-view-fieldtilt" class="hidden w-full h-full flex items-center justify-center">
                                        <div class="w-full bg-white border border-gray-200 rounded-lg shadow-sm p-3">
                                            <div id="field-tilt-header-ga" class="flex items-center justify-between mb-2">
                                                <div class="text-xs font-semibold text-gray-700">Field Tilt (Zeitverlauf)</div>
                                                <div id="field-tilt-summary-ga" class="text-[11px] text-gray-600"></div>
                                            </div>
                                            <div class="relative w-full" style="height: 220px;">
                                                <canvas id="field-tilt-canvas-ga" class="absolute inset-0 w-full h-full"></canvas>
                                                <canvas id="territory-canvas-ga" class="absolute inset-0 w-full h-full hidden"></canvas>
                                            </div>
                                            <div id="field-tilt-footer-ga" class="mt-2 text-[10px] text-gray-400">10-Minuten Moving Average</div>
                                            <div id="territory-legend-ga" class="mt-2 text-[10px] text-gray-600 hidden"></div>
                                        </div>
                                    </div>
                                </div>

                                <!-- BACK: Physisch-Grafiken -->
                                <div class="flip-face flip-back">
                                    <div class="w-full h-full flex flex-col gap-4">
                                        <div class="flex-1 min-h-0 w-full bg-gray-50 border border-gray-200 rounded-lg p-4 overflow-hidden">
                                            <div class="relative w-full h-full">
                                                <canvas id="physisch-distance-chart" class="absolute inset-0 w-full h-full"></canvas>
                                            </div>
                                        </div>
                                        <div class="flex-1 min-h-0 w-full bg-gray-50 border border-gray-200 rounded-lg p-4 overflow-hidden">
                                            <div class="relative w-full h-full">
                                                <canvas id="physisch-tempo-intense-chart" class="absolute inset-0 w-full h-full"></canvas>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        </div>
                    </div>

                    <!-- Info Rechts (2 Boxen) -->
                    <div id="info-rechts" class="h-full phase-fade flex flex-col gap-4" hidden>
                        <div id="right-box-1" class="border rounded-lg p-4 flex flex-col min-h-0">
                            <h3 id="right-title" class="font-semibold mb-2 text-gray-700">Individualtaktik</h3>
                            <div id="info-content-rechts" class="text-sm space-y-2">
                                <p class="text-gray-500">Platzhalter für Text...</p>
                            </div>
                        </div>

                        <div id="right-box-2" class="border rounded-lg p-4 flex flex-col min-h-0">
                            <h3 id="right-title-2" class="font-semibold mb-2 text-gray-700">Weitere Inhalte</h3>
                            <div id="info-content-rechts-2" class="text-sm space-y-2">
                                <p class="text-gray-500">Platzhalter für weitere Inhalte…</p>
                            </div>
                        </div>
                    </div>

                </div>
        </div>
    </main>
</div>

<style>
    /* Fast show/hide for phase-driven panels */
    .phase-fade {
        transition: opacity 120ms ease, transform 120ms ease;
        will-change: opacity, transform;
    }
    .phase-hidden {
        opacity: 0;
        transform: translateY(-4px);
        pointer-events: none;
        user-select: none;
    }
    /* Physisch keeps the default 3-column layout (left | pitch | right). */

    /* Keep the white main box within the viewport (no page scrollbar)
       and push scrolling into the inner panels (e.g., player list). */
    #main-content-container {
        display: flex;
        flex-direction: column;
        height: 100%;
        box-sizing: border-box;
        overflow: hidden;
    }
    #main-grid {
        flex: 1;
        min-height: 0;
    }
    #info-links,
    #action-container,
    #info-rechts {
        min-height: 0;
    }
    #info-rechts { min-height: 0; }
    /* Don't stretch the right column to the full grid cell; we sync to pitch height. */
    #info-rechts {
        align-self: flex-start;
    }
    #right-box-1,
    #right-box-2 {
        flex: 1 1 0;
        min-height: 0;
        overflow: hidden;
    }
    #info-content-rechts,
    #info-content-rechts-2 {
        display: flex;
        flex-direction: column;
        flex: 1;
        min-height: 0;
        overflow-y: auto;
    }

    /* Physisch flip (pitch -> charts) */
    .flip-scene {
        perspective: 1200px;
        height: 100%;
    }
    .flip-card {
        display: grid;
        transform-style: preserve-3d;
        transition: transform 420ms ease;
        width: 100%;
        height: 100%;
    }
    .flip-card.is-flipped {
        transform: rotateY(180deg);
    }
    .flip-face {
        grid-area: 1 / 1;
        width: 100%;
        backface-visibility: hidden;
        transform-style: preserve-3d;
        height: 100%;
    }
    .flip-back {
        transform: rotateY(180deg);
    }
</style>

<!-- ### START JAVASCRIPT LOGIK ### -->
<script>
    // --- MOCK DATEN (Erweitert auf 3 Matches) ---

    // --- GLOBALE VARIABLEN ---
    let dataset = []; // Wird mit den Daten aus der JSON-Datei gefüllt
    let eventDataset = []; // Hält die rohen Event-Daten
    let formationsDataset = []; // Optional: Formationen/Startelf je Match (aus formations_data.json)
    let dflRunningTeamMatches = []; // Team-Laufdaten (DFL) pro Match
    let dflRunningPlayerMatches = []; // Spieler-Laufdaten (DFL) pro Match
    let currentTeam = "Team A";
    let baseTeam = "Team A";
    // Default landing view: Übersicht
    let currentMainPhase = "uebersicht"; // zuletzt gewählter Top-Level (btn-uebersicht/mit-ball/gegen-ball/standards/physisch)
    let currentPhase = "uebersicht"; // aktueller Mittelbereich (Top-Level ODER Analyse-Phase)

    // Übersicht: Tabellen-Sortierung (Spielerliste links)
    let overviewPlayerMatrixSortKey = 'minutes'; // 'name' | 'minutes' | 'goals' | 'xg' | 'diff' | 'xt'
    let overviewPlayerMatrixSortDir = 'desc'; // 'asc' | 'desc'
    let overviewPlayerMatrixLastTeam = '';
    let overviewPlayerMatrixLastMatchIds = [];
    let activeGegenBallGroup = 'pressing'; // 'pressing' | 'block' | 'chance' (nur eine linke Box aktiv)
    let currentGameCount = 10; // Standard auf 10 Spiele
    let lastOpenNestedPhase = null; // Merkt zuletzt geöffneten Unterabschnitt (z.B. 'grundstruktur')
    let lastOpenAufbauTab = 'grundstruktur'; // Merkt zuletzt gewählten Spielaufbau-Tab
    let lastOpenKontrolleTab = 'ballbesitz'; // Merkt zuletzt gewählten Spielkontrolle-Tab
    let lastOpenZumTorTab = 'angriffsseite'; // Merkt zuletzt gewählten Zum-Tor-Tab
    let lastOpenPressingTab = 'pressinghoehe'; // Gegen den Ball: Pressing & Zugriff Tab
    let lastOpenBlockTab = 'zentrum'; // Gegen den Ball: Block & Raumkontrolle Tab
    let lastOpenChanceTab = 'shots'; // Gegen den Ball: Chance Prevention Tab
    let lastOpenCornerTab = 'eckball'; // Standards: Eckbälle Tab
    let standardsMode = 'mit-ball'; // Standards: 'mit-ball' (eigene) | 'gegen-ball' (gegen uns)
    let activeLeftTabGroup = 'aufbau'; // 'aufbau' | 'kontrolle' | 'zumtor' (nur dieser Tab-Button ist blau)
    let isUpdating = false; // Re-Entrancy Guard gegen Flicker/Loops
    let globalViewMode = 'detail'; // 'detail' (Pfeile) oder 'zones' (Zonen)
    let ballmagnetTopMetas = []; // [{ playerId, fullName, avgX, avgY, received_p90 }]
    let ballmagnetPassGroups = []; // [{ fullName, lines: [{ x, y, ex, ey }] }]

    // Farben für die Aktionen
    const LINE_COLOR = "#6b7280"; // bg-gray-400 für bessere Sichtbarkeit
    const COLOR_PASS = "rgba(59, 130, 246, 0.7)"; // blue-500
    const COLOR_SHOT = "rgba(30, 58, 138, 0.9)";  // blue-900
    const COLOR_DEFENSE = "rgba(147, 197, 253, 0.7)"; // blue-300
    const COLOR_STANDARD = "rgba(234, 179, 8, 0.7)"; // yellow-500

    // --- FUNKTIONEN ZUM ZEICHNEN DES SPIELFELDS (HOCHKANT) ---
     function drawPitch(canvas, withActions = false) {
        const ctx = canvas.getContext('2d');
        const w = canvas.width;
        const h = canvas.height;

        ctx.clearRect(0, 0, w, h);
        ctx.strokeStyle = LINE_COLOR;
        ctx.lineWidth = Math.max(1, w * 0.005); // Mindestbreite 1px
        ctx.lineCap = 'round';

        // Äußere Linien
        ctx.strokeRect(0, 0, w, h);
        // Mittellinie
        ctx.beginPath();
        ctx.moveTo(0, h / 2); // von links nach rechts in der Mitte
        ctx.lineTo(w, h / 2); // der Höhe
        ctx.stroke();
        // Mittelkreis
        ctx.beginPath();
        ctx.arc(w / 2, h / 2, w * 0.2, 0, 2 * Math.PI); // Radius relativ zur Breite
        ctx.stroke();
        // Mittelpunkt
        ctx.beginPath();
        ctx.arc(w / 2, h / 2, w * 0.01, 0, 2 * Math.PI);
        ctx.fillStyle = LINE_COLOR;
        ctx.fill();
        
        // Strafraum (Penalty Box) - 16.5m tief, 40.3m breit
        const penaltyBoxHeight = h * (16.5 / 105);
        const penaltyBoxWidth = w * (40.3 / 68);
        const penaltyBoxX = (w - penaltyBoxWidth) / 2;
        ctx.strokeRect(penaltyBoxX, 0, penaltyBoxWidth, penaltyBoxHeight); // Oben
        ctx.strokeRect(penaltyBoxX, h - penaltyBoxHeight, penaltyBoxWidth, penaltyBoxHeight); // Unten

        // Fünfmeterraum (Goal Box) - 5.5m tief, 18.32m breit
        const goalBoxHeight = h * (5.5 / 105);
        const goalBoxWidth = w * (18.32 / 68);
        const goalBoxX = (w - goalBoxWidth) / 2;
        ctx.strokeRect(goalBoxX, 0, goalBoxWidth, goalBoxHeight); // Oben
        ctx.strokeRect(goalBoxX, h - goalBoxHeight, goalBoxWidth, goalBoxHeight); // Unten

        // HINZUGEFÜGT: Zeichne das 18-Zonen-Raster (6x3)
        ctx.save(); // Aktuellen Zeichenzustand speichern
        ctx.strokeStyle = 'rgba(156, 163, 175, 0.5)'; // etwas deutlicheres Grau
        ctx.lineWidth = Math.max(1, w * 0.0015); // Dünnere Linien für das Raster
        ctx.setLineDash([4, 4]); // Gestrichelte Linien

        // Horizontale Linien (Sechstelung der Länge)
        ctx.beginPath();
        for (let i = 1; i < 6; i++) {
            // Die Mittellinie (i=3) wird hier auch als gestrichelte Linie gezeichnet,
            // aber die solidere Haupt-Mittellinie wird später darüber gezeichnet.
            ctx.moveTo(0, (h / 6) * i);
            ctx.lineTo(w, (h / 6) * i);
        }
        ctx.stroke();

        // Vertikale Linien (Drittelung der Breite)
        ctx.beginPath();
        ctx.moveTo(w / 3, 0);
        ctx.lineTo(w / 3, h);
        ctx.moveTo(2 * w / 3, 0);
        ctx.lineTo(2 * w / 3, h);
        ctx.stroke();

        ctx.restore(); // Ursprünglichen Zeichenzustand wiederherstellen

        // Optional: 18-Zonen-Nummerierung (nur wenn keine Aktionen gezeichnet werden sollen)
        if (!withActions) {
            ctx.save();
            // Zahlen: größer, fett, aber leicht transparent im Hintergrund
            const fontSize = Math.max(12, w * 0.055);
            ctx.font = `600 ${fontSize}px Inter, sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = 'rgba(17, 24, 39, 0.25)'; // text-gray-900 mit ~25% Opazität
            const zoneHeight = h / 6;
            const zoneWidth = w / 3;
            // Spielrichtung: unten -> oben
            // Zone 1 = unten links, Zone 18 = oben rechts
            for (let row = 0; row < 6; row++) {
                for (let col = 0; col < 3; col++) {
                    const cx = col * zoneWidth + zoneWidth / 2;
                    const cy = (5 - row) * zoneHeight + zoneHeight / 2;
                    const num = row * 3 + col + 1;
                    ctx.fillText(String(num), cx, cy);
                }
            }
            ctx.restore();
        }
    }
    
    // --- FUNKTION ZUM ZEICHNEN DER AKTIONEN (HOCHKANT) ---
    function drawActions(ctx, dataPoints, w, h) {
        ctx.globalAlpha = 0.7;
        for (const pt of dataPoints) {
            const x = pt.y * (w / 100); // y-Koordinate der Daten wird zu x auf der Canvas
            const y = pt.x * (h / 100); // x-Koordinate der Daten wird zu y auf der Canvas
            
            let actionColor = COLOR_PASS; // Standard
            if (pt.type === 'Shot' || pt.type === 'Goal') {
                actionColor = COLOR_SHOT;
            } else if (pt.type === 'Tackle' || pt.type === 'Interception' || pt.type === 'BallRecovery') {
                actionColor = COLOR_DEFENSE;
            } else if (['Corner', 'Freekick', 'ThrowIn'].includes(pt.type)) { // Standard-Events
                 actionColor = COLOR_STANDARD;
            }
            
            ctx.fillStyle = actionColor;
            ctx.beginPath();
            ctx.arc(x, y, w * 0.012, 0, 2 * Math.PI); // Punkte etwas kleiner
            ctx.fill();
        }
        ctx.globalAlpha = 1.0;
    }
    
    // --- NEU: FUNKTION ZUM ZEICHNEN VON PÄSSEN/SCHÜSSEN ALS LINIEN ---
    function drawActionLines(ctx, dataPoints, w, h) {
        ctx.save();
        ctx.lineWidth = Math.max(1.5, w * 0.006);
        ctx.globalAlpha = 0.6;

        for (const pt of dataPoints) {
            const startX = pt.y * (w / 100);
            const startY = pt.x * (h / 100);
            const endX = pt.end_y * (w / 100);
            const endY = pt.end_x * (h / 100);

            // Erfolgreiche Abstöße grün, erfolglose rot
            ctx.strokeStyle = pt.outcome === 'Successful' ? 'rgba(16, 185, 129, 0.7)' : 'rgba(239, 68, 68, 0.7)';
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
        }
        ctx.restore();
    }

    // Globaler Helper: Schaltet den Stil des globalen Switches
    function setGlobalViewActive(mode) {
        const btnDet = document.getElementById('btn-global-detail');
        const btnZon = document.getElementById('btn-global-zones');
        if (!btnDet || !btnZon) return;

        const active = ['bg-[#0A3F86]', 'text-white', 'hover:bg-[#0A3F86]', 'hover:text-white'];
        const inactive = ['bg-white', 'text-gray-700', 'hover:bg-gray-50', 'hover:text-gray-700'];

        [btnDet, btnZon].forEach(b => b.classList.remove(...active, ...inactive));
        btnDet.classList.add(...inactive);
        btnZon.classList.add(...inactive);

        if (mode === 'zones') {
            btnZon.classList.remove(...inactive);
            btnZon.classList.add(...active);
        } else {
            btnDet.classList.remove(...inactive);
            btnDet.classList.add(...active);
        }
    }

    // --- DATENANALYSE-FUNKTIONEN ---
    
    function getEventsForTeam(teamName, gameCount) {
        // Erlaube, dass "Hamburg" und "Hamburger SV" als gleichwertig gelten
        const teamNames = [teamName];
        if (teamName === 'Hamburger SV') teamNames.push('Hamburg');
        if (teamName === 'Hamburg') teamNames.push('Hamburger SV');
        // 1. Finde alle Spiele des ausgewählten Teams aus den STATISTIK-Daten
        const teamGames = dataset.filter(row => teamNames.includes(row.team));
        // 2. Finde die einzigartigen, letzten Match-IDs
        const uniqueMatchIds = [...new Set(teamGames.map(row => row.match_id))].sort().reverse();
        // 3. Wähle die Anzahl der zu analysierenden Spiele aus
        const matchesToAnalyze = uniqueMatchIds.slice(0, gameCount);
        // 4. Gib alle Events für diese Spiele aus den EVENT-Daten zurück
        return eventDataset.filter(row => matchesToAnalyze.includes(row.match_id) && teamNames.includes(row.team));
    }

    function getMatchIdsForTeam(teamName, gameCount) {
        const teamNames = [teamName];
        if (teamName === 'Hamburger SV') teamNames.push('Hamburg');
        if (teamName === 'Hamburg') teamNames.push('Hamburger SV');
        const teamGames = dataset.filter(row => teamNames.includes(row.team));
        const uniqueMatchIds = [...new Set(teamGames.map(row => row.match_id))].sort().reverse();
        return uniqueMatchIds.slice(0, gameCount);
    }

    function formatFormationName(name) {
        const s = String(name || '').trim();
        if (!s) return null;
        if (s.includes('-')) return s;
        if (/^\d{2,}$/.test(s)) return s.split('').join('-');
        return s;
    }

    function parseFormationParts(formationStr) {
        const f = String(formationStr || '').trim();
        if (!f) return null;
        const cleaned = f.replace(/\s+/g, '');
        const hyphenated = cleaned.includes('-') ? cleaned : (cleaned.match(/^\d{2,}$/) ? cleaned.split('').join('-') : cleaned);
        const parts = hyphenated.split('-').map(s => Number(s)).filter(n => Number.isFinite(n) && n > 0);
        return parts.length ? parts : null;
    }

    function getMostUsedStartingFormation(teamName, gameCount) {
        if (!formationsDataset || !formationsDataset.length) return null;
        const matchIds = new Set(getMatchIdsForTeam(teamName, gameCount).map(String));
        if (!matchIds.size) return null;

        const teamNames = [teamName];
        if (teamName === 'Hamburger SV') teamNames.push('Hamburg');
        if (teamName === 'Hamburg') teamNames.push('Hamburger SV');

        const counts = new Map();
        const matchSeen = new Set();

        for (const r of formationsDataset) {
            if (!r || r.match_id == null) continue;
            const mid = String(r.match_id);
            if (!matchIds.has(mid)) continue;
            const t = String(r.team_name || '').trim();
            if (!t || !teamNames.includes(t)) continue;
            if (Number(r.startMinuteExpanded) !== 0) continue;

            const f = formatFormationName(r.formationName);
            if (!f) continue;

            const keyMatch = `${mid}__${t}`;
            if (matchSeen.has(keyMatch)) continue;
            matchSeen.add(keyMatch);
            counts.set(f, (counts.get(f) || 0) + 1);
        }

        if (!counts.size) return null;
        let best = null;
        let bestC = -1;
        for (const [f, c] of counts.entries()) {
            if (c > bestC) { best = f; bestC = c; }
        }
        return { formation: best, count: bestC, matchesWithFormation: matchSeen.size };
    }

    function buildStartingXIByMatch(teamName, matchIdsSet) {
        const out = new Map();
        if (!formationsDataset || !formationsDataset.length) return out;

        const teamNames = [teamName];
        if (teamName === 'Hamburger SV') teamNames.push('Hamburg');
        if (teamName === 'Hamburg') teamNames.push('Hamburger SV');

        for (const r of formationsDataset) {
            if (!r || r.match_id == null) continue;
            const mid = String(r.match_id);
            if (!matchIdsSet.has(mid)) continue;
            const t = String(r.team_name || '').trim();
            if (!t || !teamNames.includes(t)) continue;
            if (Number(r.startMinuteExpanded) !== 0) continue;

            const playerIds = Array.isArray(r.playerIds) ? r.playerIds : null;
            const slots = Array.isArray(r.formationSlots) ? r.formationSlots : null;
            if (!playerIds || !slots || !playerIds.length || !slots.length) continue;

            const ids = new Set();
            for (let i = 0; i < slots.length && i < playerIds.length; i++) {
                const slot = Number(slots[i]);
                if (slot >= 1 && slot <= 11) {
                    const pid = Number(playerIds[i]);
                    if (Number.isFinite(pid)) ids.add(pid);
                }
            }
            if (ids.size) out.set(mid, ids);
        }
        return out;
    }

    // Standards helper: liefert Events für Standards in Team-Perspektive.
    // - mit-ball: Standards des Teams selbst
    // - gegen-ball: Standards gegen das Team (Events der Gegner, umgerechnet in Team-Koordinaten)
    function getStandardsEventsForTeam(teamName, gameCount, mode) {
        const own = getEventsForTeam(teamName, gameCount) || [];
        if (mode !== 'gegen-ball') return own;

        const matchIds = new Set((own || []).map(e => String(e.match_id ?? '')).filter(Boolean));
        if (!matchIds.size) return [];

        const invert = (v) => {
            if (v == null) return v;
            const n = Number(v);
            return Number.isFinite(n) ? (100 - n) : v;
        };

        // Gegner-Events in Team-Koordinaten umrechnen (180°), damit "gegen uns" korrekt in unserer Perspektive liegt.
        const against = (eventDataset || [])
            .filter(e => e && e.match_id != null && matchIds.has(String(e.match_id)))
            .filter(e => e.team != null && String(e.team) !== String(teamName))
            .map(e => ({
                ...e,
                x_coord: invert(e.x_coord),
                y_coord: invert(e.y_coord),
                end_x: invert(e.end_x),
                end_y: invert(e.end_y),
                // preserve original taker team for potential labeling/debugging
                __taker_team: e.team
            }));

        return against;
    }

    function resolveDflTeamName() {
        const teams = Array.from(new Set((dflRunningTeamMatches || []).map(r => String(r.team || '').trim()).filter(Boolean)));
        if (!teams.length) return null;

        const wanted = String(currentTeam || '').trim();
        if (!wanted) return null;

        const wantedLc = wanted.toLowerCase();
        const exact = teams.find(t => t.toLowerCase() === wantedLc);
        if (exact) return exact;

        // common mapping
        if (wantedLc.includes('hamburg') || wantedLc.includes('hsv')) {
            const hsv = teams.find(t => t.toLowerCase().includes('hamburger'));
            if (hsv) return hsv;
            if (teams.includes('Hamburger SV')) return 'Hamburger SV';
        }

        // fallback 1: substring match
        const contains = teams.find(t => t.toLowerCase().includes(wantedLc) || wantedLc.includes(t.toLowerCase()));
        if (contains) return contains;

        // fallback 2: token match (handles e.g. "SC Freiburg" vs "Sport-Club Freiburg",
        // or "Bayer Leverkusen" vs "Bayer 04 Leverkusen")
        const tokens = wantedLc
            .split(/[^a-z0-9\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df]+/g)
            .map(t => t.trim())
            .filter(t => t.length >= 4);
        if (!tokens.length) return null;

        let best = null;
        let bestScore = 0;
        for (const team of teams) {
            const tlc = team.toLowerCase();
            let score = 0;
            for (const tok of tokens) {
                if (tlc.includes(tok)) score++;
            }
            if (score > bestScore) {
                bestScore = score;
                best = team;
            }
        }
        return bestScore > 0 ? best : null;
    }

    function _dflOpponentsForBaseTeam(baseTeamName) {
        const base = String(baseTeamName || '').trim();
        if (!base || !Array.isArray(dflRunningTeamMatches) || !dflRunningTeamMatches.length) return [];
        const baseAlt = (base.toLowerCase() === 'hamburger sv') ? 'Hamburg' : (base.toLowerCase() === 'hamburg' ? 'Hamburger SV' : null);
        const isBase = (t) => {
            const s = String(t || '').trim();
            if (!s) return false;
            if (s === base) return true;
            if (baseAlt && s === baseAlt) return true;
            return false;
        };

        const opps = new Set();
        for (const r of dflRunningTeamMatches) {
            if (!r) continue;
            if (!isBase(r.team)) continue;
            const opp = String(r.opponent || '').trim();
            if (opp) opps.add(opp);
        }
        return Array.from(opps).sort((a, b) => a.localeCompare(b));
    }

    function _wrapLabelLines(label, maxCharsPerLine, maxLines) {
        const text = String(label || '').trim();
        if (!text) return [];

        const words = text.split(/\s+/).filter(Boolean);
        const lines = [];
        let current = '';
        const pushCurrent = () => {
            if (current) lines.push(current);
            current = '';
        };

        for (const w of words) {
            const next = current ? (current + ' ' + w) : w;
            if (next.length <= maxCharsPerLine) {
                current = next;
            } else {
                pushCurrent();
                // if a single word is longer than max, hard-split
                if (w.length > maxCharsPerLine) {
                    let start = 0;
                    while (start < w.length) {
                        lines.push(w.slice(start, start + maxCharsPerLine));
                        start += maxCharsPerLine;
                        if (lines.length >= maxLines) return lines.slice(0, maxLines);
                    }
                } else {
                    current = w;
                }
            }
            if (lines.length >= maxLines) return lines.slice(0, maxLines);
        }
        pushCurrent();
        return lines.slice(0, maxLines);
    }

    function _drawWrappedXLabels(ctx, labels, getX, baseY, opts) {
        const font = opts?.font || '10px Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
        const color = opts?.color || '#6b7280';
        const maxCharsPerLine = opts?.maxCharsPerLine ?? 18;
        const maxLines = opts?.maxLines ?? 3;
        const lineH = opts?.lineH ?? 11;
        const rotateRad = opts?.rotateRad ?? 0;

        ctx.save();
        ctx.fillStyle = color;
        ctx.font = font;
        ctx.textAlign = rotateRad ? 'left' : 'center';
        ctx.textBaseline = 'top';

        for (let i = 0; i < labels.length; i++) {
            const lines = _wrapLabelLines(labels[i], maxCharsPerLine, maxLines);
            const x = getX(i);
            if (rotateRad) {
                ctx.save();
                ctx.translate(x, baseY);
                ctx.rotate(rotateRad);
                for (let li = 0; li < lines.length; li++) {
                    ctx.fillText(lines[li], 0, li * lineH);
                }
                ctx.restore();
            } else {
                for (let li = 0; li < lines.length; li++) {
                    ctx.fillText(lines[li], x, baseY + li * lineH);
                }
            }
        }
        ctx.restore();
    }

    function renderPhysischTotalDistanceBarChart(windowRows) {
        const canvas = document.getElementById('physisch-distance-chart');
        if (!canvas) return;

        const rect = canvas.getBoundingClientRect();
        const w = Math.max(1, Math.floor(rect.width));
        const h = Math.max(1, Math.floor(rect.height));
        const dpr = window.devicePixelRatio || 1;
        canvas.width = Math.floor(w * dpr);
        canvas.height = Math.floor(h * dpr);

        const ctx = canvas.getContext('2d');
        if (!ctx) return;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.clearRect(0, 0, w, h);

        const rows = Array.isArray(windowRows) ? windowRows.slice() : [];
        const data = rows
            .map(r => {
                const total = Number(r.total_distance_net_km);
                const intense = Number(r.intense_distance_net_km);
                const pct = (Number.isFinite(total) && total > 0 && Number.isFinite(intense))
                    ? (intense / total) * 100
                    : null;
                return {
                    label: String(r.opponent || r.match_label || r.match_id || '').trim(),
                    value: total,
                    pct,
                };
            })
            .filter(d => d.label && Number.isFinite(d.value));

        // empty state
        if (!data.length) {
            ctx.fillStyle = '#6b7280';
            ctx.font = '12px Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('Keine DFL-Laufdaten', w / 2, h / 2);
            return;
        }

        // Title (no overlap with labels)
        ctx.fillStyle = '#111827';
        ctx.font = '11px Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        ctx.fillText('Gesamtlaufdistanz (Netto)', 4, 4);

        const padL = 38;
        const padR = 44; // room for secondary y-axis on the right
        const padT = 48; // extra header space for title + legend
        const padB = 96;
        const chartW = Math.max(1, w - padL - padR);
        const chartH = Math.max(1, h - padT - padB);

        const maxV = Math.max(...data.map(d => d.value));
        const minV = Math.min(...data.map(d => d.value));
        const top = Math.ceil((maxV + 1) / 5) * 5;
        const bottom = Math.floor((Math.max(0, minV - 1)) / 5) * 5;
        const range = Math.max(1, top - bottom);

        // grid + left y ticks (km)
        ctx.strokeStyle = '#e5e7eb';
        ctx.fillStyle = '#6b7280';
        ctx.lineWidth = 1;
        ctx.font = '10px Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        const ticks = 4;
        for (let i = 0; i <= ticks; i++) {
            const t = bottom + (range * i) / ticks;
            const y = padT + chartH - (chartH * i) / ticks;
            ctx.beginPath();
            ctx.moveTo(padL, y);
            ctx.lineTo(padL + chartW, y);
            ctx.stroke();
            ctx.fillText(String(Math.round(t)), padL - 6, y);
        }

        // right y-axis (percent)
        const pctVals = data.map(d => d.pct).filter(v => Number.isFinite(v));
        const pctMax = pctVals.length ? Math.min(100, Math.max(...pctVals)) : 0;
        const pctTop = Math.max(10, Math.ceil((pctMax + 1) / 5) * 5);
        const pctBottom = 0;
        const pctRange = Math.max(1, pctTop - pctBottom);

        ctx.save();
        ctx.strokeStyle = '#d1d5db';
        ctx.fillStyle = '#6b7280';
        ctx.lineWidth = 1;
        ctx.font = '10px Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        const rx = padL + chartW;
        // axis line
        ctx.beginPath();
        ctx.moveTo(rx, padT);
        ctx.lineTo(rx, padT + chartH);
        ctx.stroke();
        // ticks
        for (let i = 0; i <= ticks; i++) {
            const t = pctBottom + (pctRange * i) / ticks;
            const y = padT + chartH - (chartH * i) / ticks;
            ctx.beginPath();
            ctx.moveTo(rx, y);
            ctx.lineTo(rx + 4, y);
            ctx.stroke();
            ctx.fillText(`${Math.round(t)}%`, rx + 6, y);
        }
        // axis label
        ctx.save();
        ctx.translate(rx + 28, padT + chartH / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('% Intensive', 0, 0);
        ctx.restore();
        ctx.restore();

        // axis label (km)
        ctx.save();
        ctx.translate(12, padT + chartH / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = '#6b7280';
        ctx.fillText('km', 0, 0);
        ctx.restore();

        // bars
        const n = data.length;
        const gap = Math.max(6, Math.floor(chartW * 0.03));
        const barW = Math.max(8, Math.floor((chartW - gap * (n - 1)) / n));

        for (let i = 0; i < n; i++) {
            const d = data[i];
            const x = padL + i * (barW + gap);
            const norm = (d.value - bottom) / range;
            const barH = Math.max(0, Math.min(chartH, norm * chartH));
            const y = padT + (chartH - barH);

            ctx.fillStyle = '#0A3F86';
            ctx.fillRect(x, y, barW, barH);
        }

        // percent line overlay (right axis)
        const linePts = data
            .map((d, i) => ({
                i,
                pct: d.pct,
            }))
            .filter(p => Number.isFinite(p.pct));

        if (linePts.length) {
            ctx.save();
            ctx.strokeStyle = '#ef4444';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let k = 0; k < linePts.length; k++) {
                const p = linePts[k];
                const cx = padL + p.i * (barW + gap) + barW / 2;
                const normPct = (p.pct - pctBottom) / pctRange;
                const cy = padT + chartH - (normPct * chartH);
                if (k === 0) ctx.moveTo(cx, cy);
                else ctx.lineTo(cx, cy);
            }
            ctx.stroke();

            // markers
            ctx.fillStyle = '#ef4444';
            for (const p of linePts) {
                const cx = padL + p.i * (barW + gap) + barW / 2;
                const normPct = (p.pct - pctBottom) / pctRange;
                const cy = padT + chartH - (normPct * chartH);
                ctx.beginPath();
                ctx.arc(cx, cy, 2.5, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }

        // legend (top-right, like the chart below)
        ctx.save();
        ctx.font = '10px Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        const ly = 22; // more distance from title
        const legendW = 160;
        const lx = Math.max(padL, (padL + chartW) - legendW);
        ctx.fillStyle = '#0A3F86';
        ctx.fillRect(lx, ly, 10, 10);
        ctx.fillStyle = '#374151';
        ctx.fillText('Netto km', lx + 14, ly);
        ctx.strokeStyle = '#ef4444';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(lx + 78, ly + 6);
        ctx.lineTo(lx + 98, ly + 6);
        ctx.stroke();
        ctx.fillStyle = '#ef4444';
        ctx.beginPath();
        ctx.arc(lx + 88, ly + 6, 2.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#374151';
        ctx.fillText('% Intensive', lx + 104, ly);
        ctx.restore();

        // x labels (opponents) - wrapped, not truncated
        _drawWrappedXLabels(
            ctx,
            data.map(d => d.label),
            (i) => (padL + i * (barW + gap) + barW / 2),
            padT + chartH + 10,
            { font: '9.5px Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif', maxCharsPerLine: 16, maxLines: 2, lineH: 11, rotateRad: Math.PI / 3 }
        );
    }

    function renderPhysischTempoIntenseBarChart(windowRows) {
        const canvas = document.getElementById('physisch-tempo-intense-chart');
        if (!canvas) return;

        const rect = canvas.getBoundingClientRect();
        const w = Math.max(1, Math.floor(rect.width));
        const h = Math.max(1, Math.floor(rect.height));
        const dpr = window.devicePixelRatio || 1;
        canvas.width = Math.floor(w * dpr);
        canvas.height = Math.floor(h * dpr);

        const ctx = canvas.getContext('2d');
        if (!ctx) return;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.clearRect(0, 0, w, h);

        const rows = Array.isArray(windowRows) ? windowRows.slice() : [];
        const data = rows
            .map(r => ({
                label: String(r.opponent || r.match_label || r.match_id || '').trim(),
                tempo: Number(r.tempo_distance_net_km),
                sprint: Number(r.sprint_distance_net_km),
            }))
            .filter(d => d.label && (Number.isFinite(d.tempo) || Number.isFinite(d.sprint)));

        if (!data.length) {
            ctx.fillStyle = '#6b7280';
            ctx.font = '12px Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('Keine DFL-Laufdaten', w / 2, h / 2);
            return;
        }

        const padL = 38;
        const padR = 10;
        const padT = 48; // extra header space (more distance below legend)
        const padB = 96;
        const chartW = Math.max(1, w - padL - padR);
        const chartH = Math.max(1, h - padT - padB);

        const maxV = Math.max(
            ...data.map(d => Number.isFinite(d.tempo) ? d.tempo : 0),
            ...data.map(d => Number.isFinite(d.sprint) ? d.sprint : 0)
        );
        const top = Math.ceil((maxV + 0.25) / 1) * 1;
        const bottom = 0;
        const range = Math.max(1e-6, top - bottom);

        // title + legend (separated, no overlap)
        ctx.fillStyle = '#111827';
        ctx.font = '11px Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        ctx.fillText('Distanz Tempo & Sprints (Netto)', 4, 2);

        const colorTempo = '#0A3F86';
        const colorSprint = '#2563eb';
        // legend top-right
        ctx.font = '10px Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
        ctx.textBaseline = 'top';
        ctx.textAlign = 'left';
        const legendY = 22;
        const legendX = Math.max(padL, w - 150);
        ctx.fillStyle = colorTempo;
        ctx.fillRect(legendX, legendY, 10, 10);
        ctx.fillStyle = '#374151';
        ctx.fillText('Tempo', legendX + 14, legendY);
        ctx.fillStyle = colorSprint;
        ctx.fillRect(legendX + 72, legendY, 10, 10);
        ctx.fillStyle = '#374151';
        ctx.fillText('Sprints', legendX + 86, legendY);

        // grid + y ticks
        ctx.strokeStyle = '#e5e7eb';
        ctx.fillStyle = '#6b7280';
        ctx.lineWidth = 1;
        ctx.font = '10px Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        const ticks = 4;
        for (let i = 0; i <= ticks; i++) {
            const t = bottom + (range * i) / ticks;
            const y = padT + chartH - (chartH * i) / ticks;
            ctx.beginPath();
            ctx.moveTo(padL, y);
            ctx.lineTo(padL + chartW, y);
            ctx.stroke();
            ctx.fillText(String(Math.round(t * 10) / 10), padL - 6, y);
        }

        // axis label (km)
        ctx.save();
        ctx.translate(12, padT + chartH / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = '#6b7280';
        ctx.fillText('km', 0, 0);
        ctx.restore();

        // grouped bars
        const n = data.length;
        const groupGap = Math.max(6, Math.floor(chartW * 0.03));
        const groupW = Math.max(10, Math.floor((chartW - groupGap * (n - 1)) / n));
        const barGap = 4;
        const barW = Math.max(4, Math.floor((groupW - barGap) / 2));

        for (let i = 0; i < n; i++) {
            const d = data[i];
            const gx = padL + i * (groupW + groupGap);
            const tVal = Number.isFinite(d.tempo) ? d.tempo : 0;
            const sVal = Number.isFinite(d.sprint) ? d.sprint : 0;

            const tH = Math.max(0, Math.min(chartH, ((tVal - bottom) / range) * chartH));
            const sH = Math.max(0, Math.min(chartH, ((sVal - bottom) / range) * chartH));
            const baseY = padT + chartH;

            ctx.fillStyle = colorTempo;
            ctx.fillRect(gx, baseY - tH, barW, tH);

            ctx.fillStyle = colorSprint;
            ctx.fillRect(gx + barW + barGap, baseY - sH, barW, sH);
        }

        // x labels (opponents) - wrapped, not truncated
        _drawWrappedXLabels(
            ctx,
            data.map(d => d.label),
            (i) => (padL + i * (groupW + groupGap) + groupW / 2),
            padT + chartH + 10,
            { font: '9.5px Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif', maxCharsPerLine: 16, maxLines: 2, lineH: 11, rotateRad: Math.PI / 3 }
        );
    }

    function renderPhysischBbVsGgBallDonut(bbKm, ggBallKm, canvasId = 'physisch-bb-ggball-donut') {
        const canvas = document.getElementById(canvasId);
        if (!canvas) return;

        // Ensure the canvas always has a measurable size.
        canvas.style.display = 'block';
        canvas.style.width = '100%';
        canvas.style.height = '100%';

        const rect = canvas.getBoundingClientRect();
        let w = Math.floor(rect.width);
        let h = Math.floor(rect.height);
        if (w < 2 || h < 2) {
            const cs = window.getComputedStyle(canvas);
            const cw = Math.floor(parseFloat(cs.width || '0'));
            const ch = Math.floor(parseFloat(cs.height || '0'));
            w = cw > 0 ? cw : w;
            h = ch > 0 ? ch : h;
        }
        if (w < 2 || h < 2) {
            const p = canvas.parentElement;
            if (p) {
                const pr = p.getBoundingClientRect();
                w = Math.floor(pr.width);
                h = Math.floor(pr.height);
            }
        }
        // last resort: match the Tailwind w-36/h-36 (144px)
        if (w < 2) w = 144;
        if (h < 2) h = 144;
        const dpr = window.devicePixelRatio || 1;
        canvas.width = Math.floor(w * dpr);
        canvas.height = Math.floor(h * dpr);

        const ctx = canvas.getContext('2d');
        if (!ctx) return;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.clearRect(0, 0, w, h);

        const bb = Number.isFinite(Number(bbKm)) ? Number(bbKm) : 0;
        const out = Number.isFinite(Number(ggBallKm)) ? Number(ggBallKm) : 0;
        const total = bb + out;

        const cx = w / 2;
        const cy = h / 2;
        const base = Math.min(w, h);
        const r = Math.max(10, base * 0.42);
        const thickness = Math.max(8, Math.min(16, base * 0.14));
        const start = -Math.PI / 2; // 12 o'clock

        // base ring
        ctx.save();
        ctx.lineCap = 'butt';
        ctx.lineWidth = thickness;
        ctx.strokeStyle = '#d1d5db';
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI * 2);
        ctx.stroke();

        if (total > 0) {
            const fracBB = bb / total;
            const mid = start + fracBB * Math.PI * 2;

            // BB segment
            ctx.strokeStyle = '#0A3F86';
            ctx.beginPath();
            ctx.arc(cx, cy, r, start, mid);
            ctx.stroke();

            // ggBall segment
            ctx.strokeStyle = '#2563eb';
            ctx.beginPath();
            ctx.arc(cx, cy, r, mid, start + Math.PI * 2);
            ctx.stroke();
        }
        ctx.restore();

        // center value (sum)
        ctx.save();
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = '#111827';
        const numSize = Math.max(12, Math.min(18, Math.round(base * 0.22)));
        ctx.font = `600 ${numSize}px Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif`;
        const centerText = total > 0 ? (Math.round(total * 10) / 10).toFixed(1) : '0.0';
        ctx.fillText(centerText, cx, cy - 6);
        ctx.fillStyle = '#6b7280';
        const unitSize = Math.max(9, Math.min(10, Math.round(base * 0.12)));
        ctx.font = `${unitSize}px Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif`;
        ctx.fillText('km', cx, cy + 12);
        ctx.restore();
    }

    // --- INFO-BLÖCKE AKTUALISIEREN ---
    function updateInfoBlocks(teamEvents) {
        const infoLinksRoot = document.getElementById('info-links');
        const infoAufbau = document.getElementById('info-content-aufbau');
        const infoKontrolle = document.getElementById('info-content-kontrolle');
        const infoZumTor = document.getElementById('info-content-zumtor');
        const infoRechts = document.getElementById('info-content-rechts');

        // Merke geöffnete Unterpunkte, um den Zustand nach Rebuild zu erhalten
        const previouslyOpenPhases = Array.from(infoLinksRoot.querySelectorAll('.accordion-item[data-phase].open'))
            .map(el => el.getAttribute('data-phase'));

        const matchIds = new Set(teamEvents.map(e => e.match_id));
    const gamesCount = matchIds.size || 1;

        // --- KPIs für die Phasen berechnen ---

        // 1. Aufbau: Abstoß-Analyse (aus Events berechnet, wie in pitch_test)
        const goalKicksForAxis = teamEvents.filter(e => e.is_goalkick === true && e.pass_length != null);
        const avgGoalKickDistance = (() => {
            if (!goalKicksForAxis.length) return 0;
            const sum = goalKicksForAxis.reduce((a, b) => a + Number(b.pass_length), 0);
            return Math.round((sum / goalKicksForAxis.length) * 10) / 10; // eine Nachkommastelle
        })();

        // Position des Markers auf der Skala (0-100%), 70m als Obergrenze (60+ Tick)
        const markerPosition = Math.min(100, Math.max(0, (avgGoalKickDistance / 70) * 100));

        // 2. Strukturfindung
        const structurePasses = teamEvents.filter(e => e.event_type === 'Pass' && e.outcome === 'Successful' && e.x_coord >= 33.3 && e.x_coord < 66.6).length;

        // Spielkontrolle: Ballbesitz (EXAKT wie in kennzahlen.py)
        // processed_data.json enthält "ballbesitz" pro Spieler als Prozent der Match-Länge.
        // Team-Ballbesitz = Summe dieser Spieler-% pro match_id; bei Mehrfachauswahl Mittelwert über Matches.
        const possessionPct = (() => {
            const rows = (dataset || [])
                .filter(r => r.team === currentTeam && matchIds.has(r.match_id) && r.ballbesitz != null);

            const sumByMatch = new Map();
            for (const r of rows) {
                const mid = String(r.match_id ?? '');
                const v = Number(r.ballbesitz);
                if (!Number.isFinite(v)) continue;
                sumByMatch.set(mid, (sumByMatch.get(mid) || 0) + v);
            }

            if (!sumByMatch.size) return null;
            const vals = Array.from(sumByMatch.values());
            const avg = vals.reduce((a, x) => a + x, 0) / vals.length;
            return Math.round(avg * 10) / 10; // 1 Nachkommastelle
        })();

        const possessionMinPer90 = possessionPct != null
            ? Math.round(((Number(possessionPct) / 100) * 90) * 10) / 10
            : null;

        // Spielkontrolle: Ø Passfolgenlänge (Anzahl erfolgreicher Pässe bis Ballverlust/Teamwechsel)
        const avgPassSequenceLen = (() => {
            const periodOrder = new Map([
                ['FirstHalf', 1],
                ['SecondHalf', 2],
                ['FirstPeriodOfExtraTime', 3],
                ['SecondPeriodOfExtraTime', 4],
                ['PenaltyShootout', 5],
            ]);

            const isRelevant = (e) => {
                const t = e.event_type;
                if (!t) return false;
                if (t === 'Start' || t === 'End' || t === 'Substitution' || t === 'FormationChange') return false;
                return true;
            };

            const sel = (eventDataset || []).filter(e => matchIds.has(e.match_id));
            if (!sel.length) return null;

            const byMatch = new Map();
            for (const e of sel) {
                const mid = String(e.match_id ?? '');
                if (!mid) continue;
                if (!byMatch.has(mid)) byMatch.set(mid, []);
                byMatch.get(mid).push(e);
            }

            let seqCount = 0;
            let seqSum = 0;

            const finalize = (passes) => {
                if (!passes || passes <= 0) return;
                seqCount += 1;
                seqSum += passes;
            };

            for (const rows of byMatch.values()) {
                rows.sort((a, b) => {
                    const pa = periodOrder.get(a.period) || 99;
                    const pb = periodOrder.get(b.period) || 99;
                    if (pa !== pb) return pa - pb;
                    const ma = Number(a.minute || 0);
                    const mb = Number(b.minute || 0);
                    if (ma !== mb) return ma - mb;
                    const sa = Number(a.second || 0);
                    const sb = Number(b.second || 0);
                    if (sa !== sb) return sa - sb;
                    const ea = Number(a.eventId || 0);
                    const eb = Number(b.eventId || 0);
                    if (ea !== eb) return ea - eb;
                    return Number(a.id || 0) - Number(b.id || 0);
                });

                let possTeam = null;
                let passCount = 0;

                for (const e of rows) {
                    if (!isRelevant(e)) continue;
                    const team = e.team;
                    if (!team) continue;

                    // Teamwechsel beendet eine aktuelle Sequenz
                    if (possTeam && team !== possTeam) {
                        if (possTeam === currentTeam) finalize(passCount);
                        possTeam = null;
                        passCount = 0;
                    }

                    if (!possTeam) {
                        possTeam = team;
                        passCount = 0;
                    }

                    if (possTeam !== currentTeam) continue;

                    if (e.event_type === 'Pass') {
                        if (e.outcome === 'Successful') {
                            passCount += 1;
                        } else {
                            // Ballverlust durch Fehlpass
                            finalize(passCount);
                            possTeam = null;
                            passCount = 0;
                        }
                    }
                }

                if (possTeam === currentTeam) finalize(passCount);
            }

            if (!seqCount) return 0;
            return Math.round((seqSum / seqCount) * 10) / 10;
        })();

        // Spielkontrolle: Field Tilt (Territoriale Dominanz)
        // Definition: Verhältnis der Aktionen im Angriffsdrittel (x_coord > 66.6) zwischen Team A und Team B.
        // Ein Field Tilt von 70% bedeutet: 70% aller Aktionen im letzten Drittel stammen von Team A.
        const fieldTilt = (() => {
            const ballEvents = new Set(['Pass', 'TakeOn', 'BallTouch', 'Shot', 'Goal', 'BallRecovery', 'Clearance', 'SavedShot', 'MissedShots']);

            const sel = (eventDataset || []).filter(e => matchIds.has(e.match_id));
            if (!sel.length) return null;

            const byMatch = new Map();
            for (const e of sel) {
                const mid = String(e.match_id ?? '');
                if (!mid) continue;
                if (!byMatch.has(mid)) byMatch.set(mid, []);
                byMatch.get(mid).push(e);
            }

            const perMatchPct = [];
            const perMatchTeamCounts = [];
            const perMatchOppCounts = [];
            for (const [mid, rows] of byMatch.entries()) {
                const attThird = rows.filter(e => {
                    const x = Number(e.x_coord);
                    const t = e.event_type;
                    if (!Number.isFinite(x) || x <= 66.6) return false;
                    if (!t || !ballEvents.has(t)) return false;
                    return true;
                });
                if (!attThird.length) continue;

                const teamCount = attThird.filter(e => e.team === currentTeam).length;
                const oppCount = attThird.filter(e => e.team !== currentTeam).length;
                const denom = teamCount + oppCount;
                if (!denom) continue;
                perMatchPct.push((teamCount / denom) * 100);
                perMatchTeamCounts.push(teamCount);
                perMatchOppCounts.push(oppCount);
            }

            if (!perMatchPct.length) return null;
            const avgPct = perMatchPct.reduce((a, v) => a + v, 0) / perMatchPct.length;
            const avgTeam = perMatchTeamCounts.reduce((a, v) => a + v, 0) / perMatchTeamCounts.length;
            const avgOpp = perMatchOppCounts.reduce((a, v) => a + v, 0) / perMatchOppCounts.length;
            return {
                pct: Math.round(avgPct * 10) / 10,
                teamPer90: Math.round(avgTeam * 10) / 10,
                oppPer90: Math.round(avgOpp * 10) / 10,
            };
        })();

        const fieldTiltPct = fieldTilt ? fieldTilt.pct : null;
        const fieldTiltTeamPer90 = fieldTilt ? fieldTilt.teamPer90 : null;
        const fieldTiltOppPer90 = fieldTilt ? fieldTilt.oppPer90 : null;

        // Spielkontrolle: Build-up Attacks (>=10 Pässe) die in Schuss oder Ballkontakt/Pass in den Strafraum enden
        const buildUpAttack = (() => {
            const shotTypes = new Set(['Shot', 'Goal', 'MissedShots', 'SavedShot']);
            const periodOrder = new Map([
                ['FirstHalf', 1],
                ['SecondHalf', 2],
                ['FirstPeriodOfExtraTime', 3],
                ['SecondPeriodOfExtraTime', 4],
                ['PenaltyShootout', 5],
            ]);
            const inBox = (x, y) => {
                const nx = Number(x);
                const ny = Number(y);
                if (!Number.isFinite(nx) || !Number.isFinite(ny)) return false;
                // Approximierter Strafraum in 0-100 Koordinaten
                const BOX_X_MIN = 83.0;
                const BOX_Y_MIN = 21.1;
                const BOX_Y_MAX = 78.9;
                return nx >= BOX_X_MIN && ny >= BOX_Y_MIN && ny <= BOX_Y_MAX;
            };

            const isRelevant = (e) => {
                const t = e.event_type;
                if (!t) return false;
                // ignoriere Meta-Events
                if (t === 'Start' || t === 'End' || t === 'Substitution' || t === 'FormationChange') return false;
                return true;
            };

            const isTerminal = (e) => {
                const t = e.event_type;
                if (shotTypes.has(t)) return true;
                if (t === 'BallTouch' && inBox(e.x_coord, e.y_coord)) return true;
                if (t === 'TakeOn' && inBox(e.x_coord, e.y_coord)) return true;
                if (t === 'Pass' && e.outcome === 'Successful' && inBox(e.end_x, e.end_y)) return true;
                return false;
            };

            const sel = (eventDataset || []).filter(e => matchIds.has(e.match_id) && e.team);
            if (!sel.length) return { buildUpCount: 0, per90: 0 };

            // Group by match for stable ordering
            const byMatch = new Map();
            for (const e of sel) {
                const mid = String(e.match_id ?? '');
                if (!mid) continue;
                if (!byMatch.has(mid)) byMatch.set(mid, []);
                byMatch.get(mid).push(e);
            }

            let buildUpCount = 0;

            const finalize = (poss) => {
                if (!poss || poss.team !== currentTeam) return;
                if (poss.passes >= 10 && poss.endedInTerminal) buildUpCount += 1;
            };

            for (const rows of byMatch.values()) {
                rows.sort((a, b) => {
                    const pa = periodOrder.get(a.period) || 99;
                    const pb = periodOrder.get(b.period) || 99;
                    if (pa !== pb) return pa - pb;
                    const ma = Number(a.minute || 0);
                    const mb = Number(b.minute || 0);
                    if (ma !== mb) return ma - mb;
                    const sa = Number(a.second || 0);
                    const sb = Number(b.second || 0);
                    if (sa !== sb) return sa - sb;
                    const ea = Number(a.eventId || 0);
                    const eb = Number(b.eventId || 0);
                    if (ea !== eb) return ea - eb;
                    return Number(a.id || 0) - Number(b.id || 0);
                });

                let poss = null;
                for (const e of rows) {
                    if (!isRelevant(e)) continue;
                    const team = e.team;
                    if (!team) continue;

                    // possession switch
                    if (poss && team !== poss.team) {
                        finalize(poss);
                        poss = null;
                    }

                    if (!poss) {
                        poss = { team, passes: 0, endedInTerminal: false };
                    }

                    if (e.event_type === 'Pass') poss.passes += 1;

                    if (isTerminal(e)) {
                        poss.endedInTerminal = true;
                        finalize(poss);
                        poss = null;
                    }
                }

                // finalize leftover possession at match end
                if (poss) finalize(poss);
            }

            const per90 = Math.round((buildUpCount / gamesCount) * 10) / 10;
            return { buildUpCount, per90 };
        })();

        // 3. Zum Tor
        const finalThirdEntries = teamEvents.filter(e => e.end_x > 66.6 && e.x_coord <= 66.6).length;
        // Schüsse: in diesem Dataset kommen v.a. "MissedShots", "SavedShot" und "Goal" vor.
        // "isShot" ist bei MissedShots ebenfalls true und eignet sich daher NICHT für "aufs Tor".
        const shotsAll = teamEvents.filter(e => ['Shot', 'Goal', 'MissedShots', 'SavedShot'].includes(e.event_type));
        const shotsOnTarget = shotsAll.filter(e => ['SavedShot', 'Goal'].includes(e.event_type));
        const goalsCount = shotsAll.filter(e => e.event_type === 'Goal' || e.isGoal === true).length;
        // Angriffsseite: Verteilung der Eintritte (nur Starts außerhalb des letzten Drittels)
        const entryPassesZT = teamEvents.filter(e => e.event_type === 'Pass' && e.end_x != null && e.end_y != null && Number(e.end_x) >= 66.6 && Number(e.x_coord) < 66.6);
        const sideCountsZT = { left: 0, center: 0, right: 0 };
        entryPassesZT.forEach(p => {
            const y = Number(p.end_y);
            if (y < 33.3) sideCountsZT.left++; else if (y < 66.6) sideCountsZT.center++; else sideCountsZT.right++;
        });
        const sideTotZT = Math.max(1, entryPassesZT.length);
        const sidePctZT = {
            left: Math.round((sideCountsZT.left / sideTotZT) * 100),
            center: Math.round((sideCountsZT.center / sideTotZT) * 100),
            right: Math.round((sideCountsZT.right / sideTotZT) * 100)
        };

        // --- Progressive Pässe: Zonen-Auswertung (Start- und Endzone auf 18-Zonen-Raster) ---
        function mapTo18Zone(x, y) {
            if (x == null || y == null) return null;
            const nx = Math.max(0, Math.min(99.999, Number(x)));
            const ny = Math.max(0, Math.min(99.999, Number(y)));
            const rowFromBottom = Math.floor((nx / 100) * 6); // 0 (unten) .. 5 (oben)
            const col = Math.floor((ny / 100) * 3);          // 0 (links) .. 2 (rechts)
            const rowFromTop = 5 - rowFromBottom;
            return rowFromTop * 3 + col + 1; // Zone 1 unten links, 18 oben rechts
        }

        // Gleiche Logik wie in der Mannschaftstaktik: Progressive Pässe heuristisch definieren,
        // damit wir auch ohne is_progressive-Flag arbeiten können
        const progressivePasses = teamEvents.filter(e => {
            if (e.event_type !== 'Pass') return false;
            // Exclude corners: they should not count as progressive passes.
            if (e.is_corner === true) return false;
            if (e.end_x == null || e.x_coord == null) return false;
            const gain = Number(e.end_x) - Number(e.x_coord);
            // einfacher Schwellenwert, kann bei Bedarf angepasst werden
            return gain >= 20; // mindestens 20m Vorwärtsgewinn
        });
        const totalProg = progressivePasses.length;
        let sumGain = 0;
        const startZoneCounts = new Map();
        const endZoneCounts = new Map();
        let succProg = 0;

        progressivePasses.forEach(p => {
            if (p.prog_gain_m != null) {
                sumGain += Number(p.prog_gain_m);
            }
            if (p.outcome === 'Successful') succProg++;
            const sz = mapTo18Zone(p.x_coord, p.y_coord);
            const ez = mapTo18Zone(p.end_x, p.end_y);
            if (sz != null) {
                startZoneCounts.set(sz, (startZoneCounts.get(sz) || 0) + 1);
            }
            if (ez != null) {
                endZoneCounts.set(ez, (endZoneCounts.get(ez) || 0) + 1);
            }
        });

        const avgProgGain = totalProg ? Math.round((sumGain / totalProg) * 10) / 10 : 0;
        const failProg = totalProg - succProg;

        function getMaxZone(map) {
            if (!map.size) return { zone: '-', count: 0 };
            let maxZone = null;
            let maxVal = -1;
            for (const [z, c] of map.entries()) {
                if (c > maxVal) { maxVal = c; maxZone = z; }
            }
            return { zone: maxZone, count: maxVal };
        }

        const maxStart = getMaxZone(startZoneCounts);
        const maxEnd = getMaxZone(endZoneCounts);

        // --- KPIs für Grundstruktur ---
        const passesAll = teamEvents.filter(e => e.event_type === 'Pass');
        const passesSucc = passesAll.filter(e => e.outcome === 'Successful');
        // Drittel: Startposition entscheidet (x_coord)
        const firstThirdAll = passesAll.filter(e => Number(e.x_coord) < 33.3);
        const firstThirdSucc = firstThirdAll.filter(e => e.outcome === 'Successful');
        const secondThirdAll = passesAll.filter(e => Number(e.x_coord) >= 33.3 && Number(e.x_coord) < 66.6);
        const secondThirdSucc = secondThirdAll.filter(e => e.outcome === 'Successful');

        // Hilfsfunktionen: Ø Pässe/Phase bis Ballverlust und PPDA und Top-5 Empfänger
        function computePassesPerPossession(allEvs, teamName, matchIds) {
            const evs = allEvs.filter(e => matchIds.has(e.match_id)).map((e, idx) => ({
                team: e.team,
                type: e.event_type,
                period: e.period ?? 0,
                minute: Number(e.minute ?? 0),
                second: Number(e.second ?? 0),
                __i: idx
            }));
            if (!evs.length) return null;
            evs.sort((a, b) => (a.period - b.period) || (a.minute - b.minute) || (a.second - b.second) || (a.__i - b.__i));
            const possessions = [];
            let currentTeamName = null;
            let ourPasses = 0;
            let inOurPoss = false;
            for (const ev of evs) {
                if (currentTeamName === null) {
                    currentTeamName = ev.team;
                    inOurPoss = (currentTeamName === teamName);
                    ourPasses = 0;
                } else if (ev.team !== currentTeamName) {
                    if (inOurPoss) possessions.push(ourPasses);
                    currentTeamName = ev.team;
                    inOurPoss = (currentTeamName === teamName);
                    ourPasses = 0;
                }
                if (inOurPoss && ev.team === teamName && ev.type === 'Pass') ourPasses++;
            }
            if (inOurPoss) possessions.push(ourPasses);
            if (!possessions.length) return null;
            const avg = possessions.reduce((a,b) => a + b, 0) / possessions.length;
            return Math.round(avg * 10) / 10;
        }

        function computePPDA(allEvs, teamName, matchIds) {
            const sel = allEvs.filter(e => matchIds.has(e.match_id));
            const oppPasses = sel.filter(e => e.team !== teamName && e.event_type === 'Pass' && e.x_coord != null && Number(e.x_coord) < 60).length;
            const ourDef = sel.filter(e => e.team === teamName && ['Tackle','Interception','BallRecovery','Foul'].includes(e.event_type) && e.x_coord != null && Number(e.x_coord) < 60).length;
            if (ourDef === 0) return null;
            return Math.round((oppPasses / ourDef) * 10) / 10;
        }

        function getLastName(name) {
            if (!name || typeof name !== 'string') return '';
            const parts = name.trim().split(/\s+/).filter(Boolean);
            return parts.length ? parts[parts.length - 1] : name;
        }

        function topReceivers(allEvs, teamName, matchIds, minutesByName, gamesCount) {
            const evs = allEvs.filter(e => matchIds.has(e.match_id) && e.playerId != null)
                .map((e, idx) => ({
                    team: e.team,
                    playerId: Number(e.playerId),
                    player_name: e.player_name || '',
                    type: e.event_type,
                    outcome: e.outcome,
                    period: e.period ?? 0,
                    minute: Number(e.minute ?? 0),
                    second: Number(e.second ?? 0),
                    x: (e.x_coord != null ? Number(e.x_coord) : null),
                    y: (e.y_coord != null ? Number(e.y_coord) : null),
                    ex: (e.end_x != null ? Number(e.end_x) : null),
                    ey: (e.end_y != null ? Number(e.end_y) : null),
                    __i: idx
                }));
            evs.sort((a, b) => (a.period - b.period) || (a.minute - b.minute) || (a.second - b.second) || (a.__i - b.__i));
            const nameById = new Map();
            evs.forEach(e => nameById.set(e.playerId, e.player_name));
            const counts = new Map();
            const posAgg = new Map(); // receiverId -> { sx, sy, n }
            for (let i = 0; i < evs.length; i++) {
                const ev = evs[i];
                if (ev.team !== teamName || ev.type !== 'Pass' || ev.outcome !== 'Successful') continue;
                const t0 = ev.minute * 60 + ev.second;
                const per0 = ev.period;
                let receiverId = null;
                // Use end location of the pass as the receiver position (moment of receiving).
                let receiverPos = (Number.isFinite(ev.ex) && Number.isFinite(ev.ey)) ? { x: ev.ex, y: ev.ey } : null;
                for (let j = i + 1; j < evs.length; j++) {
                    const nxt = evs[j];
                    if (nxt.period !== per0) break;
                    const dt = (nxt.minute * 60 + nxt.second) - t0;
                    if (dt < 0) continue;
                    if (dt > 10) break;
                    if (nxt.team === teamName && nxt.playerId && nxt.playerId !== ev.playerId) {
                        receiverId = nxt.playerId;
                        // Fallback: if pass end coords are missing, approximate with receiver's next on-ball position.
                        if (!receiverPos && Number.isFinite(nxt.x) && Number.isFinite(nxt.y)) receiverPos = { x: nxt.x, y: nxt.y };
                        break;
                    }
                }
                if (!receiverId) continue;
                counts.set(receiverId, (counts.get(receiverId) || 0) + 1);
                if (receiverPos) {
                    const cur = posAgg.get(receiverId) || { sx: 0, sy: 0, n: 0 };
                    cur.sx += receiverPos.x;
                    cur.sy += receiverPos.y;
                    cur.n += 1;
                    posAgg.set(receiverId, cur);
                }
            }
            const rows = [...counts.entries()].map(([pid, cnt]) => {
                const full = nameById.get(pid) || String(pid);
                const agg = posAgg.get(pid);
                const avgX = (agg && agg.n) ? (agg.sx / agg.n) : null;
                const avgY = (agg && agg.n) ? (agg.sy / agg.n) : null;
                const mins = minutesByName ? Number(minutesByName.get(full) || 0) : 0;
                const denom90 = mins > 0 ? (mins / 90) : (gamesCount || 1);
                const received_p90 = denom90 > 0 ? (cnt / denom90) : 0;
                return { playerId: pid, name: getLastName(full), fullName: full, count: cnt, minutes: mins, received_p90, avgX, avgY };
            });

            rows.sort((a, b) => (b.received_p90 - a.received_p90) || (b.count - a.count));
            return rows.slice(0, 5);
        }

        function collectBallmagnetPassLines(allEvs, teamName, matchIds, receiverIdSet) {
            if (!receiverIdSet || receiverIdSet.size === 0) return new Map();
            const evs = allEvs.filter(e => matchIds.has(e.match_id) && e.playerId != null)
                .map((e, idx) => ({
                    team: e.team,
                    playerId: Number(e.playerId),
                    type: e.event_type,
                    outcome: e.outcome,
                    period: e.period ?? 0,
                    minute: Number(e.minute ?? 0),
                    second: Number(e.second ?? 0),
                    x: (e.x_coord != null ? Number(e.x_coord) : null),
                    y: (e.y_coord != null ? Number(e.y_coord) : null),
                    ex: (e.end_x != null ? Number(e.end_x) : null),
                    ey: (e.end_y != null ? Number(e.end_y) : null),
                    __i: idx
                }));
            evs.sort((a, b) => (a.period - b.period) || (a.minute - b.minute) || (a.second - b.second) || (a.__i - b.__i));

            const linesByReceiver = new Map();
            for (let i = 0; i < evs.length; i++) {
                const ev = evs[i];
                if (ev.team !== teamName || ev.type !== 'Pass' || ev.outcome !== 'Successful') continue;
                if (!Number.isFinite(ev.x) || !Number.isFinite(ev.y)) continue;

                const t0 = ev.minute * 60 + ev.second;
                const per0 = ev.period;
                let receiverId = null;
                let receiverPos = (Number.isFinite(ev.ex) && Number.isFinite(ev.ey)) ? { x: ev.ex, y: ev.ey } : null;

                for (let j = i + 1; j < evs.length; j++) {
                    const nxt = evs[j];
                    if (nxt.period !== per0) break;
                    const dt = (nxt.minute * 60 + nxt.second) - t0;
                    if (dt < 0) continue;
                    if (dt > 10) break;
                    if (nxt.team === teamName && nxt.playerId && nxt.playerId !== ev.playerId) {
                        receiverId = nxt.playerId;
                        if (!receiverPos && Number.isFinite(nxt.x) && Number.isFinite(nxt.y)) receiverPos = { x: nxt.x, y: nxt.y };
                        break;
                    }
                }

                if (!receiverId || !receiverIdSet.has(receiverId)) continue;
                if (!receiverPos || !Number.isFinite(receiverPos.x) || !Number.isFinite(receiverPos.y)) continue;

                const arr = linesByReceiver.get(receiverId) || [];
                arr.push({ x: ev.x, y: ev.y, ex: receiverPos.x, ey: receiverPos.y });
                linesByReceiver.set(receiverId, arr);
            }
            return linesByReceiver;
        }

        const avgPassesPerPoss = computePassesPerPossession(eventDataset, currentTeam, matchIds);
        const ppdaValue = computePPDA(eventDataset, currentTeam, matchIds);
        const minutesByName = (() => {
            const m = new Map();
            (dataset || [])
                .filter(r => r && r.team === currentTeam && matchIds.has(r.match_id) && Number(r.half || 0) === 0)
                .forEach(r => {
                    const nm = String(r.player || '').trim();
                    if (!nm) return;
                    const mins = Number(r.minutes_played || 0);
                    if (!Number.isFinite(mins) || mins <= 0) return;
                    m.set(nm, (m.get(nm) || 0) + mins);
                });
            return m;
        })();

        const top5Recv = topReceivers(eventDataset, currentTeam, matchIds, minutesByName, gamesCount);
        const top3Recv = (top5Recv || []).slice(0, 3);
        ballmagnetTopMetas = top3Recv
            .map(r => ({ playerId: r.playerId, fullName: r.fullName, avgX: r.avgX, avgY: r.avgY, received_p90: r.received_p90 }));

        // Pass-Linien für die Top-3 Ballmagneten: Start des Passes -> Empfangsposition
        const topReceiverIds = new Set(top3Recv.map(r => r.playerId).filter(v => v != null));
        const linesById = collectBallmagnetPassLines(eventDataset, currentTeam, matchIds, topReceiverIds);
        ballmagnetPassGroups = top3Recv.map(r => ({
            fullName: r.fullName,
            lines: linesById.get(r.playerId) || []
        }));
        // Abschlüsse p90 auf Teamebene: aktuell als pro Spiel über die gewählten Spiele
        const shotsPer90 = Math.round((shotsAll.length / gamesCount) * 10) / 10;
        const shotsOnTargetPer90 = Math.round((shotsOnTarget.length / gamesCount) * 10) / 10;
        const goalsPer90 = Math.round((goalsCount / gamesCount) * 10) / 10;

        // Grundstruktur p90 (pro Spiel über die gewählten Spiele)
        const passesPer90 = Math.round((passesAll.length / gamesCount) * 10) / 10;
        const passesSuccPer90 = Math.round((passesSucc.length / gamesCount) * 10) / 10;
        const firstThirdPer90 = Math.round((firstThirdAll.length / gamesCount) * 10) / 10;
        const firstThirdSuccPer90 = Math.round((firstThirdSucc.length / gamesCount) * 10) / 10;
        const secondThirdPer90 = Math.round((secondThirdAll.length / gamesCount) * 10) / 10;
        const secondThirdSuccPer90 = Math.round((secondThirdSucc.length / gamesCount) * 10) / 10;

        // Grundstruktur im Ballbesitz: einfache Struktur-Metriken aus Pass-Startpositionen
        const structurePassPoints = passesSucc
            .filter(e => e.x_coord != null && e.y_coord != null)
            .map(e => ({
                x: Number(e.x_coord),
                y: Number(e.y_coord),
                ex: e.end_x != null ? Number(e.end_x) : null,
                ey: e.end_y != null ? Number(e.end_y) : null
            }))
            .filter(p => Number.isFinite(p.x) && Number.isFinite(p.y));

        const mean = (arr) => arr.length ? (arr.reduce((a, b) => a + b, 0) / arr.length) : null;
        const std = (arr) => {
            if (arr.length < 2) return null;
            const m = mean(arr);
            const v = arr.reduce((a, b) => a + (b - m) * (b - m), 0) / (arr.length - 1);
            return Math.sqrt(v);
        };

        const structureHeight = (() => {
            const xs = structurePassPoints.map(p => p.x);
            const m = mean(xs);
            return m == null ? null : Math.round(m * 10) / 10; // 0-100
        })();

        const structureWidth = (() => {
            const ys = structurePassPoints.map(p => p.y);
            const s = std(ys);
            return s == null ? null : Math.round(s * 10) / 10; // Streuung 0-100
        })();

        const structureZones18 = (() => {
            return structurePassPoints
                .map(p => mapTo18Zone(p.x, p.y))
                .filter(z => Number.isFinite(z));
        })();

        const structureCentralityPct = (() => {
            if (!structureZones18.length) return null;
            // Zentrum = mittlere Spalte im 18-Zonen-Raster (Zonen 2,5,8,11,14,17)
            const center = structureZones18.filter(z => ((z - 1) % 3) === 1).length;
            return Math.round((center / structureZones18.length) * 1000) / 10;
        })();

        const structureSideDist = (() => {
            if (!structurePassPoints.length) return null;
            const left = structurePassPoints.filter(p => p.y < 33.3).length;
            const center = structurePassPoints.filter(p => p.y >= 33.3 && p.y < 66.6).length;
            const right = structurePassPoints.filter(p => p.y >= 66.6).length;
            const pct = (v) => Math.round((v / structurePassPoints.length) * 1000) / 10;
            return { left: pct(left), center: pct(center), right: pct(right) };
        })();

        const structureThirdDist = (() => {
            if (!structurePassPoints.length) return null;
            const b = structurePassPoints.filter(p => p.x < 33.3).length;
            const m = structurePassPoints.filter(p => p.x >= 33.3 && p.x < 66.6).length;
            const t = structurePassPoints.filter(p => p.x >= 66.6).length;
            const pct = (v) => Math.round((v / structurePassPoints.length) * 1000) / 10;
            return { back: pct(b), mid: pct(m), top: pct(t) };
        })();

        const avgPassLength = (() => {
            const pts = structurePassPoints
                .filter(p => Number.isFinite(p.ex) && Number.isFinite(p.ey))
                .map(p => Math.sqrt((p.ex - p.x) ** 2 + (p.ey - p.y) ** 2));
            const m = mean(pts);
            return m == null ? null : Math.round(m * 10) / 10;
        })();

        // Flanken (ohne Eckbälle) p90
        const crossesAll = teamEvents.filter(e => e.event_type === 'Pass' && e.is_cross === true && e.is_corner !== true);
        const crossesSucc = crossesAll.filter(e => e.outcome === 'Successful');
        const crossesPer90 = Math.round((crossesAll.length / gamesCount) * 10) / 10;
        const crossesSuccPer90 = Math.round((crossesSucc.length / gamesCount) * 10) / 10;
        const crossesSuccPct = crossesAll.length ? Math.round((crossesSucc.length / crossesAll.length) * 100) : 0;

        // Second Ball Recovery after Cross (Zweiter Ball nach Flanke)
        // Definition (heuristisch): misslungene Flanke (ohne Eckball), die vom Gegner geklärt/abgewehrt wird
        // (z.B. Clearance, gewonnenes Kopfballduell/Aerial, Interception/Tackle/BlockedPass). Danach prüfen wir,
        // wer innerhalb eines kurzen Fensters die erste kontrollierte Aktion hat.
        const secondBallRecoveryAfterCrossPct = (() => {
            if (!crossesAll.length) return null;

            const periodOrder = new Map([
                ['FirstHalf', 1],
                ['SecondHalf', 2],
                ['FirstPeriodOfExtraTime', 3],
                ['SecondPeriodOfExtraTime', 4],
                ['PenaltyShootout', 5],
            ]);

            const isRelevant = (e) => {
                const t = e.event_type;
                if (!t) return false;
                if (t === 'Start' || t === 'End' || t === 'Substitution' || t === 'FormationChange') return false;
                return true;
            };

            const isControlled = (e) => {
                const t = e.event_type;
                if (!t) return false;
                if (t === 'BallRecovery' || t === 'Interception') return true;
                if (t === 'Tackle' && e.outcome === 'Successful') return true;
                if (t === 'Pass' && e.outcome === 'Successful') return true;
                if (t === 'TakeOn' && e.outcome === 'Successful') return true;
                if (t === 'Carry') return true;
                if (t === 'Shot' || t === 'Goal' || t === 'MissedShots' || t === 'SavedShot') return true;
                return false;
            };

            const isDefendedCrossOutcome = (e) => {
                if (!e) return false;
                if (!e.team || e.team === currentTeam) return false;
                const t = e.event_type;
                if (!t) return false;
                if (t === 'Clearance') return true; // egal ob Kopf oder Fuß
                if (t === 'Aerial' && e.outcome === 'Successful') return true;
                if (t === 'Interception') return true;
                if (t === 'Tackle' && e.outcome === 'Successful') return true;
                if (t === 'BlockedPass') return true;
                return false;
            };

            const comparator = (a, b) => {
                const pa = periodOrder.get(a.period) || 99;
                const pb = periodOrder.get(b.period) || 99;
                if (pa !== pb) return pa - pb;
                const ma = Number(a.minute || 0);
                const mb = Number(b.minute || 0);
                if (ma !== mb) return ma - mb;
                const sa = Number(a.second || 0);
                const sb = Number(b.second || 0);
                if (sa !== sb) return sa - sb;
                const ea = Number(a.eventId || 0);
                const eb = Number(b.eventId || 0);
                if (ea !== eb) return ea - eb;
                return Number(a.id || 0) - Number(b.id || 0);
            };

            // Events pro Match sortieren
            const sel = (eventDataset || []).filter(e => matchIds.has(e.match_id));
            if (!sel.length) return null;
            const byMatch = new Map();
            for (const e of sel) {
                const mid = String(e.match_id ?? '');
                if (!mid) continue;
                if (!byMatch.has(mid)) byMatch.set(mid, []);
                byMatch.get(mid).push(e);
            }

            const indexByMatchAndId = new Map();
            for (const [mid, rows] of byMatch.entries()) {
                rows.sort(comparator);
                const m = new Map();
                for (let i = 0; i < rows.length; i++) {
                    const id = rows[i]?.id;
                    if (id != null) m.set(Number(id), i);
                }
                indexByMatchAndId.set(mid, m);
            }

            let denom = 0;
            let num = 0;

            const DEFENSE_LOOKAHEAD_EVENTS = 3;
            const CONTROL_LOOKAHEAD_EVENTS = 10;

            for (const c of crossesAll) {
                // nur misslungene Flanken ("kommt nicht an")
                if (c.outcome === 'Successful') continue;

                const mid = String(c.match_id ?? '');
                const rows = byMatch.get(mid);
                const idxMap = indexByMatchAndId.get(mid);
                if (!rows || !idxMap) continue;
                const startIdx = idxMap.get(Number(c.id));
                if (startIdx == null) continue;

                // innerhalb kurzer Zeitspanne: gegnerische Abwehraktion finden
                let defenseIdx = null;
                let seenDefense = 0;
                for (let j = startIdx + 1; j < rows.length && seenDefense < DEFENSE_LOOKAHEAD_EVENTS; j++) {
                    const e = rows[j];
                    if (!isRelevant(e)) continue;
                    seenDefense += 1;
                    if (isDefendedCrossOutcome(e)) {
                        defenseIdx = j;
                        break;
                    }
                }
                if (defenseIdx == null) continue;

                denom += 1;

                // danach: wer hat die erste kontrollierte Aktion?
                let firstTeam = null;
                let seenControl = 0;
                for (let j = defenseIdx + 1; j < rows.length && seenControl < CONTROL_LOOKAHEAD_EVENTS; j++) {
                    const e = rows[j];
                    if (!isRelevant(e)) continue;
                    seenControl += 1;
                    if (!isControlled(e)) continue;
                    firstTeam = e.team || null;
                    break;
                }

                if (firstTeam && firstTeam === currentTeam) num += 1;
            }

            if (!denom) return null;
            return Math.round((num / denom) * 1000) / 10; // 1 Nachkommastelle
        })();
        const fmtP90 = (v) => {
            const n = Number(v);
            if (!Number.isFinite(n)) return '-';
            return (Math.abs(n - Math.round(n)) < 1e-9) ? String(Math.round(n)) : String(n);
        };
        // Minuten pro Spieler aus processed_data (dataset) für die ausgewählten Spiele
        const minutesByPlayerName = (() => {
            const m = new Map();
            dataset
                .filter(r => r.team === currentTeam && matchIds.has(r.match_id))
                .forEach(r => {
                    const nm = r.player;
                    const mins = Number(r.minutes_played || 0);
                    m.set(nm, (m.get(nm) || 0) + mins);
                });
            return m;
        })();

        // xT-Summe pro Spieler aus processed_data (dataset) für die ausgewählten Spiele
        const xtByPlayerName = (() => {
            const m = new Map();
            (dataset || [])
                .filter(r => r.team === currentTeam && matchIds.has(r.match_id))
                .forEach(r => {
                    const nm = r.player;
                    if (!nm) return;
                    const xt = Number(r.xt || 0);
                    if (!Number.isFinite(xt)) return;
                    m.set(nm, (m.get(nm) || 0) + xt);
                });
            return m;
        })();

        const leftTitle1 = document.getElementById('left-title-1');
        const leftTitle2 = document.getElementById('left-title-2');
        const leftTitle3 = document.getElementById('left-title-3');
        const standardsInfoBox = document.getElementById('standards-info-box');
        const rightTitle = document.getElementById('right-title');
        // Titles / left-layout are driven by the selected top-level phase,
        // even if currentPhase is a nested view (e.g. 'pressinghoehe').
        const topPhase = (typeof currentMainPhase === 'string' && currentMainPhase) ? currentMainPhase : currentPhase;
        const isGegenBall = (topPhase === 'gegen-ball');
        const isStandardsPhase = (topPhase === 'standards');
        const isPhysisch = (topPhase === 'physisch');

        // Zeige nur die Standards-Box bei Standards-Phase, sonst die drei Boxen
        if (standardsInfoBox) standardsInfoBox.style.display = isStandardsPhase ? '' : 'none';
        if (leftTitle1) leftTitle1.parentElement.style.display = isStandardsPhase ? 'none' : '';
        if (leftTitle2) leftTitle2.parentElement.style.display = isStandardsPhase ? 'none' : '';
        if (leftTitle3) leftTitle3.parentElement.style.display = isStandardsPhase ? 'none' : '';

        if (leftTitle1 && leftTitle2 && leftTitle3) {
            if (isGegenBall) {
                leftTitle1.textContent = 'Pressing & Zugriff';
                leftTitle2.textContent = 'Block & Raumkontrolle';
                leftTitle3.textContent = 'Chance Prevention';
            } else if (isPhysisch) {
                leftTitle1.innerHTML = 'Laufparameter <span class="ml-2 text-[10px] font-semibold text-gray-700">Verteilung (BB vs ggBall)</span>';
                leftTitle2.textContent = 'Aktivität & Intensität';
                leftTitle3.textContent = '—';
            } else {
                leftTitle1.textContent = 'Spielaufbau';
                leftTitle2.textContent = 'Spielkontrolle';
                leftTitle3.textContent = 'Zum Tor';
            }
        }
        // Standards: Eckball-Kurzinfos werden weiter unten im Standards-Block berechnet
        // (inkl. Abhängigkeit von matchIds/gamesCount). Hier keine zweite, fehleranfällige
        // Ausgabe.

        if (rightTitle) {
            rightTitle.textContent = isPhysisch ? 'Laufparameter (Spieler)' : 'Individualtaktik';
        }

        if (isGegenBall) {
            // --- Gegen den Ball: erste Kennzahlen ---
            const recoveries = teamEvents.filter(e => ((e.event_type === 'Tackle' && e.outcome === 'Successful') || e.event_type === 'Interception' || e.event_type === 'BallRecovery'));
            const recoveriesPer90 = gamesCount ? Math.round((recoveries.length / gamesCount) * 10) / 10 : null;
            const highRecoveries = recoveries.filter(r => r.x_coord != null && Number(r.x_coord) >= 66.6);
            const highRecoveriesPer90 = gamesCount ? Math.round((highRecoveries.length / gamesCount) * 10) / 10 : null;
            const midRecoveries = recoveries.filter(r => r.x_coord != null && Number(r.x_coord) >= 33.3 && Number(r.x_coord) < 66.6);
            const lowRecoveries = recoveries.filter(r => r.x_coord != null && Number(r.x_coord) < 33.3);
            const midRecoveriesPer90 = gamesCount ? Math.round((midRecoveries.length / gamesCount) * 10) / 10 : null;
            const lowRecoveriesPer90 = gamesCount ? Math.round((lowRecoveries.length / gamesCount) * 10) / 10 : null;
            const avgRecoveryX = (() => {
                const xs = recoveries.map(r => Number(r.x_coord)).filter(v => Number.isFinite(v));
                if (!xs.length) return null;
                const avg = xs.reduce((a, b) => a + b, 0) / xs.length;
                return Math.round(avg * 10) / 10;
            })();

            // PPDA (wie zuvor im Dashboard genutzt): Gegner-Pässe (x<60) / eigene Def-Aktionen (x<60)
            const ppdaInfo = (() => {
                const sel = (eventDataset || []).filter(e => matchIds.has(e.match_id));
                if (!sel.length) return { value: null, oppPasses: 0, defActions: 0 };
                const oppPasses = sel.filter(e => e.team !== currentTeam && e.event_type === 'Pass' && e.x_coord != null && Number(e.x_coord) < 60).length;
                const defActions = sel.filter(e => e.team === currentTeam && ['Tackle', 'Interception', 'BallRecovery', 'Foul'].includes(e.event_type) && e.x_coord != null && Number(e.x_coord) < 60).length;
                const value = defActions > 0 ? Math.round((oppPasses / defActions) * 10) / 10 : null;
                return { value, oppPasses, defActions };
            })();

            // Turnovers + Gegenpressing (heuristisch): Ballverlust -> Rückgewinn innerhalb von X Sekunden
            const counterPressInfo = (() => {
                const WINDOW_SEC = 5;
                const sel = (eventDataset || []).filter(e => matchIds.has(e.match_id));
                if (!sel.length) return { attempts: 0, wins: 0, per90: null, pct: null };

                const periodOrder = new Map([
                    ['FirstHalf', 0],
                    ['SecondHalf', 2700],
                    ['FirstPeriodOfExtraTime', 5400],
                    ['SecondPeriodOfExtraTime', 6300],
                    ['PenaltyShootout', 7200],
                ]);
                const absSec = (e) => {
                    const off = periodOrder.get(e.period) ?? 0;
                    return off + (Number(e.minute || 0) * 60) + Number(e.second || 0);
                };
                const comparator = (a, b) => {
                    const pa = periodOrder.has(a.period) ? periodOrder.get(a.period) : 999999;
                    const pb = periodOrder.has(b.period) ? periodOrder.get(b.period) : 999999;
                    if (pa !== pb) return pa - pb;
                    const ma = Number(a.minute || 0);
                    const mb = Number(b.minute || 0);
                    if (ma !== mb) return ma - mb;
                    const sa = Number(a.second || 0);
                    const sb = Number(b.second || 0);
                    if (sa !== sb) return sa - sb;
                    const ea = Number(a.eventId || 0);
                    const eb = Number(b.eventId || 0);
                    if (ea !== eb) return ea - eb;
                    return Number(a.id || 0) - Number(b.id || 0);
                };

                const inPossessionEventTypes = new Set(['Pass', 'Carry', 'TakeOn', 'BallTouch', 'Shot', 'Goal', 'MissedShots', 'SavedShot']);
                const isRecovery = (e) => (e.event_type === 'Interception' || e.event_type === 'BallRecovery' || (e.event_type === 'Tackle' && e.outcome === 'Successful'));
                const turnoverTypes = new Set(['Pass', 'TakeOn', 'BallTouch', 'Carry']);

                const byMatch = new Map();
                for (const e of sel) {
                    const mid = String(e.match_id ?? '');
                    if (!mid) continue;
                    if (!byMatch.has(mid)) byMatch.set(mid, []);
                    byMatch.get(mid).push(e);
                }

                let attempts = 0;
                let wins = 0;

                for (const rows of byMatch.values()) {
                    rows.sort(comparator);

                    // turnover: eigenes kontrolliertes Event, danach gegnerisches kontrolliertes Event
                    for (let i = 0; i < rows.length - 1; i++) {
                        const e = rows[i];
                        if (!e || e.team !== currentTeam) continue;
                        if (!inPossessionEventTypes.has(e.event_type)) continue;
                        if (!turnoverTypes.has(e.event_type)) continue;
                        // nur Fehlpass / verlorenes Dribbling als Ballverlust
                        const isTurnover = (
                            (e.event_type === 'Pass' && e.outcome === 'Unsuccessful') ||
                            (e.event_type === 'TakeOn' && e.outcome === 'Unsuccessful')
                        );
                        if (!isTurnover) continue;

                        // Prüfe, ob Gegner unmittelbar danach kontrollierten Ballbesitz hat
                        let j = i + 1;
                        while (j < rows.length) {
                            const n = rows[j];
                            if (!n || !n.team) { j++; continue; }
                            if (!inPossessionEventTypes.has(n.event_type)) { j++; continue; }
                            if (n.team === currentTeam) { j++; continue; }
                            break;
                        }
                        if (j >= rows.length) continue;

                        const t0 = absSec(e);
                        attempts += 1;

                        // suche Rückgewinn in WINDOW_SEC
                        for (let k = j; k < rows.length; k++) {
                            const r = rows[k];
                            if (!r || !r.team) continue;
                            const dt = absSec(r) - t0;
                            if (dt > WINDOW_SEC) break;
                            if (r.team !== currentTeam) continue;
                            if (isRecovery(r)) { wins += 1; break; }
                        }
                    }
                }

                const per90 = gamesCount ? Math.round((wins / gamesCount) * 10) / 10 : null;
                const pct = attempts ? Math.round((wins / attempts) * 1000) / 10 : null;
                return { attempts, wins, per90, pct };
            })();

            const pressingIntensityInfo = (() => {
                const defActionTypes = new Set(['Tackle', 'Interception', 'BallRecovery', 'Foul']);
                const highDefActions = teamEvents.filter(e => defActionTypes.has(e.event_type) && e.x_coord != null && Number(e.x_coord) >= 66.6);
                const midDefActions = teamEvents.filter(e => defActionTypes.has(e.event_type) && e.x_coord != null && Number(e.x_coord) >= 33.3 && Number(e.x_coord) < 66.6);
                const p90High = gamesCount ? Math.round((highDefActions.length / gamesCount) * 10) / 10 : null;
                const p90Mid = gamesCount ? Math.round((midDefActions.length / gamesCount) * 10) / 10 : null;
                return { p90High, p90Mid };
            })();

            const accessInfo = (() => {
                const tackles = teamEvents.filter(e => e.event_type === 'Tackle');
                const tacklesSucc = tackles.filter(e => e.outcome === 'Successful');
                const tacklesPer90 = gamesCount ? Math.round((tackles.length / gamesCount) * 10) / 10 : null;
                const tacklesSuccPer90 = gamesCount ? Math.round((tacklesSucc.length / gamesCount) * 10) / 10 : null;
                const succPct = tackles.length ? Math.round((tacklesSucc.length / tackles.length) * 1000) / 10 : null;
                const interceptions = teamEvents.filter(e => e.event_type === 'Interception');
                const interceptionsPer90 = gamesCount ? Math.round((interceptions.length / gamesCount) * 10) / 10 : null;
                return { tacklesPer90, tacklesSuccPer90, succPct, interceptionsPer90 };
            })();

            const defActionTypes = new Set(['Tackle', 'Interception', 'BallRecovery', 'Clearance', 'BlockedPass', 'Block', 'Foul']);
            const defActions = teamEvents.filter(e => defActionTypes.has(e.event_type));
            const defActionsPer90 = gamesCount ? Math.round((defActions.length / gamesCount) * 10) / 10 : null;
            const interceptions = teamEvents.filter(e => e.event_type === 'Interception');
            const interceptionsPer90 = gamesCount ? Math.round((interceptions.length / gamesCount) * 10) / 10 : null;
            const clearances = teamEvents.filter(e => e.event_type === 'Clearance');
            const clearancesPer90 = gamesCount ? Math.round((clearances.length / gamesCount) * 10) / 10 : null;

            const allMatchEvents = (eventDataset || []).filter(e => matchIds.has(e.match_id));
            const oppEvents = allMatchEvents.filter(e => e.team && e.team !== currentTeam);
            const oppSuccPasses = oppEvents
                .filter(e => e.event_type === 'Pass' && e.outcome === 'Successful' && e.end_x != null && e.end_y != null)
                .map(e => ({ end_x: Number(e.end_x), end_y: Number(e.end_y), is_cross: e.is_cross === true, is_corner: e.is_corner === true }))
                .filter(p => Number.isFinite(p.end_x) && Number.isFinite(p.end_y));

            const inCentral = (y) => Number(y) >= 33.3 && Number(y) < 66.6;
            const inLeftHalfspace = (y) => Number(y) >= 16.6 && Number(y) < 33.3;
            const inRightHalfspace = (y) => Number(y) >= 66.6 && Number(y) < 83.4;
            const inLeftWing = (y) => Number(y) < 16.6;
            const inRightWing = (y) => Number(y) >= 83.4;
            const inFinalThird = (x) => Number(x) >= 66.6;

            const oppCentralFinalThird = oppSuccPasses.filter(p => inFinalThird(p.end_x) && inCentral(p.end_y));
            const oppHalfspaceLFinalThird = oppSuccPasses.filter(p => inFinalThird(p.end_x) && inLeftHalfspace(p.end_y));
            const oppHalfspaceRFinalThird = oppSuccPasses.filter(p => inFinalThird(p.end_x) && inRightHalfspace(p.end_y));
            const oppWingLFinalThird = oppSuccPasses.filter(p => inFinalThird(p.end_x) && inLeftWing(p.end_y));
            const oppWingRFinalThird = oppSuccPasses.filter(p => inFinalThird(p.end_x) && inRightWing(p.end_y));

            const oppFinalThirdPasses = oppSuccPasses.filter(p => inFinalThird(p.end_x));
            const oppFinalThirdPassesPer90 = gamesCount ? Math.round((oppFinalThirdPasses.length / gamesCount) * 10) / 10 : null;

            const zone14Opp = oppSuccPasses.filter(p => p.end_x != null && Number(p.end_x) >= 66.6 && Number(p.end_x) < 83.3 && inCentral(p.end_y));
            const zone14OppPer90 = gamesCount ? Math.round((zone14Opp.length / gamesCount) * 10) / 10 : null;

            const interCentral = interceptions.filter(e => e.y_coord != null && inCentral(Number(e.y_coord)));
            const interCentralPer90 = gamesCount ? Math.round((interCentral.length / gamesCount) * 10) / 10 : null;

            const blockHeightInfo = (() => {
                const xs = defActions.map(a => Number(a.x_coord)).filter(v => Number.isFinite(v));
                if (!xs.length) return { avgX: null, defThirdPct: null, midThirdPct: null, highThirdPct: null };
                const avgX = xs.reduce((a, b) => a + b, 0) / xs.length;
                const n = xs.length;
                const defThird = xs.filter(x => x < 33.3).length;
                const midThird = xs.filter(x => x >= 33.3 && x < 66.6).length;
                const highThird = xs.filter(x => x >= 66.6).length;
                return {
                    avgX: Math.round(avgX * 10) / 10,
                    defThirdPct: Math.round((defThird / n) * 1000) / 10,
                    midThirdPct: Math.round((midThird / n) * 1000) / 10,
                    highThirdPct: Math.round((highThird / n) * 1000) / 10,
                };
            })();

            const compactnessInfo = (() => {
                const xs = defActions.map(a => Number(a.x_coord)).filter(v => Number.isFinite(v));
                const ys = defActions.map(a => Number(a.y_coord)).filter(v => Number.isFinite(v));
                if (xs.length < 2 || ys.length < 2) return { stdX: null, stdY: null };
                const mean = (arr) => arr.reduce((a, b) => a + b, 0) / arr.length;
                const std = (arr) => {
                    const m = mean(arr);
                    const v = arr.reduce((a, b) => a + (b - m) * (b - m), 0) / (arr.length - 1);
                    return Math.sqrt(v);
                };
                return { stdX: Math.round(std(xs) * 10) / 10, stdY: Math.round(std(ys) * 10) / 10 };
            })();

            const deepPressureInfo = (() => {
                // "Deep PPDA" Proxy: Gegner erfolgreiche Pässe ins letzte Drittel / eigene Def-Aktionen im eigenen Def-Drittel
                const oppDeep = oppFinalThirdPasses.length;
                const ourDeep = defActions.filter(e => e.x_coord != null && Number(e.x_coord) < 33.3).length;
                const ratio = ourDeep > 0 ? Math.round((oppDeep / ourDeep) * 10) / 10 : null;
                return { oppDeep, ourDeep, ratio };
            })();

            const blocks = teamEvents.filter(e => (e.event_type === 'BlockedPass' || e.event_type === 'Block'));
            const blocksPer90 = gamesCount ? Math.round((blocks.length / gamesCount) * 10) / 10 : null;
            const boxXThreshold = (16.5 / 105) * 100; // ~15.7% Feldlänge
            const clearancesInBox = clearances.filter(e => e.x_coord != null && Number(e.x_coord) <= boxXThreshold);
            const clearancesInBoxPer90 = gamesCount ? Math.round((clearancesInBox.length / gamesCount) * 10) / 10 : null;
            const foulsDefThird = teamEvents.filter(e => e.event_type === 'Foul' && e.x_coord != null && Number(e.x_coord) < 33.3);
            const foulsDefThirdPer90 = gamesCount ? Math.round((foulsDefThird.length / gamesCount) * 10) / 10 : null;

            const blocksInBox = blocks.filter(e => e.x_coord != null && Number(e.x_coord) <= boxXThreshold);
            const blocksInBoxPer90 = gamesCount ? Math.round((blocksInBox.length / gamesCount) * 10) / 10 : null;

            const shotTypesOpp = new Set(['Shot', 'Goal', 'MissedShots', 'SavedShot']);
            const oppShotsAll = oppEvents.filter(e => shotTypesOpp.has(e.event_type));
            const oppGoals = oppShotsAll.filter(e => e.event_type === 'Goal' || e.isGoal === true);
            const oppOnTarget = oppShotsAll.filter(e => e.event_type === 'SavedShot' || e.event_type === 'Goal' || e.isGoal === true);
            const oppShotsPer90 = gamesCount ? Math.round((oppShotsAll.length / gamesCount) * 10) / 10 : null;
            const oppOnTargetPer90 = gamesCount ? Math.round((oppOnTarget.length / gamesCount) * 10) / 10 : null;
            const oppGoalsPer90 = gamesCount ? Math.round((oppGoals.length / gamesCount) * 10) / 10 : null;

            // Gegner-Schüsse im Strafraum (aus Sicht des angreifenden Teams: Box liegt nahe x=100)
            const boxStartX = 100 - boxXThreshold; // ~84.3
            const oppShotsInBox = oppShotsAll.filter(e => e.x_coord != null && Number(e.x_coord) >= boxStartX);
            const oppShotsInBoxPer90 = gamesCount ? Math.round((oppShotsInBox.length / gamesCount) * 10) / 10 : null;
            const oppShotsInBoxPct = oppShotsAll.length ? Math.round((oppShotsInBox.length / oppShotsAll.length) * 1000) / 10 : null;

            // Box Entries: erfolgreiche Pässe, deren Endpunkt wirklich im Strafraum liegt (nicht daneben/Flügelzone)
            const boxHalfW = (40.3 / 68) * 50;           // ~29.632 (in %-y)
            const boxMinY = 50 - boxHalfW;               // ~20.368
            const boxMaxY = 50 + boxHalfW;               // ~79.632
            const oppBoxEntries = oppEvents
                .filter(e => e.event_type === 'Pass' && e.outcome === 'Successful' && e.end_x != null && e.end_y != null)
                .filter(e => {
                    const ex = Number(e.end_x);
                    const ey = Number(e.end_y);
                    if (!Number.isFinite(ex) || !Number.isFinite(ey)) return false;
                    return ex >= boxStartX && ex <= 100 && ey >= boxMinY && ey <= boxMaxY;
                });
            const oppBoxEntriesPer90 = gamesCount ? Math.round((oppBoxEntries.length / gamesCount) * 10) / 10 : null;

            const oppBoxTouches = oppEvents
                .filter(e => (e.event_type === 'BallTouch') && e.x_coord != null)
                .filter(e => Number(e.x_coord) >= boxStartX);
            const oppBoxTouchesPer90 = gamesCount ? Math.round((oppBoxTouches.length / gamesCount) * 10) / 10 : null;

            const oppCrosses = oppEvents.filter(e => e.event_type === 'Pass' && e.is_cross === true && e.is_corner !== true);
            const oppCrossesSucc = oppCrosses.filter(e => e.outcome === 'Successful');
            const oppCrossesPer90 = gamesCount ? Math.round((oppCrosses.length / gamesCount) * 10) / 10 : null;
            const oppCrossesSuccPer90 = gamesCount ? Math.round((oppCrossesSucc.length / gamesCount) * 10) / 10 : null;
            const oppCrossSuccPct = oppCrosses.length ? Math.round((oppCrossesSucc.length / oppCrosses.length) * 1000) / 10 : null;

            const oppCorners = oppEvents.filter(e => e.is_corner === true);
            const oppFreekicks = oppEvents.filter(e => e.is_freekick === true);
            const oppCornersPer90 = gamesCount ? Math.round((oppCorners.length / gamesCount) * 10) / 10 : null;
            const oppFreekicksPer90 = gamesCount ? Math.round((oppFreekicks.length / gamesCount) * 10) / 10 : null;

            if (infoAufbau) {
                const activePressTab = (
                    lastOpenPressingTab === 'pressinghoehe' ||
                    lastOpenPressingTab === 'zugriff' ||
                    lastOpenPressingTab === 'ppda' ||
                    lastOpenPressingTab === 'gegenpressing' ||
                    lastOpenPressingTab === 'intensitaet' ||
                    lastOpenPressingTab === 'ballgewinne-zonen'
                ) ? lastOpenPressingTab : 'pressinghoehe';
                lastOpenPressingTab = activePressTab;

                const tabBase = 'px-3 py-1 rounded-md text-xs font-medium border border-gray-300 bg-white text-gray-700 hover:bg-gray-50';
                const tabActive = 'bg-[#0A3F86] text-white border-[#0A3F86] hover:bg-[#0A3F86]';
                const tabClass = (key) => `${tabBase} ${(activeGegenBallGroup === 'pressing' && activePressTab === key) ? tabActive : ''}`;
                const panelClass = (key) => `${activePressTab === key ? '' : 'hidden'} mt-3`;

                infoAufbau.innerHTML = `
                    <div>
                        <div class="grid grid-cols-3 gap-2">
                            <button type="button" data-pressing-tab="pressinghoehe" class="${tabClass('pressinghoehe')}">Pressinghöhe</button>
                            <button type="button" data-pressing-tab="zugriff" class="${tabClass('zugriff')}">Zugriff</button>
                            <button type="button" data-pressing-tab="ppda" class="${tabClass('ppda')}">PPDA</button>
                            <button type="button" data-pressing-tab="gegenpressing" class="${tabClass('gegenpressing')}">Gegenpressing</button>
                            <button type="button" data-pressing-tab="intensitaet" class="${tabClass('intensitaet')}">Intensität</button>
                            <button type="button" data-pressing-tab="ballgewinne-zonen" class="${tabClass('ballgewinne-zonen')}">Ballgewinne Zonen</button>
                        </div>

                        <div data-pressing-panel="pressinghoehe" class="${panelClass('pressinghoehe')}">
                            <div class="text-[11px] leading-5 text-gray-800 space-y-1">
                                <div class="flex justify-between"><span>Ø Ballgewinnhöhe (x)</span><span class="font-medium">${avgRecoveryX != null ? avgRecoveryX.toFixed(1) : '-'}</span></div>
                                <div class="flex justify-between"><span>High Regains p90 (x ≥ 66.6)</span><span class="font-medium">${highRecoveriesPer90 != null ? fmtP90(highRecoveriesPer90) : '-'}</span></div>
                                <div class="flex justify-between"><span>Ballgewinne p90</span><span class="font-medium">${recoveriesPer90 != null ? fmtP90(recoveriesPer90) : '-'}</span></div>
                            </div>
                        </div>

                        <div data-pressing-panel="zugriff" class="${panelClass('zugriff')}">
                            <div class="text-[11px] leading-5 text-gray-800 space-y-1">
                                <div class="flex justify-between"><span>Tackles p90 | davon erfolgreich</span><span class="font-medium">${accessInfo.tacklesPer90 != null ? fmtP90(accessInfo.tacklesPer90) : '-'} | ${accessInfo.tacklesSuccPer90 != null ? fmtP90(accessInfo.tacklesSuccPer90) : '-'}</span></div>
                                <div class="flex justify-between"><span>Tackle Erfolgsquote</span><span class="font-medium">${accessInfo.succPct != null ? `${accessInfo.succPct.toFixed(1)}%` : '-'}</span></div>
                                <div class="flex justify-between"><span>Interceptions p90</span><span class="font-medium">${accessInfo.interceptionsPer90 != null ? fmtP90(accessInfo.interceptionsPer90) : '-'}</span></div>
                            </div>
                        </div>

                        <div data-pressing-panel="ppda" class="${panelClass('ppda')}">
                            <div class="text-[11px] leading-5 text-gray-800 space-y-1">
                                <div class="flex justify-between"><span>PPDA</span><span class="font-medium">${ppdaInfo.value != null ? fmtP90(ppdaInfo.value) : '-'}</span></div>
                                <div class="flex justify-between"><span>Gegner-Pässe (x &lt; 60)</span><span class="font-medium">${ppdaInfo.oppPasses || 0}</span></div>
                                <div class="flex justify-between"><span>Def-Aktionen (x &lt; 60)</span><span class="font-medium">${ppdaInfo.defActions || 0}</span></div>
                            </div>
                        </div>

                        <div data-pressing-panel="gegenpressing" class="${panelClass('gegenpressing')}">
                            <div class="text-[11px] leading-5 text-gray-800 space-y-1">
                                <div class="text-xs text-gray-600">Ballverlust → Rückgewinn innerhalb 5s (heuristisch)</div>
                                <div class="flex justify-between"><span>Rückgewinne p90</span><span class="font-medium">${counterPressInfo.per90 != null ? fmtP90(counterPressInfo.per90) : '-'}</span></div>
                                <div class="flex justify-between"><span>Erfolgsquote</span><span class="font-medium">${counterPressInfo.pct != null ? `${counterPressInfo.pct.toFixed(1)}%` : '-'}</span></div>
                                <div class="flex justify-between"><span>Versuche (N) | Gewinne (N)</span><span class="font-medium">${counterPressInfo.attempts || 0} | ${counterPressInfo.wins || 0}</span></div>
                            </div>
                        </div>

                        <div data-pressing-panel="intensitaet" class="${panelClass('intensitaet')}">
                            <div class="text-[11px] leading-5 text-gray-800 space-y-1">
                                <div class="flex justify-between"><span>Def-Aktionen im letzten Drittel p90</span><span class="font-medium">${pressingIntensityInfo.p90High != null ? fmtP90(pressingIntensityInfo.p90High) : '-'}</span></div>
                                <div class="flex justify-between"><span>Def-Aktionen im Mitteldrittel p90</span><span class="font-medium">${pressingIntensityInfo.p90Mid != null ? fmtP90(pressingIntensityInfo.p90Mid) : '-'}</span></div>
                                <div class="flex justify-between"><span>High Regains p90</span><span class="font-medium">${highRecoveriesPer90 != null ? fmtP90(highRecoveriesPer90) : '-'}</span></div>
                            </div>
                        </div>

                        <div data-pressing-panel="ballgewinne-zonen" class="${panelClass('ballgewinne-zonen')}">
                            <div class="text-[11px] leading-5 text-gray-800 space-y-1">
                                <div class="flex justify-between"><span>Ballgewinne p90 (Def. Drittel)</span><span class="font-medium">${lowRecoveriesPer90 != null ? fmtP90(lowRecoveriesPer90) : '-'}</span></div>
                                <div class="flex justify-between"><span>Ballgewinne p90 (Mitteldrittel)</span><span class="font-medium">${midRecoveriesPer90 != null ? fmtP90(midRecoveriesPer90) : '-'}</span></div>
                                <div class="flex justify-between"><span>Ballgewinne p90 (Angr. Drittel)</span><span class="font-medium">${highRecoveriesPer90 != null ? fmtP90(highRecoveriesPer90) : '-'}</span></div>
                            </div>
                        </div>
                    </div>
                `;
            }
            if (infoKontrolle) {
                const activeBlockTab = (
                    lastOpenBlockTab === 'zentrum' ||
                    lastOpenBlockTab === 'halb' ||
                    lastOpenBlockTab === 'fluegel' ||
                    lastOpenBlockTab === 'blockhoehe' ||
                    lastOpenBlockTab === 'kompaktheit' ||
                    lastOpenBlockTab === 'deep-ppda'
                ) ? lastOpenBlockTab : 'zentrum';
                lastOpenBlockTab = activeBlockTab;

                const tabBase = 'px-3 py-1 rounded-md text-xs font-medium border border-gray-300 bg-white text-gray-700 hover:bg-gray-50';
                const tabActive = 'bg-[#0A3F86] text-white border-[#0A3F86] hover:bg-[#0A3F86]';
                const tabClass = (key) => `${tabBase} ${(activeGegenBallGroup === 'block' && activeBlockTab === key) ? tabActive : ''}`;
                const panelClass = (key) => `${activeBlockTab === key ? '' : 'hidden'} mt-3`;

                const p90 = (n) => gamesCount ? (Math.round((Number(n || 0) / gamesCount) * 10) / 10) : null;

                infoKontrolle.innerHTML = `
                    <div>
                        <div class="grid grid-cols-3 gap-2">
                            <button type="button" data-block-tab="zentrum" class="${tabClass('zentrum')}">Zentrum</button>
                            <button type="button" data-block-tab="halb" class="${tabClass('halb')}">Halbräume</button>
                            <button type="button" data-block-tab="fluegel" class="${tabClass('fluegel')}">Flügel</button>
                            <button type="button" data-block-tab="blockhoehe" class="${tabClass('blockhoehe')}">Blockhöhe</button>
                            <button type="button" data-block-tab="kompaktheit" class="${tabClass('kompaktheit')}">Kompaktheit</button>
                            <button type="button" data-block-tab="deep-ppda" class="${tabClass('deep-ppda')}">Deep PPDA</button>
                        </div>

                        <div data-block-panel="zentrum" class="${panelClass('zentrum')}">
                            <div class="text-[11px] leading-5 text-gray-800 space-y-1">
                                <div class="flex justify-between"><span>Gegner Pässe (Final Third) ins Zentrum p90</span><span class="font-medium">${fmtP90(p90(oppCentralFinalThird.length))}</span></div>
                                <div class="flex justify-between"><span>Zone 14 (Gegner) p90</span><span class="font-medium">${zone14OppPer90 != null ? fmtP90(zone14OppPer90) : '-'}</span></div>
                                <div class="flex justify-between"><span>Interceptions im Zentrum p90</span><span class="font-medium">${interCentralPer90 != null ? fmtP90(interCentralPer90) : '-'}</span></div>
                            </div>
                        </div>

                        <div data-block-panel="halb" class="${panelClass('halb')}">
                            <div class="text-[11px] leading-5 text-gray-800 space-y-1">
                                <div class="flex justify-between"><span>Halbraum links (Gegner, Final Third) p90</span><span class="font-medium">${fmtP90(p90(oppHalfspaceLFinalThird.length))}</span></div>
                                <div class="flex justify-between"><span>Halbraum rechts (Gegner, Final Third) p90</span><span class="font-medium">${fmtP90(p90(oppHalfspaceRFinalThird.length))}</span></div>
                                <div class="flex justify-between"><span>Anteil Halbräume (L+R) im Final Third</span><span class="font-medium">${oppFinalThirdPasses.length ? `${(((oppHalfspaceLFinalThird.length + oppHalfspaceRFinalThird.length) / oppFinalThirdPasses.length) * 100).toFixed(1)}%` : '-'}</span></div>
                            </div>
                        </div>

                        <div data-block-panel="fluegel" class="${panelClass('fluegel')}">
                            <div class="text-[11px] leading-5 text-gray-800 space-y-1">
                                <div class="flex justify-between"><span>Flügel links (Gegner, Final Third) p90</span><span class="font-medium">${fmtP90(p90(oppWingLFinalThird.length))}</span></div>
                                <div class="flex justify-between"><span>Flügel rechts (Gegner, Final Third) p90</span><span class="font-medium">${fmtP90(p90(oppWingRFinalThird.length))}</span></div>
                                <div class="flex justify-between"><span>Gegner-Flanken (ohne Ecke) p90</span><span class="font-medium">${fmtP90(p90(oppSuccPasses.filter(p => p.is_cross && !p.is_corner).length))}</span></div>
                            </div>
                        </div>

                        <div data-block-panel="blockhoehe" class="${panelClass('blockhoehe')}">
                            <div class="text-[11px] leading-5 text-gray-800 space-y-1">
                                <div class="flex justify-between"><span>Ø Defensivaktion-Höhe (x)</span><span class="font-medium">${blockHeightInfo.avgX != null ? blockHeightInfo.avgX.toFixed(1) : '-'}</span></div>
                                <div class="flex justify-between"><span>Def-Aktionen: Def|Mid|High</span><span class="font-medium">${blockHeightInfo.defThirdPct != null ? `${blockHeightInfo.defThirdPct.toFixed(1)}% | ${blockHeightInfo.midThirdPct.toFixed(1)}% | ${blockHeightInfo.highThirdPct.toFixed(1)}%` : '-'}</span></div>
                                <div class="flex justify-between"><span>Defensivaktionen p90</span><span class="font-medium">${defActionsPer90 != null ? fmtP90(defActionsPer90) : '-'}</span></div>
                            </div>
                        </div>

                        <div data-block-panel="kompaktheit" class="${panelClass('kompaktheit')}">
                            <div class="text-[11px] leading-5 text-gray-800 space-y-1">
                                <div class="flex justify-between"><span>Breiten-Streuung (Std y)</span><span class="font-medium">${compactnessInfo.stdY != null ? compactnessInfo.stdY.toFixed(1) : '-'}</span></div>
                                <div class="flex justify-between"><span>Tiefen-Streuung (Std x)</span><span class="font-medium">${compactnessInfo.stdX != null ? compactnessInfo.stdX.toFixed(1) : '-'}</span></div>
                                <div class="flex justify-between"><span>Interceptions p90 | Clearances p90</span><span class="font-medium">${interceptionsPer90 != null ? fmtP90(interceptionsPer90) : '-'} | ${clearancesPer90 != null ? fmtP90(clearancesPer90) : '-'}</span></div>
                            </div>
                        </div>

                        <div data-block-panel="deep-ppda" class="${panelClass('deep-ppda')}">
                            <div class="text-[11px] leading-5 text-gray-800 space-y-1">
                                <div class="flex justify-between"><span>Deep PPDA (Proxy)</span><span class="font-medium">${deepPressureInfo.ratio != null ? fmtP90(deepPressureInfo.ratio) : '-'}</span></div>
                                <div class="flex justify-between"><span>Gegner Pässe ins letzte Drittel (N)</span><span class="font-medium">${deepPressureInfo.oppDeep || 0}</span></div>
                                <div class="flex justify-between"><span>Eigene Def-Aktionen Def. Drittel (N)</span><span class="font-medium">${deepPressureInfo.ourDeep || 0}</span></div>
                            </div>
                        </div>
                    </div>
                `;
            }
            if (infoZumTor) {
                const activeChanceTab = (
                    lastOpenChanceTab === 'shots' ||
                    lastOpenChanceTab === 'shots-box' ||
                    lastOpenChanceTab === 'box-defense' ||
                    lastOpenChanceTab === 'box-entries' ||
                    lastOpenChanceTab === 'cross-defense' ||
                    lastOpenChanceTab === 'standards-against'
                ) ? lastOpenChanceTab : 'shots';
                lastOpenChanceTab = activeChanceTab;

                const tabBase = 'px-3 py-1 rounded-md text-xs font-medium border border-gray-300 bg-white text-gray-700 hover:bg-gray-50';
                const tabActive = 'bg-[#0A3F86] text-white border-[#0A3F86] hover:bg-[#0A3F86]';
                const tabClass = (key) => `${tabBase} ${(activeGegenBallGroup === 'chance' && activeChanceTab === key) ? tabActive : ''}`;
                const panelClass = (key) => `${activeChanceTab === key ? '' : 'hidden'} mt-3`;

                infoZumTor.innerHTML = `
                    <div>
                        <div class="grid grid-cols-3 gap-2">
                            <button type="button" data-chance-tab="shots" class="${tabClass('shots')}">Schüsse</button>
                            <button type="button" data-chance-tab="shots-box" class="${tabClass('shots-box')}">Schüsse Box</button>
                            <button type="button" data-chance-tab="box-defense" class="${tabClass('box-defense')}">Box Defense</button>
                            <button type="button" data-chance-tab="box-entries" class="${tabClass('box-entries')}">Box Entries</button>
                            <button type="button" data-chance-tab="cross-defense" class="${tabClass('cross-defense')}">Flanken</button>
                            <button type="button" data-chance-tab="standards-against" class="${tabClass('standards-against')}">Gegentore</button>
                        </div>

                        <div data-chance-panel="shots" class="${panelClass('shots')}">
                            <div class="text-[11px] leading-5 text-gray-800 space-y-1">
                                <div class="flex justify-between"><span>Schüsse zugelassen p90</span><span class="font-medium">${oppShotsPer90 != null ? fmtP90(oppShotsPer90) : '-'}</span></div>
                                <div class="flex justify-between"><span>Schüsse aufs Tor zugelassen p90</span><span class="font-medium">${oppOnTargetPer90 != null ? fmtP90(oppOnTargetPer90) : '-'}</span></div>
                                <div class="flex justify-between"><span>Tore zugelassen p90</span><span class="font-medium">${oppGoalsPer90 != null ? fmtP90(oppGoalsPer90) : '-'}</span></div>
                            </div>
                        </div>

                        <div data-chance-panel="shots-box" class="${panelClass('shots-box')}">
                            <div class="text-[11px] leading-5 text-gray-800 space-y-1">
                                <div class="flex justify-between"><span>Schüsse aus Box zugelassen p90</span><span class="font-medium">${oppShotsInBoxPer90 != null ? fmtP90(oppShotsInBoxPer90) : '-'}</span></div>
                                <div class="flex justify-between"><span>Anteil Box-Schüsse</span><span class="font-medium">${oppShotsInBoxPct != null ? `${oppShotsInBoxPct.toFixed(1)}%` : '-'}</span></div>
                                <div class="flex justify-between"><span>Schüsse zugelassen p90</span><span class="font-medium">${oppShotsPer90 != null ? fmtP90(oppShotsPer90) : '-'}</span></div>
                            </div>
                        </div>

                        <div data-chance-panel="box-defense" class="${panelClass('box-defense')}">
                            <div class="text-[11px] leading-5 text-gray-800 space-y-1">
                                <div class="flex justify-between"><span>Blocks p90</span><span class="font-medium">${blocksPer90 != null ? fmtP90(blocksPer90) : '-'}</span></div>
                                <div class="flex justify-between"><span>Blocks im Strafraum p90</span><span class="font-medium">${blocksInBoxPer90 != null ? fmtP90(blocksInBoxPer90) : '-'}</span></div>
                                <div class="flex justify-between"><span>Clearances im Strafraum p90</span><span class="font-medium">${clearancesInBoxPer90 != null ? fmtP90(clearancesInBoxPer90) : '-'}</span></div>
                            </div>
                        </div>

                        <div data-chance-panel="box-entries" class="${panelClass('box-entries')}">
                            <div class="text-[11px] leading-5 text-gray-800 space-y-1">
                                <div class="flex justify-between"><span>Box Entries (Pässe) zugelassen p90</span><span class="font-medium">${oppBoxEntriesPer90 != null ? fmtP90(oppBoxEntriesPer90) : '-'}</span></div>
                                <div class="flex justify-between"><span>Box Touches (BallTouch) zugelassen p90</span><span class="font-medium">${oppBoxTouchesPer90 != null ? fmtP90(oppBoxTouchesPer90) : '-'}</span></div>
                                <div class="flex justify-between"><span>Schüsse aus Box zugelassen p90</span><span class="font-medium">${oppShotsInBoxPer90 != null ? fmtP90(oppShotsInBoxPer90) : '-'}</span></div>
                            </div>
                        </div>

                        <div data-chance-panel="cross-defense" class="${panelClass('cross-defense')}">
                            <div class="text-[11px] leading-5 text-gray-800 space-y-1">
                                <div class="flex justify-between"><span>Flanken zugelassen p90</span><span class="font-medium">${oppCrossesPer90 != null ? fmtP90(oppCrossesPer90) : '-'}</span></div>
                                <div class="flex justify-between"><span>Erfolgreiche Flanken zugelassen p90</span><span class="font-medium">${oppCrossesSuccPer90 != null ? fmtP90(oppCrossesSuccPer90) : '-'}</span></div>
                                <div class="flex justify-between"><span>Flanken Erfolgsquote (Gegner)</span><span class="font-medium">${oppCrossSuccPct != null ? `${oppCrossSuccPct.toFixed(1)}%` : '-'}</span></div>
                            </div>
                        </div>

                        <div data-chance-panel="standards-against" class="${panelClass('standards-against')}">
                            <div class="text-[11px] leading-5 text-gray-800 space-y-1">
                                <div class="flex justify-between"><span>Gegner-Ecken p90</span><span class="font-medium">${oppCornersPer90 != null ? fmtP90(oppCornersPer90) : '-'}</span></div>
                                <div class="flex justify-between"><span>Gegner-Freistöße p90</span><span class="font-medium">${oppFreekicksPer90 != null ? fmtP90(oppFreekicksPer90) : '-'}</span></div>
                                <div class="flex justify-between"><span>Fouls Def. Drittel p90</span><span class="font-medium">${foulsDefThirdPer90 != null ? fmtP90(foulsDefThirdPer90) : '-'}</span></div>
                            </div>
                        </div>
                    </div>
                `;
            }
        } else if (isPhysisch) {
            // --- Physisch: Laufparameter aus DFL-Aggregaten (dfl_running_team_matches.json) ---
            const dflTeamName = resolveDflTeamName();

            // In Gegneranalyse we want the opponent's recent running profile.
            // Therefore: show the last N matches of the selected opponent team
            // (not only matches vs HSV).
            const dflRows = (dflTeamName && Array.isArray(dflRunningTeamMatches))
                ? dflRunningTeamMatches.filter(r => String(r.team || '') === dflTeamName)
                : [];

            const sorted = dflRows
                .slice()
                .sort((a, b) => String(a.match_date || '').localeCompare(String(b.match_date || '')));

            const n = Math.max(1, Number(currentGameCount || 1));
            const windowRows = sorted.length ? sorted.slice(Math.max(0, sorted.length - n)) : [];

            // Center (flip back): total distance bar chart over selected window
            renderPhysischTotalDistanceBarChart(windowRows);
            renderPhysischTempoIntenseBarChart(windowRows);

            const avg = (key) => {
                if (!windowRows.length) return null;
                const vals = windowRows.map(r => Number(r[key])).filter(v => Number.isFinite(v));
                if (!vals.length) return null;
                const m = vals.reduce((a, x) => a + x, 0) / vals.length;
                return Math.round(m * 10) / 10;
            };

            const avgTotalGross = avg('total_distance_gross_km');
            const avgIntenseGross = avg('intense_distance_gross_km');

            const avgTotalNet = avg('total_distance_net_km');
            const avgBB = avg('total_distance_possession_km');
            const avgOut = avg('total_distance_outpos_km');

            const avgTempoBB = avg('tempo_distance_possession_km');
            const avgTempoOut = avg('tempo_distance_outpos_km');

            const avgSprintBB = avg('sprint_distance_possession_km');
            const avgSprintOut = avg('sprint_distance_outpos_km');

            const avgMinutes = avg('minutes');
            const avgIntenseNet = avg('intense_distance_net_km');
            const avgIntenseBB = avg('intense_distance_possession_km');
            const avgIntenseOut = avg('intense_distance_outpos_km');

            const avgMatchMinutesGross = (() => {
                if (!windowRows.length) return null;
                const vals = windowRows
                    .map(r => {
                        const mg = Number(r.match_minutes_gross);
                        if (Number.isFinite(mg) && mg > 0) return mg;
                        const mSum = Number(r.minutes);
                        return (Number.isFinite(mSum) && mSum > 0) ? (mSum / 11) : null;
                    })
                    .filter(v => v != null && Number.isFinite(v) && v > 0);
                if (!vals.length) return null;
                const m = vals.reduce((a, x) => a + x, 0) / vals.length;
                return Math.round(m * 10) / 10;
            })();

            const matchMinutesGrossForRow = (r) => {
                const mg = Number(r.match_minutes_gross);
                if (Number.isFinite(mg) && mg > 0) return mg;
                const mSum = Number(r.minutes);
                return (Number.isFinite(mSum) && mSum > 0) ? (mSum / 11) : null;
            };

            const avgMetersPerMinFromKmKey = (kmKey) => {
                if (!windowRows.length) return null;
                const vals = windowRows
                    .map(r => {
                        const km = Number(r[kmKey]);
                        const min = matchMinutesGrossForRow(r);
                        if (!Number.isFinite(km) || !Number.isFinite(min) || min <= 0) return null;
                        // Use per-player average: (team total / 11) / match minutes
                        return (km * 1000) / (min * 11);
                    })
                    .filter(v => v != null && Number.isFinite(v));
                if (!vals.length) return null;
                const m = vals.reduce((a, x) => a + x, 0) / vals.length;
                return m;
            };

            const mPerMin = (km, minutes) => {
                const k = Number(km);
                const m = Number(minutes);
                if (!Number.isFinite(k) || !Number.isFinite(m) || m <= 0) return null;
                return (k * 1000) / m;
            };

            // IMPORTANT: compute per-match m/min and then average across the selected window
            // (instead of (avg distance) / (avg minutes)).
            const activityTotal = avgMetersPerMinFromKmKey('total_distance_gross_km');
            const activityBB = avgMetersPerMinFromKmKey('total_distance_possession_km');
            const activityOut = avgMetersPerMinFromKmKey('total_distance_outpos_km');

            const intenseMPerMinNet = avgMetersPerMinFromKmKey('intense_distance_gross_km');
            const intenseMPerMinBB = avgMetersPerMinFromKmKey('intense_distance_possession_km');
            const intenseMPerMinOut = avgMetersPerMinFromKmKey('intense_distance_outpos_km');

            // Scale range based on all available matches for this team (DFL)
            const activityAll = (() => {
                const vals = dflRows
                    .map(r => {
                        const km = Number(r.total_distance_gross_km);
                        const minGross = Number(r.match_minutes_gross);
                        const min = (Number.isFinite(minGross) && minGross > 0)
                            ? minGross
                            : ((Number.isFinite(Number(r.minutes)) && Number(r.minutes) > 0) ? (Number(r.minutes) / 11) : null);
                        return (Number.isFinite(km) && Number.isFinite(min) && min > 0)
                            ? (km * 1000) / (min * 11)
                            : null;
                    })
                    .filter(v => v != null && Number.isFinite(v));
                if (!vals.length) return { min: null, max: null };
                return { min: Math.min(...vals), max: Math.max(...vals) };
            })();

            const activityPosPct = (() => {
                const v = Number(activityTotal);
                const mn = Number(activityAll.min);
                const mx = Number(activityAll.max);
                if (!Number.isFinite(v) || !Number.isFinite(mn) || !Number.isFinite(mx) || mx <= mn) return null;
                const t = (v - mn) / (mx - mn);
                const clamped = Math.max(0, Math.min(1, t));
                return clamped * 100;
            })();

            const intensityPctNet = (() => {
                const intense = Number(avgIntenseNet);
                const tot = Number(avgTotalNet);
                if (!Number.isFinite(intense) || !Number.isFinite(tot) || tot <= 0) return null;
                return (intense / tot) * 100;
            })();
            const intensityPctBB = (() => {
                const intense = Number(avgIntenseBB);
                const tot = Number(avgBB);
                if (!Number.isFinite(intense) || !Number.isFinite(tot) || tot <= 0) return null;
                return (intense / tot) * 100;
            })();
            const intensityPctOut = (() => {
                const intense = Number(avgIntenseOut);
                const tot = Number(avgOut);
                if (!Number.isFinite(intense) || !Number.isFinite(tot) || tot <= 0) return null;
                return (intense / tot) * 100;
            })();

            // Scale range for intensive running (m/min netto) based on all available matches for this team (DFL)
            const intenseMPerMinAll = (() => {
                const vals = dflRows
                    .map(r => {
                        const km = Number(r.intense_distance_gross_km);
                        const minGross = Number(r.match_minutes_gross);
                        const min = (Number.isFinite(minGross) && minGross > 0)
                            ? minGross
                            : ((Number.isFinite(Number(r.minutes)) && Number(r.minutes) > 0) ? (Number(r.minutes) / 11) : null);
                        return (Number.isFinite(km) && Number.isFinite(min) && min > 0)
                            ? (km * 1000) / (min * 11)
                            : null;
                    })
                    .filter(v => v != null && Number.isFinite(v));
                if (!vals.length) return { min: null, max: null };
                return { min: Math.min(...vals), max: Math.max(...vals) };
            })();

            const intenseMPerMinPosPct = (() => {
                const v = Number(intenseMPerMinNet);
                const mn = Number(intenseMPerMinAll.min);
                const mx = Number(intenseMPerMinAll.max);
                if (!Number.isFinite(v) || !Number.isFinite(mn) || !Number.isFinite(mx) || mx <= mn) return null;
                const t = (v - mn) / (mx - mn);
                const clamped = Math.max(0, Math.min(1, t));
                return clamped * 100;
            })();

            // Player list (same KPIs per player)
            const windowMatchIds = new Set(windowRows.map(r => String(r.match_id || '')));
            const playerRows = (dflTeamName && Array.isArray(dflRunningPlayerMatches))
                ? dflRunningPlayerMatches
                    .filter(r => String(r.team || '') === dflTeamName)
                    .filter(r => windowMatchIds.has(String(r.match_id || '')))
                : [];

            const byPlayer = new Map();
            for (const r of playerRows) {
                const name = String(r.player_name || '').trim();
                if (!name) continue;
                if (!byPlayer.has(name)) {
                    byPlayer.set(name, {
                        name,
                        games: 0,
                        totalNet: 0,
                        totalBB: 0,
                        totalOut: 0,
                        intenseBB: 0,
                        intenseOut: 0,
                    });
                }
                const acc = byPlayer.get(name);
                const net = Number(r.total_distance_net_km);
                const bb = Number(r.total_distance_possession_km);
                const out = Number(r.total_distance_outpos_km);
                const iBB = Number(r.intense_distance_possession_km);
                const iOut = Number(r.intense_distance_outpos_km);
                // count game for this player if at least one metric is present
                if (Number.isFinite(net) || Number.isFinite(bb) || Number.isFinite(out)) acc.games += 1;
                if (Number.isFinite(net)) acc.totalNet += net;
                if (Number.isFinite(bb)) acc.totalBB += bb;
                if (Number.isFinite(out)) acc.totalOut += out;
                if (Number.isFinite(iBB)) acc.intenseBB += iBB;
                if (Number.isFinite(iOut)) acc.intenseOut += iOut;
            }

            const playerList = [...byPlayer.values()]
                .map(p => ({
                    name: p.name,
                    games: p.games,
                    avgNet: p.games ? (p.totalNet / p.games) : null,
                    avgBB: p.games ? (p.totalBB / p.games) : null,
                    avgOut: p.games ? (p.totalOut / p.games) : null,
                    shareIntenseBB: (p.totalBB > 0) ? (p.intenseBB / p.totalBB) : null,
                    shareIntenseOut: (p.totalOut > 0) ? (p.intenseOut / p.totalOut) : null,
                }))
                .sort((a, b) => (Number(b.avgNet || 0) - Number(a.avgNet || 0)));

            const renderPhysischIntensityShareLinesByGame = (matchRows, canvasId) => {
                const canvas = document.getElementById(canvasId);
                if (!canvas) return;
                const parent = canvas.parentElement;
                const rect = parent ? parent.getBoundingClientRect() : canvas.getBoundingClientRect();
                const cssW = Math.max(1, Math.round(rect.width || 0));
                const cssH = Math.max(1, Math.round(rect.height || 0));
                const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
                canvas.width = Math.round(cssW * dpr);
                canvas.height = Math.round(cssH * dpr);
                canvas.style.width = cssW + 'px';
                canvas.style.height = cssH + 'px';

                const ctx = canvas.getContext('2d');
                if (!ctx) return;
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                ctx.clearRect(0, 0, cssW, cssH);

                const rows = Array.isArray(matchRows) ? matchRows : [];
                if (rows.length < 2) return;

                // Build series: share of intense meters over total meters (per match)
                const data = rows.map(r => {
                    const totBB = Number(r.total_distance_possession_km);
                    const intBB = Number(r.intense_distance_possession_km);
                    const totOut = Number(r.total_distance_outpos_km);
                    const intOut = Number(r.intense_distance_outpos_km);
                    const shareBB = (Number.isFinite(totBB) && totBB > 0 && Number.isFinite(intBB)) ? (intBB / totBB) : null;
                    const shareOut = (Number.isFinite(totOut) && totOut > 0 && Number.isFinite(intOut)) ? (intOut / totOut) : null;
                    return { shareBB, shareOut };
                });

                // y-scale: auto based on min/max across visible values in the selected window
                const padX = 0;
                const padY = 2;
                const innerW = Math.max(1, cssW - padX * 2);
                const innerH = Math.max(1, cssH - padY * 2);
                const xForIndex = (i) => padX + (innerW * (data.length === 1 ? 0 : (i / (data.length - 1))));

                const allVals = data
                    .flatMap(p => [p.shareBB, p.shareOut])
                    .filter(v => v != null && Number.isFinite(v));
                if (!allVals.length) return;

                let yMin = Math.min(...allVals);
                let yMax = Math.max(...allVals);
                if (!Number.isFinite(yMin) || !Number.isFinite(yMax)) return;
                if (yMax <= yMin) {
                    // degenerate range: draw a flat line in the middle
                    yMin = yMin - 0.01;
                    yMax = yMax + 0.01;
                } else {
                    // small padding so the line doesn't touch the edges
                    const pad = (yMax - yMin) * 0.08;
                    yMin = yMin - pad;
                    yMax = yMax + pad;
                }

                const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
                const yForShare = (s) => {
                    const t = (Number(s) - yMin) / (yMax - yMin);
                    const tt = clamp(t, 0, 1);
                    return padY + (innerH * (1 - tt));
                };

                const drawLine = (getter, strokeStyle) => {
                    ctx.beginPath();
                    let started = false;
                    for (let i = 0; i < data.length; i++) {
                        const v = getter(data[i]);
                        if (v == null || !Number.isFinite(v)) {
                            started = false;
                            continue;
                        }
                        const x = xForIndex(i);
                        const y = yForShare(v);
                        if (!started) {
                            ctx.moveTo(x, y);
                            started = true;
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.strokeStyle = strokeStyle;
                    ctx.lineWidth = 2;
                    ctx.lineJoin = 'round';
                    ctx.lineCap = 'round';
                    ctx.stroke();
                };

                // BB (HSV blue) and ggBall (blue-600)
                drawLine(p => p.shareBB, '#0A3F86');
                drawLine(p => p.shareOut, '#2563eb');
            };

            if (infoRechts) {
                const header = `
                    <div class="flex items-center justify-between">
                        <div class="text-xs font-semibold text-gray-700">Laufparameter pro Spieler</div>
                        <div class="text-[10px] text-gray-500">Ø über letzte ${Math.min(n, windowRows.length || 0)} Spiele</div>
                    </div>
                `;

                if (!playerList.length) {
                    infoRechts.innerHTML = `${header}<div class="mt-2 text-xs text-gray-500">Keine DFL-Spieler-Laufdaten gefunden.</div>`;
                } else {
                    const rowsHtml = playerList.map(p => {
                        const net = (p.avgNet != null && Number.isFinite(p.avgNet)) ? (Math.round(p.avgNet * 10) / 10).toFixed(1) : '-';
                        const bb = (p.avgBB != null && Number.isFinite(p.avgBB)) ? (Math.round(p.avgBB * 10) / 10).toFixed(1) : '-';
                        const out = (p.avgOut != null && Number.isFinite(p.avgOut)) ? (Math.round(p.avgOut * 10) / 10).toFixed(1) : '-';
                        return `
                            <div class="grid grid-cols-[minmax(0,1fr)_3.5rem_3.5rem_3.5rem] gap-2 py-1 border-b border-gray-100">
                                <div class="truncate text-[11px] text-gray-800">${p.name}</div>
                                <div class="text-[11px] text-right text-gray-700">${net}</div>
                                <div class="text-[11px] text-right text-gray-700">${bb}</div>
                                <div class="text-[11px] text-right text-gray-700">${out}</div>
                            </div>
                        `;
                    }).join('');

                    infoRechts.innerHTML = `
                        ${header}
                        <div class="mt-2 grid grid-cols-[minmax(0,1fr)_3.5rem_3.5rem_3.5rem] gap-2 text-[10px] text-gray-500 pb-1 border-b border-gray-200">
                            <div>Spieler</div>
                            <div class="text-right">Netto</div>
                            <div class="text-right">BB</div>
                            <div class="text-right">ggBall</div>
                        </div>
                        <div class="mt-1 flex-1 overflow-y-auto pr-1 min-h-0">
                            ${rowsHtml}
                        </div>
                    `;
                }
            }

            if (infoAufbau) {
                infoAufbau.innerHTML = `
                    <div class="text-[11px] leading-5 text-gray-800 space-y-1">
                        <div class="pt-3 border-t border-gray-200">
                            <div class="flex items-start justify-between gap-3 mb-2">
                                <div class="flex items-center gap-3 text-[10px] text-gray-600 ml-auto">
                                    <div class="flex items-center gap-1.5"><span class="inline-block w-2.5 h-2.5 rounded-sm bg-[#0A3F86]"></span><span>BB</span></div>
                                    <div class="flex items-center gap-1.5"><span class="inline-block w-2.5 h-2.5 rounded-sm bg-blue-600"></span><span>ggBall</span></div>
                                </div>
                            </div>

                            <div class="flex items-center justify-between gap-3">
                                <div class="flex flex-col items-center">
                                    <div class="relative w-28 h-28">
                                        <canvas id="physisch-bb-ggball-donut" class="absolute inset-0 w-full h-full"></canvas>
                                    </div>
                                    <div class="mt-1 text-[10px] text-gray-600">Gesamt</div>
                                </div>

                                <div class="flex flex-col items-center">
                                    <div class="relative w-28 h-28">
                                        <canvas id="physisch-tempo-bb-ggball-donut" class="absolute inset-0 w-full h-full"></canvas>
                                    </div>
                                    <div class="mt-1 text-[10px] text-gray-600">Tempo</div>
                                </div>

                                <div class="flex flex-col items-center">
                                    <div class="relative w-28 h-28">
                                        <canvas id="physisch-sprint-bb-ggball-donut" class="absolute inset-0 w-full h-full"></canvas>
                                    </div>
                                    <div class="mt-1 text-[10px] text-gray-600">Sprints</div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;

                // Render donuts after DOM + layout exists (prevents 0x0 canvas).
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        renderPhysischBbVsGgBallDonut(avgBB, avgOut, 'physisch-bb-ggball-donut');
                        renderPhysischBbVsGgBallDonut(avgTempoBB, avgTempoOut, 'physisch-tempo-bb-ggball-donut');
                        renderPhysischBbVsGgBallDonut(avgSprintBB, avgSprintOut, 'physisch-sprint-bb-ggball-donut');
                    });
                });
            }
            if (infoKontrolle) {
                const fmt1 = (v) => (v != null && Number.isFinite(v)) ? (Math.round(v * 10) / 10).toFixed(1) : '-';
                const fmtPct1 = (v) => (v != null && Number.isFinite(v)) ? `${(Math.round(v * 10) / 10).toFixed(1)}%` : '-';

                const avgShareIntenseTotalPct = (() => {
                    if (!windowRows.length) return null;
                    const vals = windowRows
                        .map(r => {
                            const totBB = Number(r.total_distance_possession_km);
                            const totOut = Number(r.total_distance_outpos_km);
                            const intBB = Number(r.intense_distance_possession_km);
                            const intOut = Number(r.intense_distance_outpos_km);
                            const tot = (Number.isFinite(totBB) ? totBB : 0) + (Number.isFinite(totOut) ? totOut : 0);
                            const intense = (Number.isFinite(intBB) ? intBB : 0) + (Number.isFinite(intOut) ? intOut : 0);
                            if (!Number.isFinite(tot) || tot <= 0 || !Number.isFinite(intense)) return null;
                            return (intense / tot) * 100;
                        })
                        .filter(v => v != null && Number.isFinite(v));
                    if (!vals.length) return null;
                    return vals.reduce((a, x) => a + x, 0) / vals.length;
                })();

                const intensityShareRangePct = (() => {
                    if (!windowRows.length) return { min: null, max: null };
                    const vals = windowRows
                        .flatMap(r => {
                            const totBB = Number(r.total_distance_possession_km);
                            const totOut = Number(r.total_distance_outpos_km);
                            const intBB = Number(r.intense_distance_possession_km);
                            const intOut = Number(r.intense_distance_outpos_km);

                            const shareBB = (Number.isFinite(totBB) && totBB > 0 && Number.isFinite(intBB)) ? (intBB / totBB) * 100 : null;
                            const shareOut = (Number.isFinite(totOut) && totOut > 0 && Number.isFinite(intOut)) ? (intOut / totOut) * 100 : null;
                            return [shareBB, shareOut];
                        })
                        .filter(v => v != null && Number.isFinite(v));
                    if (!vals.length) return { min: null, max: null };
                    return { min: Math.min(...vals), max: Math.max(...vals) };
                })();

                const arrowLeft = (activityPosPct != null) ? `${activityPosPct.toFixed(1)}%` : '0%';
                const showArrow = (activityPosPct != null);

                const intensityArrowLeft = (intenseMPerMinPosPct != null) ? `${intenseMPerMinPosPct.toFixed(1)}%` : '0%';
                const showIntensityArrow = (intenseMPerMinPosPct != null);

                infoKontrolle.innerHTML = `
                    <div class="grid grid-cols-2 gap-4 text-[11px] leading-5 text-gray-800">
                        <div>
                            <div class="text-[10px] font-semibold text-gray-700 mb-1">Aktivität</div>

                            <div class="flex items-end justify-between">
                                <div class="text-gray-600">m/min (Brutto)</div>
                                <div class="font-semibold text-gray-900">${fmt1(activityTotal)}</div>
                            </div>

                            <div class="mt-2">
                                <div class="relative">
                                    <div class="relative h-2 rounded-full overflow-hidden bg-gray-200">
                                        <div class="absolute inset-0 bg-gradient-to-r from-red-500 via-yellow-400 to-[#0A3F86]"></div>
                                    </div>
                                    ${showArrow ? `
                                        <div class="absolute -top-2" style="left:${arrowLeft};">
                                            <div class="absolute left-0 -translate-x-1/2 rotate-180 w-0 h-0 border-l-[6px] border-r-[6px] border-b-[8px] border-l-transparent border-r-transparent border-b-gray-900"></div>
                                        </div>
                                    ` : ``}
                                </div>
                                <div class="mt-1 flex items-center justify-between text-[10px] text-gray-500">
                                    <span>Min ${fmt1(activityAll.min)}</span>
                                    <span>Max ${fmt1(activityAll.max)}</span>
                                </div>
                            </div>

                            <div class="mt-2 space-y-0.5">
                                <div class="flex justify-between"><span class="text-gray-600">m/min in BB</span><span class="font-medium">${fmt1(activityBB)}</span></div>
                                <div class="flex justify-between"><span class="text-gray-600">m/min gg BB</span><span class="font-medium">${fmt1(activityOut)}</span></div>
                            </div>
                        </div>

                        <div>
                            <div class="text-[10px] font-semibold text-gray-700 mb-1">Intensität</div>
                            <div class="flex items-end justify-between">
                                <div class="text-gray-600">m/min intensive Läufe (Brutto)</div>
                                <div class="font-semibold text-gray-900">${fmt1(intenseMPerMinNet)}</div>
                            </div>

                            <div class="mt-2">
                                <div class="relative">
                                    <div class="relative h-2 rounded-full overflow-hidden bg-gray-200">
                                        <div class="absolute inset-0 bg-gradient-to-r from-red-500 via-yellow-400 to-[#0A3F86]"></div>
                                    </div>
                                    ${showIntensityArrow ? `
                                        <div class="absolute -top-2" style="left:${intensityArrowLeft};">
                                            <div class="absolute left-0 -translate-x-1/2 rotate-180 w-0 h-0 border-l-[6px] border-r-[6px] border-b-[8px] border-l-transparent border-r-transparent border-b-gray-900"></div>
                                        </div>
                                    ` : ``}
                                </div>
                                <div class="mt-1 flex items-center justify-between text-[10px] text-gray-500">
                                    <span>Min ${fmt1(intenseMPerMinAll.min)}</span>
                                    <span>Max ${fmt1(intenseMPerMinAll.max)}</span>
                                </div>
                            </div>

                            <div class="mt-2 space-y-0.5">
                                <div class="flex justify-between"><span class="text-gray-600">m/min intensive Läufe in BB</span><span class="font-medium">${fmt1(intenseMPerMinBB)}</span></div>
                                <div class="flex justify-between"><span class="text-gray-600">m/min intensive Läufe gg BB</span><span class="font-medium">${fmt1(intenseMPerMinOut)}</span></div>
                            </div>
                        </div>
                    </div>

                    <div class="mt-4">
                        <div class="text-center text-[10px] text-gray-600">
                            Ø Anteil intensive Meter an Gesamtdistanz: <span class="font-semibold text-gray-900">${fmtPct1(avgShareIntenseTotalPct)}</span>
                        </div>
                        <div class="mt-3 grid grid-cols-[minmax(0,1fr)_5.5rem] gap-1 items-end">
                            <div class="relative w-full h-20">
                                <canvas id="physisch-player-intensity-share-lines" class="absolute inset-0 w-full h-full"></canvas>
                                <div class="absolute bottom-0 right-0 text-[9px] text-gray-600 flex items-center gap-2 pointer-events-none">
                                    <div class="flex items-center gap-1">
                                        <span class="inline-block w-3 h-[2px] bg-[#0A3F86]"></span>
                                        <span>BB</span>
                                    </div>
                                    <div class="flex items-center gap-1">
                                        <span class="inline-block w-3 h-[2px] bg-blue-600"></span>
                                        <span>ggBall</span>
                                    </div>
                                </div>
                            </div>
                            <div class="h-20 flex flex-col justify-between text-[10px] text-gray-600 text-right pb-0.5">
                                <div class="font-medium text-gray-800">${fmtPct1(intensityShareRangePct.max)}</div>
                                <div class="font-medium text-gray-800">${fmtPct1(intensityShareRangePct.min)}</div>
                            </div>
                        </div>
                    </div>
                `;

                // Render the mini line chart after layout exists.
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        renderPhysischIntensityShareLinesByGame(windowRows, 'physisch-player-intensity-share-lines');
                    });
                });
            }
            if (infoZumTor) infoZumTor.innerHTML = '';
        } else if (isStandardsPhase) {
            // --- Standards: Eckbälle / Einwürfe / Freistöße ---
            // Toggle: "Mit dem Ball" = eigene Standards, "Gegen den Ball" = Standards gegen uns.
            const stdEvents = getStandardsEventsForTeam(currentTeam, currentGameCount, standardsMode) || [];
            const corners = stdEvents.filter(e => e.is_corner === true);
            // Für Kennzahlen: nutze nur Ecken mit validen Start-Koordinaten,
            // damit Links/Rechts-Splits und Totals konsistent sind.
            const cornersBase = corners.filter(e => Number.isFinite(Number(e.x_coord)) && Number.isFinite(Number(e.y_coord)));
            const throwIns = stdEvents.filter(e => e.is_throwin === true);
            const freekicks = stdEvents.filter(e => e.is_freekick === true);

            const per90 = (n) => gamesCount ? (Math.round((Number(n || 0) / gamesCount) * 10) / 10) : null;

            const cornerIntoBox = cornersBase.filter(e => e.end_x != null && Number(e.end_x) >= (100 - (16.5 / 105) * 100));
            const cornerIntoBoxPct = cornersBase.length ? Math.round((cornerIntoBox.length / cornersBase.length) * 1000) / 10 : null;

            // Corner delivery zones based on end coordinates (team-attacking perspective).
            // Penalty area: 16.5m depth, 40.32m width (centered). 5m-box ("5-Meter-Raum"): ~5.5m depth, 18.32m width.
            const CORNER_PITCH_LENGTH_M = 105;
            const CORNER_PITCH_WIDTH_M = 68;
            const PENALTY_BOX_DEPTH_M = 16.5;
            const PENALTY_BOX_WIDTH_M = 40.32;
            const SIX_YARD_DEPTH_M = 5.5;
            const SIX_YARD_WIDTH_M = 18.32;
            const boxYBounds = (boxWidthM) => {
                const half = (boxWidthM / 2) / CORNER_PITCH_WIDTH_M * 100;
                return { minY: 50 - half, maxY: 50 + half };
            };
            const { minY: penMinY, maxY: penMaxY } = boxYBounds(PENALTY_BOX_WIDTH_M);
            const { minY: sixMinY, maxY: sixMaxY } = boxYBounds(SIX_YARD_WIDTH_M);
            const penMinX = 100 - (PENALTY_BOX_DEPTH_M / CORNER_PITCH_LENGTH_M) * 100;
            const sixMinX = 100 - (SIX_YARD_DEPTH_M / CORNER_PITCH_LENGTH_M) * 100;
            const cornersIntoPenaltyArea = cornersBase.filter(e => {
                const ex = Number(e.end_x);
                const ey = Number(e.end_y);
                return Number.isFinite(ex) && Number.isFinite(ey) && ex >= penMinX && ey >= penMinY && ey <= penMaxY;
            });
            const cornersIntoSixYardBox = cornersBase.filter(e => {
                const ex = Number(e.end_x);
                const ey = Number(e.end_y);
                return Number.isFinite(ex) && Number.isFinite(ey) && ex >= sixMinX && ey >= sixMinY && ey <= sixMaxY;
            });

            const throwFinalThird = throwIns.filter(e => e.x_coord != null && Number(e.x_coord) >= 66.6);
            const throwFinalThirdPct = throwIns.length ? Math.round((throwFinalThird.length / throwIns.length) * 1000) / 10 : null;

            const fkIntoFinalThird = freekicks.filter(e => e.end_x != null && Number(e.end_x) >= 66.6);
            const fkIntoFinalThirdPct = freekicks.length ? Math.round((fkIntoFinalThird.length / freekicks.length) * 1000) / 10 : null;

            // ---- Freistoß KPIs (für Standards → Freistoß) ----
            const fkBase = freekicks.filter(e =>
                Number.isFinite(Number(e.x_coord)) &&
                Number.isFinite(Number(e.y_coord)) &&
                Number.isFinite(Number(e.end_x)) &&
                Number.isFinite(Number(e.end_y))
            );
            const fkSucc = fkBase.filter(e => String(e.outcome || '') === 'Successful');
            const fkSuccPctT = fkBase.length ? Math.round((fkSucc.length / fkBase.length) * 1000) : null;

            const fkStartFinalThird = fkBase.filter(e => Number(e.x_coord) >= 66.6);
            const fkStartFinalThirdPctT = fkBase.length ? Math.round((fkStartFinalThird.length / fkBase.length) * 1000) : null;

            const fkStartWideFinalThird = fkBase.filter(e => {
                const x = Number(e.x_coord);
                const y = Number(e.y_coord);
                return Number.isFinite(x) && Number.isFinite(y) && x >= 66.6 && (y < 33.3 || y > 66.6);
            });
            const fkStartWideFinalThirdPctT = fkBase.length ? Math.round((fkStartWideFinalThird.length / fkBase.length) * 1000) : null;

            const fkIntoBox = fkBase.filter(e => {
                const ex = Number(e.end_x);
                const ey = Number(e.end_y);
                return Number.isFinite(ex) && Number.isFinite(ey) && ex >= penMinX && ey >= penMinY && ey <= penMaxY;
            });
            const fkIntoBoxPctT = fkBase.length ? Math.round((fkIntoBox.length / fkBase.length) * 1000) : null;

            const isShortFk = (e) => {
                const pl = Number(e?.pass_length);
                if (Number.isFinite(pl)) return pl <= 15;
                const sx = Number(e?.x_coord);
                const sy = Number(e?.y_coord);
                const ex = Number(e?.end_x);
                const ey = Number(e?.end_y);
                if (Number.isFinite(sx) && Number.isFinite(sy) && Number.isFinite(ex) && Number.isFinite(ey)) {
                    const dx = (ex - sx);
                    const dy = (ey - sy);
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    return dist <= 12; // proxy in %-units
                }
                return false;
            };
            const fkShort = fkBase.filter(isShortFk);
            const fkShortPctT = fkBase.length ? Math.round((fkShort.length / fkBase.length) * 1000) : null;

            const fkPossession = (() => {
                if (!fkBase.length) return { kept: 0, lost: 0, keptPctT: null };
                const matchIds = new Set(fkBase.map(e => String(e.match_id ?? '')).filter(Boolean));
                const sel = (eventDataset || []).filter(e => e && e.match_id != null && matchIds.has(String(e.match_id)));
                if (!sel.length) return { kept: 0, lost: 0, keptPctT: null };

                const periodOrder = new Map([
                    ['FirstHalf', 0],
                    ['SecondHalf', 2700],
                    ['FirstPeriodOfExtraTime', 5400],
                    ['SecondPeriodOfExtraTime', 6300],
                    ['PenaltyShootout', 7200],
                ]);
                const comparator = (a, b) => {
                    const pa = periodOrder.has(a.period) ? periodOrder.get(a.period) : 999999;
                    const pb = periodOrder.has(b.period) ? periodOrder.get(b.period) : 999999;
                    if (pa !== pb) return pa - pb;
                    const ma = Number(a.minute || 0);
                    const mb = Number(b.minute || 0);
                    if (ma !== mb) return ma - mb;
                    const sa = Number(a.second || 0);
                    const sb = Number(b.second || 0);
                    if (sa !== sb) return sa - sb;
                    const ea = Number(a.eventId || 0);
                    const eb = Number(b.eventId || 0);
                    if (ea !== eb) return ea - eb;
                    return Number(a.id || 0) - Number(b.id || 0);
                };

                const controlled = new Set(['Pass', 'Carry', 'TakeOn', 'BallTouch', 'Shot', 'Goal', 'MissedShots', 'SavedShot']);
                const isStopMarker = (n) => (n.is_freekick === true || n.is_corner === true || n.is_throwin === true ||
                    n.event_type === 'FreekickAwarded' || n.event_type === 'CornerAwarded' || n.event_type === 'ThrowInAwarded');

                const byMatch = new Map();
                for (const e of sel) {
                    const mid = String(e.match_id ?? '');
                    if (!mid) continue;
                    if (!byMatch.has(mid)) byMatch.set(mid, []);
                    byMatch.get(mid).push(e);
                }
                for (const rows of byMatch.values()) rows.sort(comparator);

                let kept = 0;
                let lost = 0;
                for (const t of fkBase) {
                    const mid = String(t.match_id ?? '');
                    const rows = byMatch.get(mid);
                    if (!rows || !rows.length) continue;
                    const tid = t.id;
                    const teid = t.eventId;
                    let idx = -1;
                    if (tid != null) idx = rows.findIndex(r => r && r.id === tid);
                    else if (teid != null) idx = rows.findIndex(r => r && r.eventId === teid);
                    if (idx < 0) continue;

                    let nextTeam = null;
                    for (let j = idx + 1; j < rows.length; j++) {
                        const n = rows[j];
                        if (!n || !n.team) continue;
                        if (isStopMarker(n)) break;
                        if (!controlled.has(n.event_type)) continue;
                        nextTeam = n.team;
                        break;
                    }
                    if (!nextTeam) continue;
                    if (String(nextTeam) === String(t.team)) kept += 1;
                    else lost += 1;
                }
                const denom = kept + lost;
                const keptPctT = denom ? Math.round((kept / denom) * 1000) : null;
                return { kept, lost, keptPctT };
            })();

            const fkChancesGoals = (() => {
                if (!fkBase.length) return { chances: 0, goals: 0, directShots: 0, directGoals: 0, chancesPctT: null, goalsPctT: null, directShotsPctT: null, directGoalsPctT: null };
                const matchIds = new Set(fkBase.map(e => String(e.match_id ?? '')).filter(Boolean));
                const sel = (eventDataset || []).filter(e => e && e.match_id != null && matchIds.has(String(e.match_id)));
                if (!sel.length) return { chances: 0, goals: 0, directShots: 0, directGoals: 0, chancesPctT: null, goalsPctT: null, directShotsPctT: null, directGoalsPctT: null };

                const periodOrder = new Map([
                    ['FirstHalf', 0],
                    ['SecondHalf', 2700],
                    ['FirstPeriodOfExtraTime', 5400],
                    ['SecondPeriodOfExtraTime', 6300],
                    ['PenaltyShootout', 7200],
                ]);
                const comparator = (a, b) => {
                    const pa = periodOrder.has(a.period) ? periodOrder.get(a.period) : 999999;
                    const pb = periodOrder.has(b.period) ? periodOrder.get(b.period) : 999999;
                    if (pa !== pb) return pa - pb;
                    const ma = Number(a.minute || 0);
                    const mb = Number(b.minute || 0);
                    if (ma !== mb) return ma - mb;
                    const sa = Number(a.second || 0);
                    const sb = Number(b.second || 0);
                    if (sa !== sb) return sa - sb;
                    const ea = Number(a.eventId || 0);
                    const eb = Number(b.eventId || 0);
                    if (ea !== eb) return ea - eb;
                    return Number(a.id || 0) - Number(b.id || 0);
                };

                const controlled = new Set(['Pass', 'Carry', 'TakeOn', 'BallTouch', 'Shot', 'Goal', 'MissedShots', 'SavedShot']);
                const shotTypes = new Set(['Shot', 'Goal', 'MissedShots', 'SavedShot']);
                const isStopMarker = (n) => (n.is_freekick === true || n.is_corner === true || n.is_throwin === true ||
                    n.event_type === 'FreekickAwarded' || n.event_type === 'CornerAwarded' || n.event_type === 'ThrowInAwarded');

                const byMatch = new Map();
                for (const e of sel) {
                    const mid = String(e.match_id ?? '');
                    if (!mid) continue;
                    if (!byMatch.has(mid)) byMatch.set(mid, []);
                    byMatch.get(mid).push(e);
                }
                for (const rows of byMatch.values()) rows.sort(comparator);

                let chances = 0;
                let goals = 0;
                let directShots = 0;
                let directGoals = 0;

                for (const t of fkBase) {
                    const mid = String(t.match_id ?? '');
                    const rows = byMatch.get(mid);
                    if (!rows || !rows.length) continue;
                    const tid = t.id;
                    const teid = t.eventId;
                    let idx = -1;
                    if (tid != null) idx = rows.findIndex(r => r && r.id === tid);
                    else if (teid != null) idx = rows.findIndex(r => r && r.eventId === teid);
                    if (idx < 0) continue;

                    let hasChance = false;
                    let hasGoal = false;
                    let firstControlled = null;

                    for (let j = idx + 1; j < rows.length; j++) {
                        const n = rows[j];
                        if (!n || !n.team) continue;
                        if (isStopMarker(n)) break;
                        if (!controlled.has(n.event_type)) continue;
                        if (String(n.team) !== String(t.team)) break;

                        if (!firstControlled) firstControlled = n;

                        const isShot = shotTypes.has(n.event_type) || n.isShot === true;
                        if (isShot) hasChance = true;
                        const isGoal = (n.event_type === 'Goal') || n.isGoal === true;
                        if (isGoal) { hasGoal = true; break; }
                    }

                    if (firstControlled) {
                        const isDirectShot = shotTypes.has(firstControlled.event_type) || firstControlled.isShot === true;
                        if (isDirectShot) directShots += 1;
                        const isDirectGoal = (firstControlled.event_type === 'Goal') || firstControlled.isGoal === true;
                        if (isDirectGoal) directGoals += 1;
                    }

                    if (hasChance) chances += 1;
                    if (hasGoal) goals += 1;
                }

                const denom = fkBase.length;
                const chancesPctT = denom ? Math.round((chances / denom) * 1000) : null;
                const goalsPctT = denom ? Math.round((goals / denom) * 1000) : null;
                const directShotsPctT = denom ? Math.round((directShots / denom) * 1000) : null;
                const directGoalsPctT = denom ? Math.round((directGoals / denom) * 1000) : null;
                return { chances, goals, directShots, directGoals, chancesPctT, goalsPctT, directShotsPctT, directGoalsPctT };
            })();

            if (infoAufbau) {
                // NOTE: lastOpenCornerTab wird im Standards-Header als Auswahl für
                // 'eckball' | 'einwurf' | 'freistoss' verwendet (und steuert u.a. die
                // Eckball-Pfeile im Pitch). In diesem Block gab es zusätzlich interne
                // Sub-Tabs (volumen/ausfuehrung/...), die lastOpenCornerTab überschrieben
                // haben. Das führte dazu, dass der Eckball-Branch nie mehr aktiv war.
                // => Wir nutzen hier nur eine lokale Variable und ändern lastOpenCornerTab nicht.
                const activeCornerTab = (
                    lastOpenCornerTab === 'volumen' ||
                    lastOpenCornerTab === 'ausfuehrung' ||
                    lastOpenCornerTab === 'zielzonen' ||
                    lastOpenCornerTab === 'second-phase' ||
                    lastOpenCornerTab === 'ballbesitz' ||
                    lastOpenCornerTab === 'schuetzen'
                ) ? lastOpenCornerTab : 'volumen';

                const tabBase = 'px-3 py-1 rounded-md text-xs font-medium border border-gray-300 bg-white text-gray-700 hover:bg-gray-50';
                const tabActive = 'bg-[#0A3F86] text-white border-[#0A3F86] hover:bg-[#0A3F86]';
                const tabClass = (key) => `${tabBase} ${activeCornerTab === key ? tabActive : ''}`;
                const panelClass = (key) => `${activeCornerTab === key ? '' : 'hidden'} mt-3`;

                const cornersSucc = cornersBase.filter(e => e.outcome === 'Successful');
                const cornersSuccPct = cornersBase.length ? Math.round((cornersSucc.length / cornersBase.length) * 1000) / 10 : null;

                // Chancen/Tore nach Ecken: pro Ecke prüfen, ob im "Corner-Phase" Fenster
                // (bis zur nächsten Ecke/CornerAwarded oder bis zur ersten kontrollierten Aktion des Gegners)
                // ein Abschluss bzw. ein Tor entsteht. Damit wird ein Tor nicht fälschlich mehreren
                // aufeinanderfolgenden Ecken zugerechnet.
                const cornerChancesGoals = (() => {
                    if (!cornersBase.length) return { chances: 0, goals: 0, chancesPctT: null, goalsPctT: null };

                    const matchIds = new Set(cornersBase.map(e => String(e.match_id ?? '')).filter(Boolean));
                    if (!matchIds.size) return { chances: 0, goals: 0, chancesPctT: null, goalsPctT: null };

                    const sel = (eventDataset || []).filter(e => e && e.match_id != null && matchIds.has(String(e.match_id)));
                    if (!sel.length) return { chances: 0, goals: 0, chancesPctT: null, goalsPctT: null };

                    const periodOrder = new Map([
                        ['FirstHalf', 0],
                        ['SecondHalf', 2700],
                        ['FirstPeriodOfExtraTime', 5400],
                        ['SecondPeriodOfExtraTime', 6300],
                        ['PenaltyShootout', 7200],
                    ]);
                    const comparator = (a, b) => {
                        const pa = periodOrder.has(a.period) ? periodOrder.get(a.period) : 999999;
                        const pb = periodOrder.has(b.period) ? periodOrder.get(b.period) : 999999;
                        if (pa !== pb) return pa - pb;
                        const ma = Number(a.minute || 0);
                        const mb = Number(b.minute || 0);
                        if (ma !== mb) return ma - mb;
                        const sa = Number(a.second || 0);
                        const sb = Number(b.second || 0);
                        if (sa !== sb) return sa - sb;
                        const ea = Number(a.eventId || 0);
                        const eb = Number(b.eventId || 0);
                        if (ea !== eb) return ea - eb;
                        return Number(a.id || 0) - Number(b.id || 0);
                    };

                    const controlled = new Set(['Pass', 'Carry', 'TakeOn', 'BallTouch', 'Shot', 'Goal', 'MissedShots', 'SavedShot']);
                    const shotTypes = new Set(['Shot', 'Goal', 'MissedShots', 'SavedShot']);

                    const byMatch = new Map();
                    for (const e of sel) {
                        const mid = String(e.match_id ?? '');
                        if (!mid) continue;
                        if (!byMatch.has(mid)) byMatch.set(mid, []);
                        byMatch.get(mid).push(e);
                    }
                    for (const rows of byMatch.values()) rows.sort(comparator);

                    let chances = 0;
                    let goals = 0;

                    for (const c of cornersBase) {
                        const mid = String(c.match_id ?? '');
                        const rows = byMatch.get(mid);
                        if (!rows || !rows.length) continue;

                        const cid = c.id;
                        let idx = -1;
                        if (cid != null) idx = rows.findIndex(r => r && r.id === cid);
                        if (idx < 0) continue;

                        let hasChance = false;
                        let hasGoal = false;
                        for (let j = idx + 1; j < rows.length; j++) {
                            const n = rows[j];
                            if (!n || !n.team) continue;

                            // Stop if a new corner sequence starts (prevents double-counting goals across consecutive corners).
                            if (n.is_corner === true || n.event_type === 'CornerAwarded') break;
                            if (!controlled.has(n.event_type)) continue;

                            // possession / phase ends once opponent has a controlled action
                            if (String(n.team) !== String(c.team)) break;

                            const isShot = shotTypes.has(n.event_type) || n.isShot === true;
                            if (isShot) hasChance = true;
                            const isGoal = (n.event_type === 'Goal') || n.isGoal === true;
                            if (isGoal) hasGoal = true;

                            // if we already have a goal, no need to scan further
                            if (hasGoal) break;
                        }

                        if (hasChance) chances += 1;
                        if (hasGoal) goals += 1;
                    }

                    const denom = cornersBase.length || 0;
                    const chancesPctT = denom ? Math.round((chances / denom) * 1000) : null;
                    const goalsPctT = denom ? Math.round((goals / denom) * 1000) : null;
                    return { chances, goals, chancesPctT, goalsPctT };
                })();

                // Short corner proxy: prefer pass_length if present, else end_x not deep.
                const isShortCorner = (e) => {
                    const pl = Number(e.pass_length);
                    if (Number.isFinite(pl)) return pl <= 15;
                    const ex = Number(e.end_x);
                    if (Number.isFinite(ex)) return ex < 75;
                    return false;
                };
                const shortCorners = cornersBase.filter(isShortCorner);
                const shortCornersPct = cornersBase.length ? Math.round((shortCorners.length / cornersBase.length) * 1000) / 10 : null;

                // Zielkategorien für die Kurzübersicht müssen exklusiv sein:
                // Kurz | 5m-Raum | 16er (ohne 5m) | Andere  => zusammen 100%.
                const isIntoPenaltyArea = (e) => {
                    const ex = Number(e.end_x);
                    const ey = Number(e.end_y);
                    return Number.isFinite(ex) && Number.isFinite(ey) && ex >= penMinX && ey >= penMinY && ey <= penMaxY;
                };
                const isIntoSixYard = (e) => {
                    const ex = Number(e.end_x);
                    const ey = Number(e.end_y);
                    return Number.isFinite(ex) && Number.isFinite(ey) && ex >= sixMinX && ey >= sixMinY && ey <= sixMaxY;
                };
                const cornersShort = shortCorners;
                const cornersLong = cornersBase.filter(e => !isShortCorner(e));
                const cornersLongIntoSix = cornersLong.filter(isIntoSixYard);
                const cornersLongIntoPenaltyNotSix = cornersLong.filter(e => isIntoPenaltyArea(e) && !isIntoSixYard(e));
                const cornersOther = cornersBase.filter(e => !isShortCorner(e) && !isIntoPenaltyArea(e));

                const pctTenthsFromCount = (count) => cornersBase.length ? Math.round((count / cornersBase.length) * 1000) : null;
                const fmtPctTenthsComma1 = (tenths) => {
                    const n = Number(tenths);
                    if (!Number.isFinite(n)) return '-';
                    return `${(n / 10).toFixed(1).replace('.', ',')}%`;
                };
                const shortPctT = pctTenthsFromCount(cornersShort.length);
                const sixPctT = pctTenthsFromCount(cornersLongIntoSix.length);
                const penNoSixPctT = pctTenthsFromCount(cornersLongIntoPenaltyNotSix.length);
                const otherPctT = cornersBase.length ? Math.max(0, 1000 - (Number(shortPctT || 0) + Number(sixPctT || 0) + Number(penNoSixPctT || 0))) : null;

                // Breakdown for successful corners ("zum Mitspieler"); % should be relative to ALL taken corners (cornersBase).
                const succShortCount = cornersSucc.filter(isShortCorner).length;
                const succIntoBoxCount = cornersSucc.filter(isIntoPenaltyArea).length;
                const succShortPctAllT = cornersBase.length ? Math.round((succShortCount / cornersBase.length) * 1000) : null;
                const succIntoBoxPctAllT = cornersBase.length ? Math.round((succIntoBoxCount / cornersBase.length) * 1000) : null;

                // Seiten-Statistiken (Links / Rechts) nach Ausführungsseite (Start y_coord)
                // Wichtig: Links/Rechts muss zur Darstellung im Canvas passen.
                // Im Eckball-Plot wird bei needsInversion die Breite gespiegelt (cx = 100 - y).
                // => Für die Side-Klassifikation verwenden wir dieselbe "Display-Y" Logik.
                const needsInversionForCorners = (currentTeam !== baseTeam);
                const yDispCorner = (y) => {
                    const n = Number(y);
                    if (!Number.isFinite(n)) return null;
                    return needsInversionForCorners ? (100 - n) : n;
                };
                const cornersLeft = cornersBase.filter(e => {
                    const yy = yDispCorner(e.y_coord);
                    return yy != null && yy < 50;
                });
                const cornersRight = cornersBase.filter(e => {
                    const yy = yDispCorner(e.y_coord);
                    return yy != null && yy >= 50;
                });

                const fmtPctComma1 = (v) => {
                    const n = Number(v);
                    if (!Number.isFinite(n)) return '-';
                    return `${n.toFixed(1).replace('.', ',')}%`;
                };

                const cornersLeftPct = cornersBase.length ? Math.round((cornersLeft.length / cornersBase.length) * 1000) / 10 : null;
                const cornersRightPct = cornersBase.length ? Math.round((cornersRight.length / cornersBase.length) * 1000) / 10 : null;
                const cornersIntoPenaltyAreaPct = cornersBase.length ? Math.round((cornersIntoPenaltyArea.length / cornersBase.length) * 1000) / 10 : null;
                const cornersIntoSixYardBoxPct = cornersBase.length ? Math.round((cornersIntoSixYardBox.length / cornersBase.length) * 1000) / 10 : null;

                // Penalty-Spot (Elferpunkt) ~ 11m vom Tor: in Prozent der Pitch-Länge
                const penaltyX = 100 - (11 / 105) * 100; // ~89.52
                const penaltyY = 50;
                const distToPenalty = (e) => {
                    if (e.end_x == null || e.end_y == null) return Infinity;
                    const dx = Number(e.end_x) - penaltyX;
                    const dy = Number(e.end_y) - penaltyY;
                    return Math.sqrt(dx * dx + dy * dy);
                };
                const cornersToPenalty = corners.filter(e => distToPenalty(e) <= 3); // within ~3% radius

                // Helper per90
                const cornersLeftP90 = per90(cornersLeft.length);
                const cornersRightP90 = per90(cornersRight.length);
                const shortCornersP90 = per90(shortCorners.length);
                const cornersToPenaltyP90 = per90(cornersToPenalty.length);
                const cornersIntoPenaltyAreaP90 = per90(cornersIntoPenaltyArea.length);
                const cornersIntoSixYardBoxP90 = per90(cornersIntoSixYardBox.length);
                const cornersArrivedP90 = per90(cornersSucc.length);
                const cornersLongIntoPenaltyNotSixP90 = per90(cornersLongIntoPenaltyNotSix.length);
                const cornersLongIntoSixP90 = per90(cornersLongIntoSix.length);
                const cornersOtherP90 = per90(cornersOther.length);

                // ---- Einwurf KPIs (für Standards → Einwurf) ----
                const throwBase = throwIns.filter(e =>
                    Number.isFinite(Number(e.x_coord)) &&
                    Number.isFinite(Number(e.y_coord)) &&
                    Number.isFinite(Number(e.end_x)) &&
                    Number.isFinite(Number(e.end_y))
                );
                const throwSucc = throwBase.filter(e => e.outcome === 'Successful');
                const throwSuccPctT = throwBase.length ? Math.round((throwSucc.length / throwBase.length) * 1000) : null;
                const throwInFinalThird = throwBase.filter(e => Number(e.x_coord) >= 66.6);
                const throwInFinalThirdPctT = throwBase.length ? Math.round((throwInFinalThird.length / throwBase.length) * 1000) : null;
                const throwIntoFinalThird = throwBase.filter(e => Number(e.x_coord) < 66.6 && Number(e.end_x) >= 66.6);
                const throwIntoFinalThirdPctT = throwBase.length ? Math.round((throwIntoFinalThird.length / throwBase.length) * 1000) : null;
                const throwIntoBox = throwBase.filter(e => {
                    const ex = Number(e.end_x);
                    const ey = Number(e.end_y);
                    return Number.isFinite(ex) && Number.isFinite(ey) && ex >= penMinX && ey >= penMinY && ey <= penMaxY;
                });
                const throwIntoBoxPctT = throwBase.length ? Math.round((throwIntoBox.length / throwBase.length) * 1000) : null;

                // Schnelle Einwürfe: Proxy für "Ball im Aus" ist die letzte Aktion vor dem Einwurf,
                // typischerweise eine Aktion des Gegners (letzter Kontakt). Schwelle fix: <= 8s.
                const throwQuick = (() => {
                    const QUICK_THROW_SECONDS = 8;
                    if (!throwBase.length) return { n: 0, pctT: null, thresholdSec: QUICK_THROW_SECONDS };

                    const matchIds = new Set(throwBase.map(e => String(e.match_id ?? '')).filter(Boolean));
                    const sel = (eventDataset || []).filter(e => e && e.match_id != null && matchIds.has(String(e.match_id)));
                    if (!sel.length) return { n: 0, pctT: null, thresholdSec: QUICK_THROW_SECONDS };

                    const periodOrder = new Map([
                        ['FirstHalf', 0],
                        ['SecondHalf', 2700],
                        ['FirstPeriodOfExtraTime', 5400],
                        ['SecondPeriodOfExtraTime', 6300],
                        ['PenaltyShootout', 7200],
                    ]);
                    const tSec = (e) => {
                        const base = periodOrder.has(e.period) ? periodOrder.get(e.period) : 0;
                        const m = Number(e.minute || 0);
                        const s = Number(e.second || 0);
                        return base + (m * 60) + s;
                    };
                    const comparator = (a, b) => {
                        const pa = periodOrder.has(a.period) ? periodOrder.get(a.period) : 999999;
                        const pb = periodOrder.has(b.period) ? periodOrder.get(b.period) : 999999;
                        if (pa !== pb) return pa - pb;
                        const ma = Number(a.minute || 0);
                        const mb = Number(b.minute || 0);
                        if (ma !== mb) return ma - mb;
                        const sa = Number(a.second || 0);
                        const sb = Number(b.second || 0);
                        if (sa !== sb) return sa - sb;
                        const ea = Number(a.eventId || 0);
                        const eb = Number(b.eventId || 0);
                        if (ea !== eb) return ea - eb;
                        return Number(a.id || 0) - Number(b.id || 0);
                    };

                    const byMatch = new Map();
                    for (const e of sel) {
                        const mid = String(e.match_id ?? '');
                        if (!mid) continue;
                        if (!byMatch.has(mid)) byMatch.set(mid, []);
                        byMatch.get(mid).push(e);
                    }
                    for (const rows of byMatch.values()) rows.sort(comparator);

                    const stoppageTypes = new Set(['SubstitutionOn', 'SubstitutionOff', 'Card', 'Start', 'End']);

                    let quick = 0;
                    let counted = 0;
                    for (const t of throwBase) {
                        const mid = String(t.match_id ?? '');
                        const rows = byMatch.get(mid);
                        if (!rows || !rows.length) continue;
                        const tid = t.id;
                        if (tid == null) continue;
                        const idx = rows.findIndex(r => r && r.id === tid);
                        if (idx < 0) continue;

                        const throwTime = tSec(rows[idx]);
                        let outTime = null;
                        for (let j = idx - 1; j >= 0; j--) {
                            const p = rows[j];
                            if (!p || !p.team) continue;
                            if (p.is_throwin === true) continue;
                            if (stoppageTypes.has(p.event_type)) continue;
                            // last touch is usually opponent (throw is awarded to opposite team)
                            if (String(p.team) === String(t.team)) continue;
                            const dt = throwTime - tSec(p);
                            // only accept plausible windows
                            if (dt < 0) continue;
                            if (dt > 60) break;
                            outTime = tSec(p);
                            break;
                        }
                        if (outTime == null) continue;
                        const dt = throwTime - outTime;
                        counted += 1;
                        if (dt <= QUICK_THROW_SECONDS) quick += 1;
                    }
                    const pctT = counted ? Math.round((quick / counted) * 1000) : null;
                    return { n: quick, pctT, thresholdSec: QUICK_THROW_SECONDS };
                })();

                const throwPossession = (() => {
                    if (!throwBase.length) return { kept: 0, lost: 0, keptPctT: null };
                    const matchIds = new Set(throwBase.map(e => String(e.match_id ?? '')).filter(Boolean));
                    const sel = (eventDataset || []).filter(e => e && e.match_id != null && matchIds.has(String(e.match_id)));
                    if (!sel.length) return { kept: 0, lost: 0, keptPctT: null };

                    const periodOrder = new Map([
                        ['FirstHalf', 0],
                        ['SecondHalf', 2700],
                        ['FirstPeriodOfExtraTime', 5400],
                        ['SecondPeriodOfExtraTime', 6300],
                        ['PenaltyShootout', 7200],
                    ]);
                    const comparator = (a, b) => {
                        const pa = periodOrder.has(a.period) ? periodOrder.get(a.period) : 999999;
                        const pb = periodOrder.has(b.period) ? periodOrder.get(b.period) : 999999;
                        if (pa !== pb) return pa - pb;
                        const ma = Number(a.minute || 0);
                        const mb = Number(b.minute || 0);
                        if (ma !== mb) return ma - mb;
                        const sa = Number(a.second || 0);
                        const sb = Number(b.second || 0);
                        if (sa !== sb) return sa - sb;
                        const ea = Number(a.eventId || 0);
                        const eb = Number(b.eventId || 0);
                        if (ea !== eb) return ea - eb;
                        return Number(a.id || 0) - Number(b.id || 0);
                    };

                    const controlled = new Set(['Pass', 'Carry', 'TakeOn', 'BallTouch', 'Shot', 'Goal', 'MissedShots', 'SavedShot']);
                    const byMatch = new Map();
                    for (const e of sel) {
                        const mid = String(e.match_id ?? '');
                        if (!mid) continue;
                        if (!byMatch.has(mid)) byMatch.set(mid, []);
                        byMatch.get(mid).push(e);
                    }
                    for (const rows of byMatch.values()) rows.sort(comparator);

                    let kept = 0;
                    let lost = 0;
                    for (const t of throwBase) {
                        const mid = String(t.match_id ?? '');
                        const rows = byMatch.get(mid);
                        if (!rows || !rows.length) continue;
                        const tid = t.id;
                        if (tid == null) continue;
                        const idx = rows.findIndex(r => r && r.id === tid);
                        if (idx < 0) continue;
                        let nextTeam = null;
                        for (let j = idx + 1; j < rows.length; j++) {
                            const n = rows[j];
                            if (!n || !n.team) continue;
                            if (n.is_throwin === true || n.event_type === 'ThrowInAwarded') break;
                            if (!controlled.has(n.event_type)) continue;
                            nextTeam = n.team;
                            break;
                        }
                        if (!nextTeam) continue;
                        if (String(nextTeam) === String(t.team)) kept += 1;
                        else lost += 1;
                    }
                    const denom = kept + lost;
                    const keptPctT = denom ? Math.round((kept / denom) * 1000) : null;
                    return { kept, lost, keptPctT };
                })();

                // Erfolgreiche Folgeaktionen nach erfolgreichem Einwurf:
                // Anteil der nächsten kontrollierten Aktion (z.B. Pass) die ebenfalls erfolgreich ist.
                const throwFollowAction = (() => {
                    if (!throwSucc.length) return { succ: 0, total: 0, pctT: null };
                    const matchIds = new Set(throwSucc.map(e => String(e.match_id ?? '')).filter(Boolean));
                    const sel = (eventDataset || []).filter(e => e && e.match_id != null && matchIds.has(String(e.match_id)));
                    if (!sel.length) return { succ: 0, total: 0, pctT: null };

                    const periodOrder = new Map([
                        ['FirstHalf', 0],
                        ['SecondHalf', 2700],
                        ['FirstPeriodOfExtraTime', 5400],
                        ['SecondPeriodOfExtraTime', 6300],
                        ['PenaltyShootout', 7200],
                    ]);
                    const comparator = (a, b) => {
                        const pa = periodOrder.has(a.period) ? periodOrder.get(a.period) : 999999;
                        const pb = periodOrder.has(b.period) ? periodOrder.get(b.period) : 999999;
                        if (pa !== pb) return pa - pb;
                        const ma = Number(a.minute || 0);
                        const mb = Number(b.minute || 0);
                        if (ma !== mb) return ma - mb;
                        const sa = Number(a.second || 0);
                        const sb = Number(b.second || 0);
                        if (sa !== sb) return sa - sb;
                        const ea = Number(a.eventId || 0);
                        const eb = Number(b.eventId || 0);
                        if (ea !== eb) return ea - eb;
                        return Number(a.id || 0) - Number(b.id || 0);
                    };

                    const controlled = new Set(['Pass', 'Carry', 'TakeOn', 'BallTouch', 'Shot', 'Goal', 'MissedShots', 'SavedShot']);
                    const byMatch = new Map();
                    for (const e of sel) {
                        const mid = String(e.match_id ?? '');
                        if (!mid) continue;
                        if (!byMatch.has(mid)) byMatch.set(mid, []);
                        byMatch.get(mid).push(e);
                    }
                    for (const rows of byMatch.values()) rows.sort(comparator);

                    let succ = 0;
                    let total = 0;
                    for (const t of throwSucc) {
                        const mid = String(t.match_id ?? '');
                        const rows = byMatch.get(mid);
                        if (!rows || !rows.length) continue;
                        const tid = t.id;
                        const teid = t.eventId;
                        let idx = -1;
                        if (tid != null) idx = rows.findIndex(r => r && r.id === tid);
                        else if (teid != null) idx = rows.findIndex(r => r && r.eventId === teid);
                        if (idx < 0) continue;

                        let nextAction = null;
                        for (let j = idx + 1; j < rows.length; j++) {
                            const n = rows[j];
                            if (!n || !n.team) continue;
                            if (n.is_throwin === true || n.event_type === 'ThrowInAwarded') break;
                            if (!controlled.has(n.event_type)) continue;
                            if (String(n.team) !== String(t.team)) break;
                            nextAction = n;
                            break;
                        }
                        if (!nextAction) continue;
                        total += 1;

                        let isSucc = true;
                        const out = nextAction.outcome;
                        if (out != null && String(out).trim() !== '') {
                            isSucc = (String(out) === 'Successful');
                        } else if (nextAction.event_type === 'Goal' || nextAction.isGoal === true) {
                            isSucc = true;
                        }
                        if (isSucc) succ += 1;
                    }

                    const pctT = total ? Math.round((succ / total) * 1000) : null;
                    return { succ, total, pctT };
                })();

                const throwChancesGoals = (() => {
                    if (!throwBase.length) return { chances: 0, goals: 0, chancesPctT: null, goalsPctT: null };
                    const matchIds = new Set(throwBase.map(e => String(e.match_id ?? '')).filter(Boolean));
                    const sel = (eventDataset || []).filter(e => e && e.match_id != null && matchIds.has(String(e.match_id)));
                    if (!sel.length) return { chances: 0, goals: 0, chancesPctT: null, goalsPctT: null };

                    const periodOrder = new Map([
                        ['FirstHalf', 0],
                        ['SecondHalf', 2700],
                        ['FirstPeriodOfExtraTime', 5400],
                        ['SecondPeriodOfExtraTime', 6300],
                        ['PenaltyShootout', 7200],
                    ]);
                    const comparator = (a, b) => {
                        const pa = periodOrder.has(a.period) ? periodOrder.get(a.period) : 999999;
                        const pb = periodOrder.has(b.period) ? periodOrder.get(b.period) : 999999;
                        if (pa !== pb) return pa - pb;
                        const ma = Number(a.minute || 0);
                        const mb = Number(b.minute || 0);
                        if (ma !== mb) return ma - mb;
                        const sa = Number(a.second || 0);
                        const sb = Number(b.second || 0);
                        if (sa !== sb) return sa - sb;
                        const ea = Number(a.eventId || 0);
                        const eb = Number(b.eventId || 0);
                        if (ea !== eb) return ea - eb;
                        return Number(a.id || 0) - Number(b.id || 0);
                    };

                    const controlled = new Set(['Pass', 'Carry', 'TakeOn', 'BallTouch', 'Shot', 'Goal', 'MissedShots', 'SavedShot']);
                    const shotTypes = new Set(['Shot', 'Goal', 'MissedShots', 'SavedShot']);
                    const byMatch = new Map();
                    for (const e of sel) {
                        const mid = String(e.match_id ?? '');
                        if (!mid) continue;
                        if (!byMatch.has(mid)) byMatch.set(mid, []);
                        byMatch.get(mid).push(e);
                    }
                    for (const rows of byMatch.values()) rows.sort(comparator);

                    let chances = 0;
                    let goals = 0;
                    for (const t of throwBase) {
                        const mid = String(t.match_id ?? '');
                        const rows = byMatch.get(mid);
                        if (!rows || !rows.length) continue;
                        const tid = t.id;
                        if (tid == null) continue;
                        const idx = rows.findIndex(r => r && r.id === tid);
                        if (idx < 0) continue;

                        let hasChance = false;
                        let hasGoal = false;
                        for (let j = idx + 1; j < rows.length; j++) {
                            const n = rows[j];
                            if (!n || !n.team) continue;
                            if (n.is_throwin === true || n.event_type === 'ThrowInAwarded') break;
                            if (!controlled.has(n.event_type)) continue;
                            if (String(n.team) !== String(t.team)) break;
                            const isShot = shotTypes.has(n.event_type) || n.isShot === true;
                            if (isShot) hasChance = true;
                            const isGoal = (n.event_type === 'Goal') || n.isGoal === true;
                            if (isGoal) { hasGoal = true; break; }
                        }

                        if (hasChance) chances += 1;
                        if (hasGoal) goals += 1;
                    }
                    const denom = throwBase.length;
                    const chancesPctT = denom ? Math.round((chances / denom) * 1000) : null;
                    const goalsPctT = denom ? Math.round((goals / denom) * 1000) : null;
                    return { chances, goals, chancesPctT, goalsPctT };
                })();

                // Schreibe kompakte Übersicht in die linke Standards-Box (unter Buttons)
                try {
                    const cornerInfoContent = document.getElementById('corner-info-content');
                    if (cornerInfoContent) {
                        if (lastOpenCornerTab === 'einwurf') {
                            cornerInfoContent.innerHTML = `
                                <div class="text-[11px] leading-5 text-gray-800 space-y-1">
                                    <div class="font-semibold text-gray-700 mb-2">Einwurf - Kurzübersicht</div>
                                    <div class="flex justify-between"><span>Einwürfe p90</span><span class="font-medium">${fmtP90(per90(throwBase.length))}</span></div>
                                    <div class="flex justify-between"><span>Einwurf erfolgreich p90 | %</span><span class="font-medium">${fmtP90(per90(throwSucc.length))} | ${fmtPctTenthsComma1(throwSuccPctT)}</span></div>
                                    <div class="flex justify-between"><span>Erfolgreiche Aktionen nach Einwurf %</span><span class="font-medium">${fmtPctTenthsComma1(throwFollowAction.pctT)}</span></div>
                                    <div class="flex justify-between"><span>Einwurf im letzten Drittel p90 | %</span><span class="font-medium">${fmtP90(per90(throwInFinalThird.length))} | ${fmtPctTenthsComma1(throwInFinalThirdPctT)}</span></div>
                                    <div class="flex justify-between"><span>Einwurf ins letzte Drittel p90 | %</span><span class="font-medium">${fmtP90(per90(throwIntoFinalThird.length))} | ${fmtPctTenthsComma1(throwIntoFinalThirdPctT)}</span></div>
                                    <div class="flex justify-between"><span>Einwurf in die Box p90 | %</span><span class="font-medium">${fmtP90(per90(throwIntoBox.length))} | ${fmtPctTenthsComma1(throwIntoBoxPctT)}</span></div>
                                    <div class="flex justify-between"><span>Schnelle Einwürfe (≤${throwQuick.thresholdSec}s) p90 | %</span><span class="font-medium">${fmtP90(per90(throwQuick.n))} | ${fmtPctTenthsComma1(throwQuick.pctT)}</span></div>
                                    <div class="h-2"></div>
                                    <div class="flex justify-between"><span>Ballbesitz gesichert p90 | %</span><span class="font-medium">${fmtP90(per90(throwPossession.kept))} | ${fmtPctTenthsComma1(throwPossession.keptPctT)}</span></div>
                                    <div class="flex justify-between"><span>Chancen nach Einwurf p90 | %</span><span class="font-medium">${fmtP90(per90(throwChancesGoals.chances))} | ${fmtPctTenthsComma1(throwChancesGoals.chancesPctT)}</span></div>
                                    <div class="flex justify-between"><span>Tore nach Einwurf p90 | %</span><span class="font-medium">${fmtP90(per90(throwChancesGoals.goals))} | ${fmtPctTenthsComma1(throwChancesGoals.goalsPctT)}</span></div>
                                </div>
                            `;
                        } else if (lastOpenCornerTab === 'freistoss') {
                            cornerInfoContent.innerHTML = `
                                <div class="text-[11px] leading-5 text-gray-800 space-y-1">
                                    <div class="font-semibold text-gray-700 mb-2">Freistoß - Kurzübersicht</div>
                                    <div class="flex justify-between"><span>Freistöße p90</span><span class="font-medium">${fmtP90(per90(fkBase.length))}</span></div>
                                    <div class="flex justify-between"><span>Freistoß erfolgreich p90 | %</span><span class="font-medium">${fmtP90(per90(fkSucc.length))} | ${fmtPctTenthsComma1(fkSuccPctT)}</span></div>
                                    <div class="flex justify-between"><span>Freistoß im letzten Drittel (Start) p90 | %</span><span class="font-medium">${fmtP90(per90(fkStartFinalThird.length))} | ${fmtPctTenthsComma1(fkStartFinalThirdPctT)}</span></div>
                                    <div class="flex justify-between"><span>Freistoß seitlich im letzten Drittel p90 | %</span><span class="font-medium">${fmtP90(per90(fkStartWideFinalThird.length))} | ${fmtPctTenthsComma1(fkStartWideFinalThirdPctT)}</span></div>
                                    <div class="flex justify-between"><span>Freistoß in die Box p90 | %</span><span class="font-medium">${fmtP90(per90(fkIntoBox.length))} | ${fmtPctTenthsComma1(fkIntoBoxPctT)}</span></div>
                                    <div class="flex justify-between"><span>Kurz ausgeführt p90 | %</span><span class="font-medium">${fmtP90(per90(fkShort.length))} | ${fmtPctTenthsComma1(fkShortPctT)}</span></div>
                                    <div class="h-2"></div>
                                    <div class="flex justify-between"><span>Ballbesitz gesichert p90 | %</span><span class="font-medium">${fmtP90(per90(fkPossession.kept))} | ${fmtPctTenthsComma1(fkPossession.keptPctT)}</span></div>
                                    <div class="flex justify-between"><span>Chancen nach Freistoß p90 | %</span><span class="font-medium">${fmtP90(per90(fkChancesGoals.chances))} | ${fmtPctTenthsComma1(fkChancesGoals.chancesPctT)}</span></div>
                                    <div class="flex justify-between"><span>Tore nach Freistoß p90 | %</span><span class="font-medium">${fmtP90(per90(fkChancesGoals.goals))} | ${fmtPctTenthsComma1(fkChancesGoals.goalsPctT)}</span></div>
                                    <div class="flex justify-between"><span>Direkte Abschlüsse p90 | %</span><span class="font-medium">${fmtP90(per90(fkChancesGoals.directShots))} | ${fmtPctTenthsComma1(fkChancesGoals.directShotsPctT)}</span></div>
                                    <div class="flex justify-between"><span>Direkte Tore p90 | %</span><span class="font-medium">${fmtP90(per90(fkChancesGoals.directGoals))} | ${fmtPctTenthsComma1(fkChancesGoals.directGoalsPctT)}</span></div>
                                </div>
                            `;
                        } else {
                            // Default: Eckball
                            cornerInfoContent.innerHTML = `
                                <div class="text-[11px] leading-5 text-gray-800 space-y-1">
                                    <div class="font-semibold text-gray-700 mb-2">Eckball - Kurzübersicht</div>
                                    <div class="flex justify-between"><span>Ecken p90</span><span class="font-medium">${fmtP90(per90(corners.length))}</span></div>
                                    <div class="flex justify-between"><span>Ecke zum Mitspieler p90 | %</span><span class="font-medium">${cornersArrivedP90 != null ? fmtP90(cornersArrivedP90) : '-'} | ${cornersSuccPct != null ? `${cornersSuccPct.toFixed(1).replace('.', ',')}%` : '-'}</span></div>
                                    <div class="flex justify-between"><span class="pl-3 text-gray-600">davon kurz ausgeführt (N | %)</span><span class="font-medium">${succShortCount} | ${fmtPctTenthsComma1(succShortPctAllT)}</span></div>
                                    <div class="flex justify-between"><span class="pl-3 text-gray-600">davon in die Box (N | %)</span><span class="font-medium">${succIntoBoxCount} | ${fmtPctTenthsComma1(succIntoBoxPctAllT)}</span></div>
                                    <div class="flex justify-between"><span>Chancen nach Ecken p90 | %</span><span class="font-medium">${fmtP90(per90(cornerChancesGoals.chances))} | ${fmtPctTenthsComma1(cornerChancesGoals.chancesPctT)}</span></div>
                                    <div class="flex justify-between"><span>Tore nach Ecken p90 | %</span><span class="font-medium">${fmtP90(per90(cornerChancesGoals.goals))} | ${fmtPctTenthsComma1(cornerChancesGoals.goalsPctT)}</span></div>
                                    <div class="h-2"></div>
                                    <div class="flex justify-between"><span>Ecken links p90 | %</span><span class="font-medium">${cornersLeftP90 != null ? fmtP90(cornersLeftP90) : '-'} | ${fmtPctComma1(cornersLeftPct)}</span></div>
                                    <div class="flex justify-between"><span>Ecken rechts p90 | %</span><span class="font-medium">${cornersRightP90 != null ? fmtP90(cornersRightP90) : '-'} | ${fmtPctComma1(cornersRightPct)}</span></div>
                                    <div class="flex justify-between"><span>Kurz ausgeführt p90 | %</span><span class="font-medium">${shortCornersP90 != null ? fmtP90(shortCornersP90) : '-'} | ${fmtPctTenthsComma1(shortPctT)}</span></div>
                                    <div class="flex justify-between"><span>Ecken in den 16er (ohne 5m) p90 | %</span><span class="font-medium">${cornersLongIntoPenaltyNotSixP90 != null ? fmtP90(cornersLongIntoPenaltyNotSixP90) : '-'} | ${fmtPctTenthsComma1(penNoSixPctT)}</span></div>
                                    <div class="flex justify-between"><span>Ecken in den 5m-Raum p90 | %</span><span class="font-medium">${cornersLongIntoSixP90 != null ? fmtP90(cornersLongIntoSixP90) : '-'} | ${fmtPctTenthsComma1(sixPctT)}</span></div>
                                    <div class="flex justify-between"><span>Andere Ecken p90 | %</span><span class="font-medium">${cornersOtherP90 != null ? fmtP90(cornersOtherP90) : '-'} | ${fmtPctTenthsComma1(otherPctT)}</span></div>
                                </div>
                            `;
                        }
                    }
                } catch (e) {
                    console.warn('corner-info write failed', e);
                }

                // Zielzonen via end_y (links/zentrum/rechts) + "Top" zone by count
                const cornerTargets = cornersBase
                    .filter(e => e.end_x != null && e.end_y != null)
                    .map(e => ({ ex: Number(e.end_x), ey: Number(e.end_y) }))
                    .filter(p => Number.isFinite(p.ex) && Number.isFinite(p.ey));

                const sideBucket = (ey) => {
                    if (ey < 33.3) return 'Links';
                    if (ey < 66.6) return 'Zentrum';
                    return 'Rechts';
                };
                const targetDist = (() => {
                    const acc = { Links: 0, Zentrum: 0, Rechts: 0 };
                    for (const p of cornerTargets) acc[sideBucket(p.ey)] += 1;
                    const n = cornerTargets.length || 0;
                    if (!n) return null;
                    return {
                        left: Math.round((acc.Links / n) * 1000) / 10,
                        center: Math.round((acc.Zentrum / n) * 1000) / 10,
                        right: Math.round((acc.Rechts / n) * 1000) / 10,
                    };
                })();
                const mostCommonTarget = (() => {
                    if (!cornerTargets.length) return null;
                    const counts = new Map();
                    for (const p of cornerTargets) {
                        const k = sideBucket(p.ey);
                        counts.set(k, (counts.get(k) || 0) + 1);
                    }
                    let best = null;
                    for (const [k, v] of counts.entries()) {
                        if (!best || v > best.v) best = { k, v };
                    }
                    return best;
                })();

                // Second phase after corner: within 10s any shot / box touch
                const cornerSecondPhase = (() => {
                    const WINDOW_SEC = 10;
                    const sel = (eventDataset || []).filter(e => matchIds.has(e.match_id));
                    if (!sel.length || !corners.length) return { shots: 0, boxTouches: 0, rateShot: null };
                    const periodOrder = new Map([
                        ['FirstHalf', 0],
                        ['SecondHalf', 2700],
                        ['FirstPeriodOfExtraTime', 5400],
                        ['SecondPeriodOfExtraTime', 6300],
                        ['PenaltyShootout', 7200],
                    ]);
                    const absSec = (e) => {
                        const off = periodOrder.get(e.period) ?? 0;
                        return off + (Number(e.minute || 0) * 60) + Number(e.second || 0);
                    };
                    const comparator = (a, b) => {
                        const pa = periodOrder.has(a.period) ? periodOrder.get(a.period) : 999999;
                        const pb = periodOrder.has(b.period) ? periodOrder.get(b.period) : 999999;
                        if (pa !== pb) return pa - pb;
                        const ma = Number(a.minute || 0);
                        const mb = Number(b.minute || 0);
                        if (ma !== mb) return ma - mb;
                        const sa = Number(a.second || 0);
                        const sb = Number(b.second || 0);
                        if (sa !== sb) return sa - sb;
                        const ea = Number(a.eventId || 0);
                        const eb = Number(b.eventId || 0);
                        if (ea !== eb) return ea - eb;
                        return Number(a.id || 0) - Number(b.id || 0);
                    };
                    const shotTypes = new Set(['Shot', 'Goal', 'MissedShots', 'SavedShot']);
                    const boxStartX = 100 - (16.5 / 105) * 100;

                    const byMatch = new Map();
                    for (const e of sel) {
                        const mid = String(e.match_id ?? '');
                        if (!mid) continue;
                        if (!byMatch.has(mid)) byMatch.set(mid, []);
                        byMatch.get(mid).push(e);
                    }

                    let shots = 0;
                    let boxTouches = 0;

                    for (const rows of byMatch.values()) {
                        rows.sort(comparator);
                        for (let i = 0; i < rows.length; i++) {
                            const e = rows[i];
                            if (!e || e.team !== currentTeam) continue;
                            if (e.is_corner !== true) continue;
                            const t0 = absSec(e);
                            let gotShot = false;
                            let gotBoxTouch = false;
                            for (let j = i + 1; j < rows.length; j++) {
                                const n = rows[j];
                                if (!n) continue;
                                const dt = absSec(n) - t0;
                                if (dt > WINDOW_SEC) break;
                                if (n.team !== currentTeam) continue;
                                if (!gotShot && shotTypes.has(n.event_type)) gotShot = true;
                                if (!gotBoxTouch && n.event_type === 'BallTouch' && n.x_coord != null && Number(n.x_coord) >= boxStartX) gotBoxTouch = true;
                                if (gotShot && gotBoxTouch) break;
                            }
                            if (gotShot) shots += 1;
                            if (gotBoxTouch) boxTouches += 1;
                        }
                    }

                    const rateShot = corners.length ? Math.round((shots / corners.length) * 1000) / 10 : null;
                    return { shots, boxTouches, rateShot };
                })();

                // Ballbesitz sichern: next controlled on-ball action after corner is ours
                const cornerPossession = (() => {
                    const sel = (eventDataset || []).filter(e => matchIds.has(e.match_id));
                    if (!sel.length || !corners.length) return { kept: 0, lost: 0, keptPct: null };
                    const periodOrder = new Map([
                        ['FirstHalf', 0],
                        ['SecondHalf', 2700],
                        ['FirstPeriodOfExtraTime', 5400],
                        ['SecondPeriodOfExtraTime', 6300],
                        ['PenaltyShootout', 7200],
                    ]);
                    const comparator = (a, b) => {
                        const pa = periodOrder.has(a.period) ? periodOrder.get(a.period) : 999999;
                        const pb = periodOrder.has(b.period) ? periodOrder.get(b.period) : 999999;
                        if (pa !== pb) return pa - pb;
                        const ma = Number(a.minute || 0);
                        const mb = Number(b.minute || 0);
                        if (ma !== mb) return ma - mb;
                        const sa = Number(a.second || 0);
                        const sb = Number(b.second || 0);
                        if (sa !== sb) return sa - sb;
                        const ea = Number(a.eventId || 0);
                        const eb = Number(b.eventId || 0);
                        if (ea !== eb) return ea - eb;
                        return Number(a.id || 0) - Number(b.id || 0);
                    };

                    const controlled = new Set(['Pass', 'Carry', 'TakeOn', 'BallTouch', 'Shot', 'Goal', 'MissedShots', 'SavedShot']);

                    const byMatch = new Map();
                    for (const e of sel) {
                        const mid = String(e.match_id ?? '');
                        if (!mid) continue;
                        if (!byMatch.has(mid)) byMatch.set(mid, []);
                        byMatch.get(mid).push(e);
                    }

                    let kept = 0;
                    let lost = 0;

                    for (const rows of byMatch.values()) {
                        rows.sort(comparator);
                        for (let i = 0; i < rows.length; i++) {
                            const e = rows[i];
                            if (!e || e.team !== currentTeam) continue;
                            if (e.is_corner !== true) continue;
                            let nextTeam = null;
                            for (let j = i + 1; j < rows.length; j++) {
                                const n = rows[j];
                                if (!n || !n.team) continue;
                                if (!controlled.has(n.event_type)) continue;
                                nextTeam = n.team;
                                break;
                            }
                            if (!nextTeam) continue;
                            if (nextTeam === currentTeam) kept += 1;
                            else lost += 1;
                        }
                    }
                    const denom = kept + lost;
                    const keptPct = denom ? Math.round((kept / denom) * 1000) / 10 : null;
                    return { kept, lost, keptPct };
                })();

                // Schützen: Top 3 Ausführer
                const topTakers = (() => {
                    const acc = new Map();
                    for (const e of corners) {
                        const nm = e.player_name || e.player || null;
                        if (!nm) continue;
                        acc.set(nm, (acc.get(nm) || 0) + 1);
                    }
                    return [...acc.entries()]
                        .map(([name, n]) => ({ name, n }))
                        .sort((a, b) => b.n - a.n)
                        .slice(0, 3);
                })();

                const takersHtml = (() => {
                    if (!topTakers.length) return `<div class="text-xs text-gray-500">Keine Daten</div>`;
                    return topTakers.map((t, idx) => {
                        const mins = minutesByPlayerName.get(t.name) || 0;
                        const p90v = mins ? Math.round((t.n / mins) * 90 * 10) / 10 : null;
                        return `<div>${idx + 1}. <span class="font-medium">${t.name}</span> (${t.n}${p90v != null ? ` | ${fmtP90(p90v)} p90` : ''})</div>`;
                    }).join('');
                })();

                infoAufbau.innerHTML = `
                    <div>
                        <div class="grid grid-cols-3 gap-2">
                            <button type="button" data-corner-tab="eckball" class="${tabClass('eckball')}">Eckball</button>
                            <button type="button" data-corner-tab="einwurf" class="${tabClass('einwurf')}">Einwurf</button>
                            <button type="button" data-corner-tab="freistoss" class="${tabClass('freistoss')}">Freistoß</button>
                        </div>

                        <div data-corner-panel="volumen" class="${panelClass('volumen')}">
                            <div class="text-[11px] leading-5 text-gray-800 space-y-1">
                                <div class="flex justify-between"><span>Ecken p90</span><span class="font-medium">${fmtP90(per90(corners.length))}</span></div>
                                <div class="flex justify-between"><span>Ecken (N)</span><span class="font-medium">${corners.length || 0}</span></div>
                                <div class="flex justify-between"><span>Erfolgsquote</span><span class="font-medium">${cornersSuccPct != null ? `${cornersSuccPct.toFixed(1)}%` : '-'}</span></div>
                            </div>
                        </div>

                        <div data-corner-panel="ausfuehrung" class="${panelClass('ausfuehrung')}">
                            <div class="text-[11px] leading-5 text-gray-800 space-y-1">
                                <div class="flex justify-between"><span>Kurz ausgespielt (Proxy)</span><span class="font-medium">${shortCornersPct != null ? `${shortCornersPct.toFixed(1)}%` : '-'}</span></div>
                                <div class="flex justify-between"><span>Ecken in die Box (N)</span><span class="font-medium">${cornerIntoBox.length || 0}</span></div>
                                <div class="flex justify-between"><span>Anteil Ecken in Box</span><span class="font-medium">${cornerIntoBoxPct != null ? `${cornerIntoBoxPct.toFixed(1)}%` : '-'}</span></div>
                            </div>
                        </div>

                        <div data-corner-panel="zielzonen" class="${panelClass('zielzonen')}">
                            <div class="text-[11px] leading-5 text-gray-800 space-y-1">
                                <div class="flex justify-between"><span>Endpunkte (L | Z | R)</span><span class="font-medium">${targetDist != null ? `${targetDist.left.toFixed(1)}% | ${targetDist.center.toFixed(1)}% | ${targetDist.right.toFixed(1)}%` : '-'}</span></div>
                                <div class="flex justify-between"><span>Häufigste Zielseite</span><span class="font-medium">${mostCommonTarget != null ? `${mostCommonTarget.k} (${mostCommonTarget.v})` : '-'}</span></div>
                                <div class="flex justify-between"><span>Endpunkte mit Koordinaten (N)</span><span class="font-medium">${cornerTargets.length || 0}</span></div>
                            </div>
                        </div>

                        <div data-corner-panel="second-phase" class="${panelClass('second-phase')}">
                            <div class="text-[11px] leading-5 text-gray-800 space-y-1">
                                <div class="text-xs text-gray-600">Innerhalb 10s nach Ecke (heuristisch)</div>
                                <div class="flex justify-between"><span>Ecken → Schuss (N)</span><span class="font-medium">${cornerSecondPhase.shots || 0}</span></div>
                                <div class="flex justify-between"><span>Ecken → Box Touch (N)</span><span class="font-medium">${cornerSecondPhase.boxTouches || 0}</span></div>
                                <div class="flex justify-between"><span>Corner→Shot Rate</span><span class="font-medium">${cornerSecondPhase.rateShot != null ? `${cornerSecondPhase.rateShot.toFixed(1)}%` : '-'}</span></div>
                            </div>
                        </div>

                        <div data-corner-panel="ballbesitz" class="${panelClass('ballbesitz')}">
                            <div class="text-[11px] leading-5 text-gray-800 space-y-1">
                                <div class="text-xs text-gray-600">Nächste kontrollierte Aktion nach Ecke</div>
                                <div class="flex justify-between"><span>Ballbesitz gesichert (N)</span><span class="font-medium">${cornerPossession.kept || 0}</span></div>
                                <div class="flex justify-between"><span>Ballbesitz verloren (N)</span><span class="font-medium">${cornerPossession.lost || 0}</span></div>
                                <div class="flex justify-between"><span>Gesichert (%)</span><span class="font-medium">${cornerPossession.keptPct != null ? `${cornerPossession.keptPct.toFixed(1)}%` : '-'}</span></div>
                            </div>
                        </div>

                        <div data-corner-panel="schuetzen" class="${panelClass('schuetzen')}">
                            <div class="text-[11px] leading-5 text-gray-800 space-y-1">
                                ${takersHtml}
                            </div>
                        </div>
                    </div>
                `;
            }
            if (infoKontrolle) {
                infoKontrolle.innerHTML = `
                    <div class="text-[11px] leading-5 text-gray-800 space-y-1">
                        <div class="flex justify-between"><span>Einwürfe p90</span><span class="font-medium">${fmtP90(per90(throwIns.length))}</span></div>
                        <div class="flex justify-between"><span>Einwürfe im letzten Drittel (N)</span><span class="font-medium">${throwFinalThird.length || 0}</span></div>
                        <div class="flex justify-between"><span>Anteil Einwürfe letztes Drittel</span><span class="font-medium">${throwFinalThirdPct != null ? `${throwFinalThirdPct.toFixed(1)}%` : '-'}</span></div>
                    </div>
                `;
            }
            if (infoZumTor) {
                infoZumTor.innerHTML = `
                    <div class="text-[11px] leading-5 text-gray-800 space-y-1">
                        <div class="flex justify-between"><span>Freistöße p90</span><span class="font-medium">${fmtP90(per90(freekicks.length))}</span></div>
                        <div class="flex justify-between"><span>Freistöße ins letzte Drittel (N)</span><span class="font-medium">${fkIntoFinalThird.length || 0}</span></div>
                        <div class="flex justify-between"><span>Anteil ins letzte Drittel</span><span class="font-medium">${fkIntoFinalThirdPct != null ? `${fkIntoFinalThirdPct.toFixed(1)}%` : '-'}</span></div>
                    </div>
                `;
            }
        } else {
        // Linke Seite: Spielaufbau (Tabs statt Dropdowns)
        if (infoAufbau) {
            const isActiveGroup = (activeLeftTabGroup === 'aufbau');
            const activeAufbauTab = (lastOpenAufbauTab === 'paesse' || lastOpenAufbauTab === 'grundstruktur' || lastOpenAufbauTab === 'spieltempo' || lastOpenAufbauTab === 'progressive-pässe' || lastOpenAufbauTab === 'abstöße')
                ? lastOpenAufbauTab
                : 'grundstruktur';
            lastOpenAufbauTab = activeAufbauTab;

            const tabBase = 'px-3 py-1 rounded-md text-xs font-medium border border-gray-300 bg-white text-gray-700 hover:bg-gray-50';
            const tabActive = 'bg-[#0A3F86] text-white border-[#0A3F86] hover:bg-[#0A3F86]';
            const tabClass = (key) => `${tabBase} ${(isActiveGroup && activeAufbauTab === key) ? tabActive : ''}`;
            const panelClass = (key) => `${activeAufbauTab === key ? '' : 'hidden'} mt-3`;

            const buildUpTempoInfo = (() => {
                // Build-up Tempo: m/s Richtung gegnerisches Tor innerhalb einer Aufbauphase
                // Aufbauphase (heuristisch): zusammenhängende Team-Ballbesitzfolge (Team-Wechsel trennt),
                // Start im nicht-letzten Drittel (x < 66.6), Tempo bis zum maximal erreichten x (oder Eintritt ins letzte Drittel).
                const sel = (eventDataset || []).filter(e => matchIds.has(e.match_id));
                if (!sel.length) return { tempo: null, count: 0 };

                const periodOrder = new Map([
                    ['FirstHalf', 0],
                    ['SecondHalf', 2700],
                    ['FirstPeriodOfExtraTime', 5400],
                    ['SecondPeriodOfExtraTime', 6300],
                    ['PenaltyShootout', 7200],
                ]);
                const absSec = (e) => {
                    const off = periodOrder.get(e.period) ?? 0;
                    return off + (Number(e.minute || 0) * 60) + Number(e.second || 0);
                };
                const comparator = (a, b) => {
                    const pa = periodOrder.has(a.period) ? periodOrder.get(a.period) : 999999;
                    const pb = periodOrder.has(b.period) ? periodOrder.get(b.period) : 999999;
                    if (pa !== pb) return pa - pb;
                    const ma = Number(a.minute || 0);
                    const mb = Number(b.minute || 0);
                    if (ma !== mb) return ma - mb;
                    const sa = Number(a.second || 0);
                    const sb = Number(b.second || 0);
                    if (sa !== sb) return sa - sb;
                    const ea = Number(a.eventId || 0);
                    const eb = Number(b.eventId || 0);
                    if (ea !== eb) return ea - eb;
                    return Number(a.id || 0) - Number(b.id || 0);
                };

                const ballTypes = new Set(['Pass', 'Carry', 'TakeOn', 'BallTouch']);
                const byMatch = new Map();
                for (const e of sel) {
                    const mid = String(e.match_id ?? '');
                    if (!mid) continue;
                    if (!byMatch.has(mid)) byMatch.set(mid, []);
                    byMatch.get(mid).push(e);
                }

                const speeds = [];
                let phases = 0;

                for (const rows of byMatch.values()) {
                    rows.sort(comparator);

                    let curTeam = null;
                    let startT = null;
                    let startX = null;
                    let maxX = null;
                    let tAtMaxX = null;
                    let active = false;

                    const flush = () => {
                        if (!active) return;
                        // only if start before last third
                        if (startX == null || startT == null || maxX == null || tAtMaxX == null) { active = false; return; }
                        if (!(startX < 66.6)) { active = false; return; }
                        const dx = Math.max(0, maxX - startX);
                        const dt = Math.max(0, tAtMaxX - startT);
                        if (dx <= 0 || dt < 1) { active = false; return; }
                        // convert 0..100 pitch length to meters (105m)
                        const meters = (dx / 100) * 105;
                        speeds.push(meters / dt);
                        phases += 1;
                        active = false;
                    };

                    for (const e of rows) {
                        if (!e || !e.team) continue;
                        const team = e.team;
                        const type = e.event_type;

                        // possession boundary approximation
                        if (curTeam === null) {
                            curTeam = team;
                        } else if (team !== curTeam) {
                            if (curTeam === currentTeam) flush();
                            curTeam = team;
                            // reset
                            active = false;
                            startT = startX = maxX = tAtMaxX = null;
                        }

                        if (team !== currentTeam) continue;
                        if (!ballTypes.has(type)) continue;
                        if (e.x_coord == null) continue;
                        const x = Number(e.x_coord);
                        if (!Number.isFinite(x)) continue;
                        const t = absSec(e);

                        // determine reached x for this event (use end_x for successful pass when present)
                        let reachedX = x;
                        if (type === 'Pass' && e.outcome === 'Successful' && e.end_x != null) {
                            const ex = Number(e.end_x);
                            if (Number.isFinite(ex)) reachedX = Math.max(reachedX, ex);
                        }

                        if (!active) {
                            active = true;
                            startT = t;
                            startX = x;
                            maxX = reachedX;
                            tAtMaxX = t;
                        } else {
                            if (reachedX > maxX) {
                                maxX = reachedX;
                                tAtMaxX = t;
                            }
                        }

                        // stop tracking once we reached final third
                        if (maxX != null && maxX >= 66.6) {
                            flush();
                            // reset for potential new phase in same possession
                            active = false;
                            startT = startX = maxX = tAtMaxX = null;
                        }
                    }

                    if (curTeam === currentTeam) flush();
                }

                if (!speeds.length) return { tempo: null, count: 0 };
                const avg = speeds.reduce((a, b) => a + b, 0) / speeds.length;
                return { tempo: Math.round(avg * 100) / 100, count: phases };
            })();

            const ballWinToShotInfo = (() => {
                // Zeit von Ballbesitzbeginn (Ballgewinn inkl. Einwurf/Abstoß) -> Abschlussaktion
                // Definition Ballgewinn: Start eines neuen eigenen Ballbesitz-Segments.
                // Heuristik: Ballbesitz-Team wechselt erst, wenn ein Team eine kontrollierte Ballaktion ausführt
                // (sonst würden defensive Aktionen wie Tackles/Blocks die Possession künstlich oft “resetten”).
                const sel = (eventDataset || []).filter(e => matchIds.has(e.match_id));
                if (!sel.length) return { avgSec: null, count: 0 };

                const periodOrder = new Map([
                    ['FirstHalf', 0],
                    ['SecondHalf', 2700],
                    ['FirstPeriodOfExtraTime', 5400],
                    ['SecondPeriodOfExtraTime', 6300],
                    ['PenaltyShootout', 7200],
                ]);
                const absSec = (e) => {
                    const off = periodOrder.get(e.period) ?? 0;
                    return off + (Number(e.minute || 0) * 60) + Number(e.second || 0);
                };
                const comparator = (a, b) => {
                    const pa = periodOrder.has(a.period) ? periodOrder.get(a.period) : 999999;
                    const pb = periodOrder.has(b.period) ? periodOrder.get(b.period) : 999999;
                    if (pa !== pb) return pa - pb;
                    const ma = Number(a.minute || 0);
                    const mb = Number(b.minute || 0);
                    if (ma !== mb) return ma - mb;
                    const sa = Number(a.second || 0);
                    const sb = Number(b.second || 0);
                    if (sa !== sb) return sa - sb;
                    const ea = Number(a.eventId || 0);
                    const eb = Number(b.eventId || 0);
                    if (ea !== eb) return ea - eb;
                    return Number(a.id || 0) - Number(b.id || 0);
                };

                const inPossessionEventTypes = new Set(['Pass', 'Carry', 'TakeOn', 'BallTouch', 'Shot', 'Goal', 'MissedShots', 'SavedShot']);
                const shotTypes = new Set(['Shot', 'Goal', 'MissedShots', 'SavedShot']);

                const byMatch = new Map();
                for (const e of sel) {
                    const mid = String(e.match_id ?? '');
                    if (!mid) continue;
                    if (!byMatch.has(mid)) byMatch.set(mid, []);
                    byMatch.get(mid).push(e);
                }

                const dts = [];

                for (const rows of byMatch.values()) {
                    rows.sort(comparator);

                    let possTeam = null;
                    let possStartT = null;
                    let countedThisPoss = false; // only first shot per possession segment

                    for (const e of rows) {
                        if (!e || !e.team) continue;

                        const type = e.event_type;
                        if (!inPossessionEventTypes.has(type)) continue;

                        const team = e.team;
                        const t = absSec(e);

                        if (possTeam === null || team !== possTeam) {
                            possTeam = team;
                            possStartT = t;
                            countedThisPoss = false;
                        }

                        if (possTeam !== currentTeam) continue;
                        if (countedThisPoss) continue;

                        if (shotTypes.has(type)) {
                            const dt = possStartT != null ? (t - possStartT) : null;
                            if (dt != null && Number.isFinite(dt) && dt >= 0) dts.push(dt);
                            countedThisPoss = true;
                        }
                    }
                }

                if (!dts.length) return { avgSec: null, count: 0 };
                const avg = dts.reduce((a, b) => a + b, 0) / dts.length;
                return { avgSec: Math.round(avg * 10) / 10, count: dts.length };
            })();

            const topFormationInfo = getMostUsedStartingFormation(currentTeam, currentGameCount);

            infoAufbau.innerHTML = `
                <div>
                    <div class="grid grid-cols-3 gap-2">
                        <button type="button" data-aufbau-tab="grundstruktur" class="${tabClass('grundstruktur')}">Grundstruktur</button>
                        <button type="button" data-aufbau-tab="paesse" class="${tabClass('paesse')}">Pässe</button>
                        <button type="button" data-aufbau-tab="spieltempo" class="${tabClass('spieltempo')}">Spieltempo</button>
                        <button type="button" data-aufbau-tab="progressive-pässe" class="${tabClass('progressive-pässe')}">Progressive Pässe</button>
                        <button type="button" data-aufbau-tab="abstöße" class="${tabClass('abstöße')}">Abstöße</button>
                    </div>

                    <div data-aufbau-panel="paesse" class="${panelClass('paesse')}">
                        <div class="space-y-1 text-[11px] leading-5 max-h-72 overflow-y-auto pr-1">
                            <div class="flex justify-between"><span>Gespielte Pässe p90 | davon erfolgreich</span><span class="font-medium">${fmtP90(passesPer90)} | ${fmtP90(passesSuccPer90)}</span></div>
                            <div class="flex justify-between"><span>Pässe aus dem 1. Drittel p90 | davon erfolgreich</span><span class="font-medium">${fmtP90(firstThirdPer90)} | ${fmtP90(firstThirdSuccPer90)}</span></div>
                            <div class="flex justify-between"><span>Pässe aus dem 2. Drittel p90 | davon erfolgreich</span><span class="font-medium">${fmtP90(secondThirdPer90)} | ${fmtP90(secondThirdSuccPer90)}</span></div>
                            <div class="flex justify-between"><span>Ø Pässe bis Ballverlust</span><span class="font-medium">${avgPassesPerPoss != null ? avgPassesPerPoss : '-'}</span></div>
                            <div class="flex justify-between"><span>PPDA</span><span class="font-medium">${ppdaValue != null ? ppdaValue : '-'}</span></div>
                        </div>
                    </div>

                    <div data-aufbau-panel="spieltempo" class="${panelClass('spieltempo')}">
                        <div class="space-y-1 text-[11px] leading-5 max-h-72 overflow-y-auto pr-1">
                            <div class="flex justify-between"><span>Build-up Tempo (m/s)</span><span class="font-medium">${buildUpTempoInfo.tempo != null ? buildUpTempoInfo.tempo.toFixed(2) : '-'}</span></div>
                            <div class="flex justify-between"><span>Build-up Phasen (N)</span><span class="font-medium">${buildUpTempoInfo.count || 0}</span></div>
                            <div class="flex justify-between"><span>Ballgewinn → Abschluss (Ø Sek.)</span><span class="font-medium">${ballWinToShotInfo.avgSec != null ? ballWinToShotInfo.avgSec.toFixed(1) : '-'}</span></div>
                            <div class="flex justify-between"><span>Ballgewinn→Abschluss Sequenzen (N)</span><span class="font-medium">${ballWinToShotInfo.count || 0}</span></div>
                        </div>
                    </div>

                    <div data-aufbau-panel="grundstruktur" class="${panelClass('grundstruktur')}">
                        <div class="space-y-1 text-[11px] leading-5 max-h-72 overflow-y-auto pr-1">
                            <div class="flex justify-between"><span>Ø Teamhöhe im Ballbesitz</span><span class="font-medium">${structureHeight != null ? structureHeight : '-'}</span></div>
                            <div class="flex justify-between"><span>Ø Teambreite (Streuung)</span><span class="font-medium">${structureWidth != null ? structureWidth : '-'}</span></div>
                            <div class="flex justify-between"><span>Häufigst verwendete Aufstellung</span><span class="font-medium">${topFormationInfo && topFormationInfo.formation ? `${topFormationInfo.formation} (${topFormationInfo.count}/${topFormationInfo.matchesWithFormation})` : '-'}</span></div>
                        </div>
                    </div>

                    <div data-aufbau-panel="progressive-pässe" class="${panelClass('progressive-pässe')}">
                        <div id="pp-stats" class="text-xs space-y-1 text-gray-700">
                            <div class="flex justify-between"><span>Progressive Pässe p90:</span><span class="font-medium">${fmtP90(Math.round((totalProg / gamesCount) * 10) / 10)}</span></div>
                            <div class="flex justify-between"><span>Ø Vorwärtsgewinn:</span><span class="font-medium">${avgProgGain} m</span></div>
                            <div class="flex justify-between"><span>Meisten Pässe aus Zone:</span><span class="font-medium">${maxStart.zone} (${fmtP90(Math.round((maxStart.count / gamesCount) * 10) / 10)})</span></div>
                            <div class="flex justify-between"><span>Meisten Pässe in Zone:</span><span class="font-medium">${maxEnd.zone} (${fmtP90(Math.round((maxEnd.count / gamesCount) * 10) / 10)})</span></div>
                            <div class="flex justify-between"><span>Erfolgreich p90:</span><span class="font-medium">${fmtP90(Math.round((succProg / gamesCount) * 10) / 10)}</span></div>
                            <div class="flex justify-between"><span>Nicht erfolgreich p90:</span><span class="font-medium">${fmtP90(Math.round((failProg / gamesCount) * 10) / 10)}</span></div>
                        </div>
                    </div>

                    <div data-aufbau-panel="abstöße" class="${panelClass('abstöße')}">
                        <div class="text-xs text-gray-600">Ø Abstoßdistanz (m)</div>
                        <div class="relative w-full pt-4">
                            <div class="w-full bg-gray-200 rounded-full h-1.5"></div>
                            <div class="absolute top-1/2 h-4 w-4 bg-[#0A3F86] rounded-full border-2 border-white shadow -translate-y-1/2" style="left: ${markerPosition}%;">
                                <div class="absolute -top-6 left-1/2 -translate-x-1/2 text-xs font-bold text-white bg-[#0A3F86] px-1.5 py-0.5 rounded-md">${avgGoalKickDistance}m</div>
                            </div>
                            <div class="flex justify-between text-[10px] text-gray-500 mt-1">
                                <span>0</span><span>15</span><span>30</span><span>45</span><span>60+</span>
                            </div>
                        </div>
                        <div id="gk-stats" class="mt-2 text-xs space-y-1 text-gray-700"></div>
                    </div>
                </div>
            `;
        }

        if (infoKontrolle) {
            const isActiveGroup = (activeLeftTabGroup === 'kontrolle');
            const activeKontrolleTab = (lastOpenKontrolleTab === 'ballbesitz' || lastOpenKontrolleTab === 'fieldtilt' || lastOpenKontrolleTab === 'build-up-attack' || lastOpenKontrolleTab === 'switch-rate')
                ? lastOpenKontrolleTab
                : 'ballbesitz';
            lastOpenKontrolleTab = activeKontrolleTab;

            const tabBase = 'px-3 py-1 rounded-md text-xs font-medium border border-gray-300 bg-white text-gray-700 hover:bg-gray-50';
            const tabActive = 'bg-[#0A3F86] text-white border-[#0A3F86] hover:bg-[#0A3F86]';
            const tabClass = (key) => `${tabBase} ${(isActiveGroup && activeKontrolleTab === key) ? tabActive : ''}`;
            const panelClass = (key) => `${activeKontrolleTab === key ? '' : 'hidden'} mt-3`;

            const switchRateInfo = (() => {
                // Spielverlagerung: Pass von linker Seite -> rechte Seite (oder umgekehrt)
                // heuristisch: y startet in [0..33.3) und endet in [66.6..100] oder vice versa
                const passes = teamEvents.filter(e => e.event_type === 'Pass' && e.y_coord != null && e.end_y != null);
                const isLeft = (y) => Number(y) < 33.3;
                const isRight = (y) => Number(y) >= 66.6;
                const switches = passes.filter(p => {
                    const ys = Number(p.y_coord);
                    const ye = Number(p.end_y);
                    if (!Number.isFinite(ys) || !Number.isFinite(ye)) return false;
                    return (isLeft(ys) && isRight(ye)) || (isRight(ys) && isLeft(ye));
                });
                const succ = switches.filter(s => s.outcome === 'Successful');
                const per90 = gamesCount ? Math.round((switches.length / gamesCount) * 10) / 10 : null;
                const succPct = switches.length ? (succ.length / switches.length) * 100 : null;
                return {
                    count: switches.length,
                    per90,
                    succCount: succ.length,
                    succPct,
                };
            })();

            infoKontrolle.innerHTML = `
                <div>
                    <div class="grid grid-cols-3 gap-2">
                        <button type="button" data-kontrolle-tab="ballbesitz" class="${tabClass('ballbesitz')}">Ballbesitz</button>
                        <button type="button" data-kontrolle-tab="fieldtilt" class="${tabClass('fieldtilt')}">Field Tilt</button>
                        <button type="button" data-kontrolle-tab="build-up-attack" class="${tabClass('build-up-attack')}">Build-up Attack</button>
                        <button type="button" data-kontrolle-tab="switch-rate" class="${tabClass('switch-rate')}">Switch Rate</button>
                    </div>

                    <div data-kontrolle-panel="ballbesitz" class="${panelClass('ballbesitz')}">
                        <div class="text-[11px] leading-5 text-gray-800 space-y-1">
                            <div class="flex justify-between"><span>Ballbesitz-Minuten p90</span><span class="font-medium">${possessionMinPer90 != null ? fmtP90(possessionMinPer90) : '-'}</span></div>
                            <div class="flex justify-between"><span>Ballbesitz</span><span class="font-medium">${possessionPct != null ? `${possessionPct.toFixed(1)}%` : '-'}</span></div>
                            <div class="flex justify-between"><span>Ø Passfolge (bis Ballverlust)</span><span class="font-medium">${avgPassSequenceLen != null ? fmtP90(avgPassSequenceLen) : '-'}</span></div>
                        </div>
                    </div>

                    <div data-kontrolle-panel="fieldtilt" class="${panelClass('fieldtilt')}">
                        <div class="text-[11px] leading-5 text-gray-800 space-y-1">
                            <div class="flex justify-between"><span>Aktionen im letzten Drittel p90 | Gegner</span><span class="font-medium">${fieldTiltTeamPer90 != null ? fmtP90(fieldTiltTeamPer90) : '-'} | ${fieldTiltOppPer90 != null ? fmtP90(fieldTiltOppPer90) : '-'}</span></div>
                            <div class="flex justify-between"><span>Field Tilt</span><span class="font-medium">${fieldTiltPct != null ? `${fieldTiltPct.toFixed(1)}%` : '-'}</span></div>
                        </div>
                    </div>

                    <div data-kontrolle-panel="build-up-attack" class="${panelClass('build-up-attack')}">
                        <div class="text-[11px] leading-5 text-gray-800 space-y-1">
                            <div class="text-xs text-gray-600">Sequenzen mit ≥10 Pässen, Ende Schuss oder Ballkontakt im Strafraum</div>
                            <div class="flex justify-between"><span>Build-up Attacks p90</span><span class="font-medium">${fmtP90(buildUpAttack.per90)}</span></div>
                        </div>
                    </div>

                    <div data-kontrolle-panel="switch-rate" class="${panelClass('switch-rate')}">
                        <div class="text-[11px] leading-5 text-gray-800 space-y-1">
                            <div class="flex justify-between"><span>Spielverlagerungen p90</span><span class="font-medium">${switchRateInfo.per90 != null ? fmtP90(switchRateInfo.per90) : '-'}</span></div>
                            <div class="flex justify-between"><span>Erfolgreich (N)</span><span class="font-medium">${switchRateInfo.succCount || 0}</span></div>
                            <div class="flex justify-between"><span>Erfolgsquote</span><span class="font-medium">${switchRateInfo.succPct != null ? `${switchRateInfo.succPct.toFixed(1)}%` : '-'}</span></div>
                        </div>
                    </div>
                </div>
            `;
        }

        if (infoZumTor) {
            const isActiveGroup = (activeLeftTabGroup === 'zumtor');
            const activeZumTorTab = (lastOpenZumTorTab === 'angriffsseite' || lastOpenZumTorTab === 'abschluesse' || lastOpenZumTorTab === 'flanken')
                ? lastOpenZumTorTab
                : 'angriffsseite';
            lastOpenZumTorTab = activeZumTorTab;

            const tabBase = 'px-3 py-1 rounded-md text-xs font-medium border border-gray-300 bg-white text-gray-700 hover:bg-gray-50';
            const tabActive = 'bg-[#0A3F86] text-white border-[#0A3F86] hover:bg-[#0A3F86]';
            const tabClass = (key) => `${tabBase} ${(isActiveGroup && activeZumTorTab === key) ? tabActive : ''}`;
            const panelClass = (key) => `${activeZumTorTab === key ? '' : 'hidden'} mt-3`;

            infoZumTor.innerHTML = `
                <div id="info-content-zumtor">
                    <div class="grid grid-cols-3 gap-2">
                        <button type="button" data-zumtor-tab="angriffsseite" class="${tabClass('angriffsseite')}">Angriffsseite</button>
                        <button type="button" data-zumtor-tab="abschluesse" class="${tabClass('abschluesse')}">Abschlüsse</button>
                        <button type="button" data-zumtor-tab="flanken" class="${tabClass('flanken')}">Flanken</button>
                    </div>

                    <div data-zumtor-panel="angriffsseite" class="${panelClass('angriffsseite')}">
                        <div class="text-[11px] leading-5 text-gray-800">
                            <div class="text-xs text-gray-600">Eintritte ins letzte Drittel (Start außerhalb)</div>
                            <div class="grid grid-cols-3 gap-2 mt-1">
                                <div><span class="text-gray-500">Links:</span> <span class="font-medium text-gray-900">${sidePctZT.left}%</span></div>
                                <div><span class="text-gray-500">Zentrum:</span> <span class="font-medium text-gray-900">${sidePctZT.center}%</span></div>
                                <div><span class="text-gray-500">Rechts:</span> <span class="font-medium text-gray-900">${sidePctZT.right}%</span></div>
                            </div>
                        </div>
                    </div>

                    <div data-zumtor-panel="abschluesse" class="${panelClass('abschluesse')}">
                        <div class="text-[11px] leading-5 text-gray-800 space-y-1">
                            <div class="flex justify-between"><span>Schüsse p90</span><span class="font-medium">${fmtP90(shotsPer90)}</span></div>
                            <div class="flex justify-between"><span>Schüsse aufs Tor p90</span><span class="font-medium">${fmtP90(shotsOnTargetPer90)}</span></div>
                            <div class="flex justify-between"><span>Tore p90</span><span class="font-medium">${fmtP90(goalsPer90)}</span></div>
                        </div>
                    </div>

                    <div data-zumtor-panel="flanken" class="${panelClass('flanken')}">
                        <div class="text-[11px] leading-5 text-gray-800 space-y-1">
                            <div class="flex justify-between"><span>Flanken p90 | davon erfolgreich</span><span class="font-medium">${fmtP90(crossesPer90)} | ${fmtP90(crossesSuccPer90)}</span></div>
                            <div class="flex justify-between"><span>Erfolgreiche Flanken</span><span class="font-medium">${crossesSuccPct}%</span></div>
                            <div class="flex justify-between"><span>Second Ball Recovery after Cross</span><span class="font-medium">${secondBallRecoveryAfterCrossPct != null ? `${secondBallRecoveryAfterCrossPct.toFixed(1)}%` : '-'}</span></div>
                        </div>
                    </div>
                </div>
            `;
        }

        }

        // Wiederherstellen: zuvor geöffnete Unterpunkte erneut öffnen; fallback auf lastOpenNestedPhase.
        const toOpen = previouslyOpenPhases.length ? previouslyOpenPhases : (lastOpenNestedPhase ? [lastOpenNestedPhase] : []);
        toOpen.forEach(phase => {
            const item = infoLinksRoot.querySelector(`.accordion-item[data-phase="${phase}"]`);
            if (item) item.classList.add('open');
        });

        // Top-Level sind statische Überschriften; kein Auto-Open mehr nötig
        
        // Analyse "Gegen den Ball" (Rechts)
        const recoveries = teamEvents.filter(e => ((e.event_type === 'Tackle' && e.outcome === 'Successful') || e.event_type === 'Interception' || e.event_type === 'BallRecovery'));
        const highRecoveries = recoveries.filter(r => r.x_coord >= 66.6).length;
        
        // Rechtes Panel: Individualtaktik als Tabs (Buttons)

        const ballmagnetenContentHtml = `
            <div class="py-2 space-y-0.5 text-xs text-gray-800">
                ${(() => {
                    if (!top5Recv.length) return `<div class=\"text-xs text-gray-500\">Keine Daten</div>`;
                    const denom = passesAll.length || 0;
                    const lines = top5Recv.map((r, idx) => {
                        const mins = minutesByPlayerName.get(r.fullName) || 0;
                        const p90 = mins ? Math.round((r.count / mins) * 90) : '-';
                        const pct = denom ? Math.round((r.count / denom) * 100) : '-';
                        return `<div>${idx+1}. <span class=\"font-medium\">${r.name}</span> (${p90} | ${pct}%)</div>`;
                    }).join('');
                    return lines;
                })()}
            </div>
        `;
        
        // Progressoren: gleiche Basis wie Mannschaftstaktik-Progressive Pässe,
        // aber auf Spieler heruntergebrochen
        const progByPlayerName = new Map();
        progressivePasses.forEach(p => {
            const fullName = p.player_name || p.player || '';
            if (!fullName) return;
            const current = progByPlayerName.get(fullName) || { total: 0, successful: 0 };
            current.total += 1;
            if (p.outcome === 'Successful') current.successful += 1;
            progByPlayerName.set(fullName, current);
        });

        const progList = [...progByPlayerName.entries()]
            .map(([fullName, vals]) => ({
                name: fullName,
                total: vals.total,
                successful: vals.successful
            }))
            .sort((a, b) => b.total - a.total)
            .slice(0, 5)
            .map((p, idx) => {
                const mins = minutesByPlayerName.get(p.name) || 0;
                const p90 = mins ? Math.round((p.total / mins) * 90) : '-';
                const succRate = p.total ? Math.round((p.successful / p.total) * 100) : '-';
                const xtSum = xtByPlayerName.get(p.name) || 0;
                const xtP90 = mins ? (Math.round(((xtSum / mins) * 90) * 100) / 100) : '-';
                return { rank: idx + 1, shortName: getLastName(p.name), fullName: p.name, total: p.total, p90, succRate, xtP90 };
            });

        const progressorenContentHtml = `
            <div class="py-2 space-y-0.5 text-xs text-gray-800">
                ${(() => {
                    if (!progList.length) return `<div class="text-xs text-gray-500">Keine Daten</div>`;
                    return progList.map(p => `<div>${p.rank}. <span class=\"font-medium\">${p.shortName}</span> (${p.p90} prog. Pässe p90 | ${p.succRate}% | ${p.xtP90 !== '-' ? fmtP90(p.xtP90) : '-'} xT)</div>`).join('');
                })()}
            </div>
        `;

        // Vorbereiter: Key Passes p90 & xA (expected assists) p90 aus processed_data (dataset)
        // xA-Feld ist nur verfügbar, wenn es in processed_data.json vorhanden ist (z.B. xa / xA / xg_assist / expected_assists)
        const hasXAField = (dataset || [])
            .some(r => r.team === currentTeam && matchIds.has(r.match_id) && (
                r.xa != null || r.xA != null || r.xg_assist != null || r.expected_assists != null
            ));

        const creatorsByPlayer = (() => {
            const m = new Map();
            (dataset || [])
                .filter(r => r.team === currentTeam && matchIds.has(r.match_id))
                .forEach(r => {
                    const nm = r.player;
                    if (!nm) return;
                    const mins = Number(r.minutes_played || 0);
                    const kp = Number(r.key_passes || 0);
                    const xaRaw = (r.xa != null ? r.xa : (r.xA != null ? r.xA : (r.xg_assist != null ? r.xg_assist : (r.expected_assists != null ? r.expected_assists : 0))));
                    const xa = Number(xaRaw || 0);
                    const cur = m.get(nm) || { mins: 0, kp: 0, xa: 0 };
                    cur.mins += Number.isFinite(mins) ? mins : 0;
                    cur.kp += Number.isFinite(kp) ? kp : 0;
                    cur.xa += (hasXAField && Number.isFinite(xa)) ? xa : 0;
                    m.set(nm, cur);
                });
            return m;
        })();

        const creatorsList = [...creatorsByPlayer.entries()]
            .map(([fullName, vals]) => {
                const mins = vals.mins || 0;
                const kpP90 = mins ? (vals.kp / mins) * 90 : 0;
                const xaP90 = (hasXAField && mins) ? (vals.xa / mins) * 90 : null;
                return {
                    fullName,
                    shortName: getLastName(fullName),
                    kpP90: Math.round(kpP90 * 100) / 100,
                    xaP90: xaP90 == null ? null : (Math.round(xaP90 * 100) / 100),
                };
            })
            .sort((a, b) => (b.kpP90 - a.kpP90) || ((b.xaP90 || 0) - (a.xaP90 || 0)))
            .slice(0, 5)
            .map((p, idx) => ({ rank: idx + 1, ...p }));

        const vorbereiterContentHtml = `
            <div class="py-2 space-y-0.5 text-xs text-gray-800">
                ${(() => {
                    if (!creatorsList.length) return `<div class="text-xs text-gray-500">Keine Daten</div>`;
                    return creatorsList
                        .map(p => `<div>${p.rank}. <span class=\"font-medium\">${p.shortName}</span> (${fmtP90(p.kpP90)} Key-Passes p90 | ${p.xaP90 != null ? fmtP90(p.xaP90) : '-'} xA p90)</div>`)
                        .join('');
                })()}
            </div>
        `;
        
        // 1v1-Flügelspieler: Dribblings (TakeOns) in den Flügelzonen
        const takeOns = teamEvents.filter(e => e.event_type === 'TakeOn');
        const flankTakeOns = takeOns.filter(e => {
            if (e.y_coord == null) return false;
            const y = Number(e.y_coord);
            return y < 20 || y > 80; // äußere 20% links/rechts als Flügel
        });

        const takeOnByPlayer = new Map();
        flankTakeOns.forEach(e => {
            const fullName = e.player_name || e.player || '';
            if (!fullName) return;
            const current = takeOnByPlayer.get(fullName) || { total: 0, successful: 0 };
            current.total += 1;
            if (e.outcome === 'Successful') current.successful += 1;
            takeOnByPlayer.set(fullName, current);
        });

        const oneVOneList = [...takeOnByPlayer.entries()]
            .map(([fullName, vals]) => ({
                name: fullName,
                total: vals.total,
                successful: vals.successful
            }))
            .sort((a, b) => b.total - a.total)
            .slice(0, 5)
            .map((p, idx) => {
                const mins = minutesByPlayerName.get(p.name) || 0;
                const p90 = mins ? Math.round((p.total / mins) * 90) : '-';
                const succRate = p.total ? Math.round((p.successful / p.total) * 100) : '-';
                return { rank: idx + 1, shortName: getLastName(p.name), total: p.total, p90, succRate };
            });

        const oneVOneContentHtml = `
            <div class="py-2 space-y-0.5 text-xs text-gray-800">
                ${(() => {
                    if (!oneVOneList.length) return `<div class="text-xs text-gray-500">Keine Daten</div>`;
                    return oneVOneList.map(p => `<div>${p.rank}. <span class=\"font-medium\">${p.shortName}</span> (${p.total} 1v1 | ${p.p90} p90 | ${p.succRate}%)</div>`).join('');
                })()}
            </div>
        `;

        // Finisher: Spieler mit den meisten Abschlüssen und Torquote
        const shotEvents = teamEvents.filter(e => {
            const t = e.event_type;
            return t === 'Shot' || t === 'Goal' || t === 'MissedShots' || t === 'SavedShot';
        });

        const shotsByPlayer = new Map();
        shotEvents.forEach(e => {
            const fullName = e.player_name || e.player || '';
            if (!fullName) return;
            const current = shotsByPlayer.get(fullName) || { shots: 0, goals: 0 };
            current.shots += 1;
            // Tor-Erkennung: entweder explizit Goal oder isGoal == true
            if (e.event_type === 'Goal' || e.isGoal === true) current.goals += 1;
            shotsByPlayer.set(fullName, current);
        });

        const finisherList = [...shotsByPlayer.entries()]
            .map(([fullName, vals]) => ({
                name: fullName,
                shots: vals.shots,
                goals: vals.goals
            }))
            .sort((a, b) => b.shots - a.shots)
            .slice(0, 5)
            .map((p, idx) => {
                const mins = minutesByPlayerName.get(p.name) || 0;
                const shotsP90 = mins ? Math.round((p.shots / mins) * 90) : '-';
                const goalRate = p.shots ? Math.round((p.goals / p.shots) * 100) : '-';
                return {
                    rank: idx + 1,
                    shortName: getLastName(p.name),
                    shots: p.shots,
                    goals: p.goals,
                    shotsP90,
                    goalRate
                };
            });

        const finisherContentHtml = `
            <div class="py-2 space-y-0.5 text-xs text-gray-800">
                ${(() => {
                    if (!finisherList.length) return `<div class="text-xs text-gray-500">Keine Daten</div>`;
                    return finisherList.map(p => `<div>${p.rank}. <span class=\"font-medium\">${p.shortName}</span> (${p.shots} Abschl. | ${p.goals} Tore | ${p.goalRate}% Torquote)</div>`).join('');
                })()}
            </div>
        `;

        // Rechts: Individualtaktik nicht über Physisch drüber-rendern
        if (!isPhysisch) {
            const tabBtnClass = (key) => `phase-btn ${lastOpenIndividualtaktikTab === key ? 'active' : ''} px-3 py-1 rounded-md text-xs font-medium`;
            const panelClass = (key) => `${lastOpenIndividualtaktikTab === key ? '' : 'hidden'}`;

            const isCornerItk = (currentPhase === 'standards' && lastOpenCornerTab === 'eckball');
            const isThrowInItk = (currentPhase === 'standards' && lastOpenCornerTab === 'einwurf');
            const isFreekickItk = (currentPhase === 'standards' && lastOpenCornerTab === 'freistoss');
            if (isCornerItk) {
                const CORNER_TABS = ['corner-schuetze', 'corner-ziel-kurz', 'corner-ziel-lang'];
                if (!CORNER_TABS.includes(lastOpenIndividualtaktikTab)) lastOpenIndividualtaktikTab = 'corner-schuetze';

                // Corner basis: use original events for correct ordering + player names
                const own = getEventsForTeam(currentTeam, currentGameCount) || [];
                const selectedMatchIds = new Set((own || []).map(e => String(e.match_id ?? '')).filter(Boolean));
                const allForMatches = (eventDataset || []).filter(e => e && e.match_id != null && selectedMatchIds.has(String(e.match_id)));
                const cornersItk = (standardsMode === 'gegen-ball')
                    ? allForMatches.filter(e => e && String(e.team) !== String(currentTeam) && e.is_corner === true)
                    : allForMatches.filter(e => e && String(e.team) === String(currentTeam) && e.is_corner === true);

                const isShortCornerItk = (e) => {
                    const pl = Number(e?.pass_length);
                    if (Number.isFinite(pl)) return pl <= 15;
                    const ex = Number(e?.end_x);
                    if (Number.isFinite(ex)) return ex < 75;
                    return false;
                };

                const comparator = (a, b) => {
                    const periodOrder = new Map([
                        ['FirstHalf', 0],
                        ['SecondHalf', 2700],
                        ['FirstPeriodOfExtraTime', 5400],
                        ['SecondPeriodOfExtraTime', 6300],
                    ]);
                    const pa = periodOrder.has(a.period) ? periodOrder.get(a.period) : 999999;
                    const pb = periodOrder.has(b.period) ? periodOrder.get(b.period) : 999999;
                    if (pa !== pb) return pa - pb;
                    const ma = Number(a.minute || 0);
                    const mb = Number(b.minute || 0);
                    if (ma !== mb) return ma - mb;
                    const sa = Number(a.second || 0);
                    const sb = Number(b.second || 0);
                    if (sa !== sb) return sa - sb;
                    const ea = Number(a.eventId || 0);
                    const eb = Number(b.eventId || 0);
                    if (ea !== eb) return ea - eb;
                    return Number(a.id || 0) - Number(b.id || 0);
                };
                const controlled = new Set(['Pass', 'Carry', 'TakeOn', 'BallTouch', 'Shot', 'Goal', 'MissedShots', 'SavedShot']);
                const byMatch = new Map();
                for (const e of allForMatches) {
                    const mid = String(e.match_id ?? '');
                    if (!mid) continue;
                    if (!byMatch.has(mid)) byMatch.set(mid, []);
                    byMatch.get(mid).push(e);
                }
                for (const rows of byMatch.values()) rows.sort(comparator);

                const countByName = (items) => {
                    const m = new Map();
                    for (const it of items) {
                        const nm = String(it || '').trim();
                        if (!nm) continue;
                        m.set(nm, (m.get(nm) || 0) + 1);
                    }
                    return [...m.entries()].map(([name, n]) => ({ name, n })).sort((a, b) => b.n - a.n);
                };

                // Schütze / Zielspieler: Eckenseite links/rechts passend zur Canvas-Darstellung.
                // In StandardsMode 'gegen-ball' werden Eck-Koordinaten in Team-Perspektive gespiegelt.
                const needsInvCorner = (currentTeam !== baseTeam);
                const yDispFromCornerEvent = (cornerEvent) => {
                    const n0 = Number(cornerEvent?.y_coord);
                    if (!Number.isFinite(n0)) return null;
                    let y = n0;
                    if (standardsMode === 'gegen-ball') y = 100 - y;
                    if (needsInvCorner) y = 100 - y;
                    return y;
                };
                const isLeftCorner = (cornerEvent) => {
                    const yy = yDispFromCornerEvent(cornerEvent);
                    return yy != null && yy < 50;
                };
                const isRightCorner = (cornerEvent) => {
                    const yy = yDispFromCornerEvent(cornerEvent);
                    return yy != null && yy >= 50;
                };

                const takersLeft = countByName(cornersItk.filter(isLeftCorner).map(e => e.player_name || e.player || '')).slice(0, 8);
                const takersRight = countByName(cornersItk.filter(isRightCorner).map(e => e.player_name || e.player || '')).slice(0, 8);
                const takersSideHtml = (title, list) => {
                    const rows = list.length
                        ? list.map((t, i) => `<div>${i + 1}. <span class="font-medium">${t.name}</span> (${t.n})</div>`).join('')
                        : `<div class="text-xs text-gray-500">Keine Daten</div>`;
                    return `
                        <div>
                            <div class="text-[11px] font-semibold text-gray-700 mb-1">${title}</div>
                            <div class="space-y-0.5">${rows}</div>
                        </div>
                    `;
                };
                const takersHtml = (() => {
                    if (!cornersItk.length) return `<div class="text-xs text-gray-500">Keine Eckball-Daten</div>`;
                    return `
                        <div class="grid grid-cols-2 gap-3">
                            ${takersSideHtml('Ecke links', takersLeft)}
                            ${takersSideHtml('Ecke rechts', takersRight)}
                        </div>
                    `;
                })();

                // Zielspieler (nächste kontrollierte Aktion nach Ecke durch Eckenteam)
                // Split nach kurz/lang UND Ecke links/rechts.
                const targetsShortLeft = [];
                const targetsShortRight = [];
                const targetsLongLeft = [];
                const targetsLongRight = [];
                for (const c of cornersItk) {
                    const mid = String(c.match_id ?? '');
                    const rows = byMatch.get(mid);
                    if (!rows || !rows.length) continue;
                    const cid = c.id;
                    const ceid = c.eventId;
                    // IMPORTANT: eventId is not globally unique in this dataset (can be shared with a different event).
                    // If we use (id match OR eventId match), findIndex may stop early on an unrelated eventId match.
                    // => Prefer id match; only fall back to eventId if id is missing.
                    let idx = -1;
                    if (cid != null) {
                        idx = rows.findIndex(r => r && r.id === cid);
                    } else if (ceid != null) {
                        idx = rows.findIndex(r => r && r.eventId === ceid);
                    }
                    if (idx < 0) continue;
                    let target = null;
                    for (let j = idx + 1; j < rows.length; j++) {
                        const n = rows[j];
                        if (!n || !n.team) continue;
                        if (!controlled.has(n.event_type)) continue;
                        if (String(n.team) !== String(c.team)) break; // possession lost before controlled by taker team
                        target = (n.player_name || n.player || '').trim();
                        break;
                    }
                    if (!target) continue;
                    const short = isShortCornerItk(c);
                    const left = isLeftCorner(c);
                    if (short) {
                        if (left) targetsShortLeft.push(target);
                        else targetsShortRight.push(target);
                    } else {
                        if (left) targetsLongLeft.push(target);
                        else targetsLongRight.push(target);
                    }
                }
                const targetShortLeftList = countByName(targetsShortLeft).slice(0, 8);
                const targetShortRightList = countByName(targetsShortRight).slice(0, 8);
                const targetLongLeftList = countByName(targetsLongLeft).slice(0, 8);
                const targetLongRightList = countByName(targetsLongRight).slice(0, 8);

                const targetSideHtml = (title, list, emptyText) => {
                    const rows = list.length
                        ? list.map((t, i) => `<div>${i + 1}. <span class="font-medium">${t.name}</span> (${t.n})</div>`).join('')
                        : `<div class="text-xs text-gray-500">${emptyText}</div>`;
                    return `
                        <div>
                            <div class="text-[11px] font-semibold text-gray-700 mb-1">${title}</div>
                            <div class="space-y-0.5">${rows}</div>
                        </div>
                    `;
                };

                const targetsTabHtml = (leftList, rightList, emptyText) => {
                    if (!cornersItk.length) return `<div class="text-xs text-gray-500">Keine Eckball-Daten</div>`;
                    return `
                        <div class="grid grid-cols-2 gap-3">
                            ${targetSideHtml('Ecke links', leftList, emptyText)}
                            ${targetSideHtml('Ecke rechts', rightList, emptyText)}
                        </div>
                    `;
                };

                infoRechts.innerHTML = `
                    <div class="flex flex-wrap gap-2 mb-2">
                        <button class="${tabBtnClass('corner-schuetze')}" data-itk-tab="corner-schuetze">Schütze</button>
                        <button class="${tabBtnClass('corner-ziel-kurz')}" data-itk-tab="corner-ziel-kurz">Zielspieler kurz</button>
                        <button class="${tabBtnClass('corner-ziel-lang')}" data-itk-tab="corner-ziel-lang">Zielspieler lang</button>
                    </div>
                    <div class="p-1">
                        <div class="${panelClass('corner-schuetze')}" data-itk-panel="corner-schuetze">
                            <div class="py-1 text-xs text-gray-800">${takersHtml}</div>
                        </div>
                        <div class="${panelClass('corner-ziel-kurz')}" data-itk-panel="corner-ziel-kurz">
                            <div class="py-1 text-xs text-gray-800">${targetsTabHtml(targetShortLeftList, targetShortRightList, 'Keine Zielspieler erkannt')}</div>
                        </div>
                        <div class="${panelClass('corner-ziel-lang')}" data-itk-panel="corner-ziel-lang">
                            <div class="py-1 text-xs text-gray-800">${targetsTabHtml(targetLongLeftList, targetLongRightList, 'Keine Zielspieler erkannt')}</div>
                        </div>
                    </div>
                `;
                return;
            } else if (isThrowInItk) {
                // Einwurf: Einwerfer (Anzahl + erfolgreich) + Zielspieler als Buttons

                const THROWIN_TABS = ['throwin-einwerfer', 'throwin-zielspieler'];
                if (!THROWIN_TABS.includes(lastOpenIndividualtaktikTab)) lastOpenIndividualtaktikTab = 'throwin-einwerfer';

                // Basis: use original events for correct ordering + player names
                const own = getEventsForTeam(currentTeam, currentGameCount) || [];
                const selectedMatchIds = new Set((own || []).map(e => String(e.match_id ?? '')).filter(Boolean));
                const allForMatches = (eventDataset || []).filter(e => e && e.match_id != null && selectedMatchIds.has(String(e.match_id)));

                const throwInsItk = (standardsMode === 'gegen-ball')
                    ? allForMatches.filter(e => e && String(e.team) !== String(currentTeam) && e.is_throwin === true)
                    : allForMatches.filter(e => e && String(e.team) === String(currentTeam) && e.is_throwin === true);

                const comparator = (a, b) => {
                    const periodOrder = new Map([
                        ['FirstHalf', 0],
                        ['SecondHalf', 2700],
                        ['FirstPeriodOfExtraTime', 5400],
                        ['SecondPeriodOfExtraTime', 6300],
                    ]);
                    const pa = periodOrder.has(a.period) ? periodOrder.get(a.period) : 999999;
                    const pb = periodOrder.has(b.period) ? periodOrder.get(b.period) : 999999;
                    if (pa !== pb) return pa - pb;
                    const ma = Number(a.minute || 0);
                    const mb = Number(b.minute || 0);
                    if (ma !== mb) return ma - mb;
                    const sa = Number(a.second || 0);
                    const sb = Number(b.second || 0);
                    if (sa !== sb) return sa - sb;
                    const ea = Number(a.eventId || 0);
                    const eb = Number(b.eventId || 0);
                    if (ea !== eb) return ea - eb;
                    return Number(a.id || 0) - Number(b.id || 0);
                };

                const controlled = new Set(['Pass', 'Carry', 'TakeOn', 'BallTouch', 'Shot', 'Goal', 'MissedShots', 'SavedShot']);
                const byMatch = new Map();
                for (const e of allForMatches) {
                    const mid = String(e.match_id ?? '');
                    if (!mid) continue;
                    if (!byMatch.has(mid)) byMatch.set(mid, []);
                    byMatch.get(mid).push(e);
                }
                for (const rows of byMatch.values()) rows.sort(comparator);

                // Einwerfer counts
                const throwerCounts = new Map();
                for (const t of throwInsItk) {
                    const nm = String(t.player_name || t.player || '').trim();
                    if (!nm) continue;
                    const cur = throwerCounts.get(nm) || { total: 0, succ: 0 };
                    cur.total += 1;
                    if (String(t.outcome || '') === 'Successful') cur.succ += 1;
                    throwerCounts.set(nm, cur);
                }
                const throwerList = [...throwerCounts.entries()]
                    .map(([name, v]) => ({ name, total: v.total, succ: v.succ }))
                    .sort((a, b) => (b.total - a.total) || (b.succ - a.succ) || a.name.localeCompare(b.name));

                // Zielspieler: nächste kontrollierte Aktion nach Einwurf durch Einwurf-Team
                // + Erfolgsquote der darauffolgenden Aktion (Pass/Aktion erfolgreich)
                const targetStats = new Map(); // name -> { total, succ }
                for (const t of throwInsItk) {
                    const mid = String(t.match_id ?? '');
                    const rows = byMatch.get(mid);
                    if (!rows || !rows.length) continue;

                    let idx = -1;
                    if (t.id != null) idx = rows.findIndex(r => r && r.id === t.id);
                    else if (t.eventId != null) idx = rows.findIndex(r => r && r.eventId === t.eventId);
                    if (idx < 0) continue;

                    let nextAction = null;
                    for (let j = idx + 1; j < rows.length; j++) {
                        const n = rows[j];
                        if (!n || !n.team) continue;
                        if (!controlled.has(n.event_type)) continue;
                        if (String(n.team) !== String(t.team)) break;
                        nextAction = n;
                        break;
                    }

                    if (!nextAction) continue;
                    const target = String(nextAction.player_name || nextAction.player || '').trim();
                    if (!target) continue;

                    // Success heuristic for the subsequent action
                    // - If outcome exists: Successful = success
                    // - Goal / isGoal: success
                    // - Otherwise: count as success (controlled action completed by same team)
                    let isSucc = true;
                    const out = nextAction.outcome;
                    if (out != null && String(out).trim() !== '') {
                        isSucc = (String(out) === 'Successful');
                    } else if (nextAction.event_type === 'Goal' || nextAction.isGoal === true) {
                        isSucc = true;
                    }

                    const cur = targetStats.get(target) || { total: 0, succ: 0 };
                    cur.total += 1;
                    if (isSucc) cur.succ += 1;
                    targetStats.set(target, cur);
                }

                const targetList = [...targetStats.entries()]
                    .map(([name, v]) => ({ name, total: v.total, succ: v.succ }))
                    .sort((a, b) => (b.total - a.total) || (b.succ - a.succ) || a.name.localeCompare(b.name))
                    .slice(0, 12);

                const throwerRows = throwerList.length
                    ? throwerList.slice(0, 10).map((p, i) => {
                        const pct = p.total ? Math.round((p.succ / p.total) * 100) : 0;
                        return `<div>${i + 1}. <span class="font-medium">${p.name}</span> (${p.total} | ${pct}% erfolgreich)</div>`;
                    }).join('')
                    : `<div class="text-xs text-gray-500">Keine Einwürfe</div>`;

                const targetRows = targetList.length
                    ? targetList.map((t, i) => {
                        const pct = t.total ? Math.round((t.succ / t.total) * 100) : 0;
                        return `<div>${i + 1}. <span class="font-medium">${t.name}</span> (${t.total} | Folgeaktion erfolgreich ${pct}%)</div>`;
                    }).join('')
                    : `<div class="text-xs text-gray-500">Keine Zielspieler erkannt</div>`;

                infoRechts.innerHTML = `
                    <div class="flex flex-wrap gap-2 mb-2">
                        <button class="${tabBtnClass('throwin-einwerfer')}" data-itk-tab="throwin-einwerfer">Einwerfer</button>
                        <button class="${tabBtnClass('throwin-zielspieler')}" data-itk-tab="throwin-zielspieler">Zielspieler</button>
                    </div>
                    <div class="p-1">
                        <div class="${panelClass('throwin-einwerfer')}" data-itk-panel="throwin-einwerfer">
                            <div class="text-[11px] font-semibold text-gray-700 mb-1">Einwerfer</div>
                            <div class="py-1 space-y-0.5 text-xs text-gray-800">${throwerRows}</div>
                        </div>
                        <div class="${panelClass('throwin-zielspieler')}" data-itk-panel="throwin-zielspieler">
                            <div class="text-[11px] font-semibold text-gray-700 mb-2">Zielspieler</div>
                            <div class="py-1 space-y-0.5 text-xs text-gray-800">${targetRows}</div>
                        </div>
                    </div>
                `;
                return;
            } else if (isFreekickItk) {
                // Freistoß: Schützen + Zielspieler
                const FK_TABS = ['fk-schuetzen', 'fk-zielspieler'];
                if (!FK_TABS.includes(lastOpenIndividualtaktikTab)) lastOpenIndividualtaktikTab = 'fk-schuetzen';

                // Basis: use original events for correct ordering + player names
                const own = getEventsForTeam(currentTeam, currentGameCount) || [];
                const selectedMatchIds = new Set((own || []).map(e => String(e.match_id ?? '')).filter(Boolean));
                const allForMatches = (eventDataset || []).filter(e => e && e.match_id != null && selectedMatchIds.has(String(e.match_id)));

                const freekicksItk = (standardsMode === 'gegen-ball')
                    ? allForMatches.filter(e => e && String(e.team) !== String(currentTeam) && e.is_freekick === true)
                    : allForMatches.filter(e => e && String(e.team) === String(currentTeam) && e.is_freekick === true);

                const comparator = (a, b) => {
                    const periodOrder = new Map([
                        ['FirstHalf', 0],
                        ['SecondHalf', 2700],
                        ['FirstPeriodOfExtraTime', 5400],
                        ['SecondPeriodOfExtraTime', 6300],
                    ]);
                    const pa = periodOrder.has(a.period) ? periodOrder.get(a.period) : 999999;
                    const pb = periodOrder.has(b.period) ? periodOrder.get(b.period) : 999999;
                    if (pa !== pb) return pa - pb;
                    const ma = Number(a.minute || 0);
                    const mb = Number(b.minute || 0);
                    if (ma !== mb) return ma - mb;
                    const sa = Number(a.second || 0);
                    const sb = Number(b.second || 0);
                    if (sa !== sb) return sa - sb;
                    const ea = Number(a.eventId || 0);
                    const eb = Number(b.eventId || 0);
                    if (ea !== eb) return ea - eb;
                    return Number(a.id || 0) - Number(b.id || 0);
                };

                const controlled = new Set(['Pass', 'Carry', 'TakeOn', 'BallTouch', 'Shot', 'Goal', 'MissedShots', 'SavedShot']);
                const byMatch = new Map();
                for (const e of allForMatches) {
                    const mid = String(e.match_id ?? '');
                    if (!mid) continue;
                    if (!byMatch.has(mid)) byMatch.set(mid, []);
                    byMatch.get(mid).push(e);
                }
                for (const rows of byMatch.values()) rows.sort(comparator);

                // Schützen: total + % Successful
                const shooterCounts = new Map();
                for (const f of freekicksItk) {
                    const nm = String(f.player_name || f.player || '').trim();
                    if (!nm) continue;
                    const cur = shooterCounts.get(nm) || { total: 0, succ: 0 };
                    cur.total += 1;
                    if (String(f.outcome || '') === 'Successful') cur.succ += 1;
                    shooterCounts.set(nm, cur);
                }
                const shooterList = [...shooterCounts.entries()]
                    .map(([name, v]) => ({ name, total: v.total, succ: v.succ }))
                    .sort((a, b) => (b.total - a.total) || (b.succ - a.succ) || a.name.localeCompare(b.name))
                    .slice(0, 10);

                const shooterRows = shooterList.length
                    ? shooterList.map((p, i) => {
                        const pct = p.total ? Math.round((p.succ / p.total) * 100) : 0;
                        return `<div>${i + 1}. <span class="font-medium">${p.name}</span> (${p.total} | ${pct}% erfolgreich)</div>`;
                    }).join('')
                    : `<div class="text-xs text-gray-500">Keine Freistöße</div>`;

                // Zielspieler: nächste kontrollierte Aktion nach Freistoß durch Freistoß-Team + Erfolgsquote
                const targetStats = new Map();
                const isStopMarker = (n) => (n.is_freekick === true || n.is_corner === true || n.is_throwin === true ||
                    n.event_type === 'FreekickAwarded' || n.event_type === 'CornerAwarded' || n.event_type === 'ThrowInAwarded');

                for (const f of freekicksItk) {
                    const mid = String(f.match_id ?? '');
                    const rows = byMatch.get(mid);
                    if (!rows || !rows.length) continue;

                    let idx = -1;
                    if (f.id != null) idx = rows.findIndex(r => r && r.id === f.id);
                    else if (f.eventId != null) idx = rows.findIndex(r => r && r.eventId === f.eventId);
                    if (idx < 0) continue;

                    let nextAction = null;
                    for (let j = idx + 1; j < rows.length; j++) {
                        const n = rows[j];
                        if (!n || !n.team) continue;
                        if (isStopMarker(n)) break;
                        if (!controlled.has(n.event_type)) continue;
                        if (String(n.team) !== String(f.team)) break;
                        nextAction = n;
                        break;
                    }
                    if (!nextAction) continue;

                    const target = String(nextAction.player_name || nextAction.player || '').trim();
                    if (!target) continue;

                    let isSucc = true;
                    const out = nextAction.outcome;
                    if (out != null && String(out).trim() !== '') {
                        isSucc = (String(out) === 'Successful');
                    } else if (nextAction.event_type === 'Goal' || nextAction.isGoal === true) {
                        isSucc = true;
                    }

                    const cur = targetStats.get(target) || { total: 0, succ: 0 };
                    cur.total += 1;
                    if (isSucc) cur.succ += 1;
                    targetStats.set(target, cur);
                }

                const targetList = [...targetStats.entries()]
                    .map(([name, v]) => ({ name, total: v.total, succ: v.succ }))
                    .sort((a, b) => (b.total - a.total) || (b.succ - a.succ) || a.name.localeCompare(b.name))
                    .slice(0, 12);

                const targetRows = targetList.length
                    ? targetList.map((t, i) => {
                        const pct = t.total ? Math.round((t.succ / t.total) * 100) : 0;
                        return `<div>${i + 1}. <span class="font-medium">${t.name}</span> (${t.total} | Folgeaktion erfolgreich ${pct}%)</div>`;
                    }).join('')
                    : `<div class="text-xs text-gray-500">Keine Zielspieler erkannt</div>`;

                infoRechts.innerHTML = `
                    <div class="flex flex-wrap gap-2 mb-2">
                        <button class="${tabBtnClass('fk-schuetzen')}" data-itk-tab="fk-schuetzen">Schützen</button>
                        <button class="${tabBtnClass('fk-zielspieler')}" data-itk-tab="fk-zielspieler">Zielspieler</button>
                    </div>
                    <div class="p-1">
                        <div class="${panelClass('fk-schuetzen')}" data-itk-panel="fk-schuetzen">
                            <div class="py-1 space-y-0.5 text-xs text-gray-800">${shooterRows}</div>
                        </div>
                        <div class="${panelClass('fk-zielspieler')}" data-itk-panel="fk-zielspieler">
                            <div class="py-1 space-y-0.5 text-xs text-gray-800">${targetRows}</div>
                        </div>
                    </div>
                `;
                return;
            } else {
                // Leaving Eckball view: restore default tab selection if needed
                if (typeof lastOpenIndividualtaktikTab === 'string' && lastOpenIndividualtaktikTab.startsWith('corner-')) {
                    lastOpenIndividualtaktikTab = 'ballmagneten';
                }

                // Leaving Einwurf view: restore default tab selection if needed
                if (typeof lastOpenIndividualtaktikTab === 'string' && lastOpenIndividualtaktikTab.startsWith('throwin-')) {
                    lastOpenIndividualtaktikTab = 'ballmagneten';
                }

                // Leaving Freistoß view: restore default tab selection if needed
                if (typeof lastOpenIndividualtaktikTab === 'string' && lastOpenIndividualtaktikTab.startsWith('fk-')) {
                    lastOpenIndividualtaktikTab = 'ballmagneten';
                }

                // Leaving Gegen den Ball view: restore default tab selection if needed
                const GB_TABS = ['zweikaempfer', 'lufthoheit', 'antizipierer'];
                if (currentMainPhase !== 'gegen-ball' && GB_TABS.includes(lastOpenIndividualtaktikTab)) {
                    lastOpenIndividualtaktikTab = 'ballmagneten';
                }
            }

            // Gegen den Ball: Spieler-Rankings für Defensivrollen (Top 5)
            if (currentMainPhase === 'gegen-ball') {
                const GB_TABS = ['zweikaempfer', 'lufthoheit', 'antizipierer'];
                if (!GB_TABS.includes(lastOpenIndividualtaktikTab)) lastOpenIndividualtaktikTab = 'zweikaempfer';

                const safeP90 = (count, mins) => {
                    const m = Number(mins || 0);
                    return m > 0 ? Math.round((count / m) * 90) : '-';
                };

                // 1) Zweikämpfer: Tackles + Challenges inkl. Erfolgsquote
                const duelEvents = (teamEvents || [])
                    .filter(e => e && e.player_name && (e.event_type === 'Tackle' || e.event_type === 'Challenge'));
                const duelsByPlayer = new Map();
                for (const e of duelEvents) {
                    const nm = String(e.player_name || '').trim();
                    if (!nm) continue;
                    const cur = duelsByPlayer.get(nm) || { total: 0, succ: 0 };
                    cur.total += 1;
                    if (String(e.outcome || '') === 'Successful') cur.succ += 1;
                    duelsByPlayer.set(nm, cur);
                }
                const zweikaempferList = [...duelsByPlayer.entries()]
                    .map(([name, v]) => {
                        const mins = minutesByPlayerName.get(name) || 0;
                        const p90 = safeP90(v.total, mins);
                        const succ = v.total ? Math.round((v.succ / v.total) * 100) : '-';
                        return { name, shortName: getLastName(name), total: v.total, p90, succPct: succ };
                    })
                    .sort((a, b) => (b.total - a.total) || String(a.name).localeCompare(String(b.name)))
                    .slice(0, 5)
                    .map((p, idx) => ({ rank: idx + 1, ...p }));

                const zweikaempferHtml = `
                    <div class="py-2 space-y-0.5 text-xs text-gray-800">
                        ${(() => {
                            if (!zweikaempferList.length) return `<div class="text-xs text-gray-500">Keine Daten</div>`;
                            return zweikaempferList
                                .map(p => `<div>${p.rank}. <span class=\"font-medium\">${p.shortName}</span> (${p.total} | ${p.p90} p90 | ${p.succPct}% gewonnen)</div>`)
                                .join('');
                        })()}
                    </div>
                `;

                // 2) Lufthoheit: Aerials inkl. Erfolgsquote
                const aerialEvents = (teamEvents || [])
                    .filter(e => e && e.player_name && e.event_type === 'Aerial');
                const aerialByPlayer = new Map();
                for (const e of aerialEvents) {
                    const nm = String(e.player_name || '').trim();
                    if (!nm) continue;
                    const cur = aerialByPlayer.get(nm) || { total: 0, succ: 0 };
                    cur.total += 1;
                    if (String(e.outcome || '') === 'Successful') cur.succ += 1;
                    aerialByPlayer.set(nm, cur);
                }
                const lufthoheitList = [...aerialByPlayer.entries()]
                    .map(([name, v]) => {
                        const mins = minutesByPlayerName.get(name) || 0;
                        const p90 = safeP90(v.total, mins);
                        const succ = v.total ? Math.round((v.succ / v.total) * 100) : '-';
                        return { name, shortName: getLastName(name), total: v.total, p90, succPct: succ };
                    })
                    .sort((a, b) => (b.total - a.total) || String(a.name).localeCompare(String(b.name)))
                    .slice(0, 5)
                    .map((p, idx) => ({ rank: idx + 1, ...p }));

                const lufthoheitHtml = `
                    <div class="py-2 space-y-0.5 text-xs text-gray-800">
                        ${(() => {
                            if (!lufthoheitList.length) return `<div class="text-xs text-gray-500">Keine Daten</div>`;
                            return lufthoheitList
                                .map(p => `<div>${p.rank}. <span class=\"font-medium\">${p.shortName}</span> (${p.total} | ${p.p90} p90 | ${p.succPct}% gewonnen)</div>`)
                                .join('');
                        })()}
                    </div>
                `;

                // 3) Antizipierer: Interceptions + BlockedPass
                const antEvents = (teamEvents || [])
                    .filter(e => e && e.player_name && (e.event_type === 'Interception' || e.event_type === 'BlockedPass'));
                const antByPlayer = new Map();
                for (const e of antEvents) {
                    const nm = String(e.player_name || '').trim();
                    if (!nm) continue;
                    const cur = antByPlayer.get(nm) || { total: 0 };
                    cur.total += 1;
                    antByPlayer.set(nm, cur);
                }
                const antizipiererList = [...antByPlayer.entries()]
                    .map(([name, v]) => {
                        const mins = minutesByPlayerName.get(name) || 0;
                        const p90 = safeP90(v.total, mins);
                        return { name, shortName: getLastName(name), total: v.total, p90 };
                    })
                    .sort((a, b) => (b.total - a.total) || String(a.name).localeCompare(String(b.name)))
                    .slice(0, 5)
                    .map((p, idx) => ({ rank: idx + 1, ...p }));

                const antizipiererHtml = `
                    <div class="py-2 space-y-0.5 text-xs text-gray-800">
                        ${(() => {
                            if (!antizipiererList.length) return `<div class="text-xs text-gray-500">Keine Daten</div>`;
                            return antizipiererList
                                .map(p => `<div>${p.rank}. <span class=\"font-medium\">${p.shortName}</span> (${p.total} | ${p.p90} p90)</div>`)
                                .join('');
                        })()}
                    </div>
                `;

                infoRechts.innerHTML = `
                    <div class="flex flex-wrap gap-2 mb-2">
                        <button class="${tabBtnClass('zweikaempfer')}" data-itk-tab="zweikaempfer">Zweikämpfer</button>
                        <button class="${tabBtnClass('lufthoheit')}" data-itk-tab="lufthoheit">Lufthoheit</button>
                        <button class="${tabBtnClass('antizipierer')}" data-itk-tab="antizipierer">Antizipierer</button>
                    </div>
                    <div class="p-1">
                        <div class="${panelClass('zweikaempfer')}" data-itk-panel="zweikaempfer">${zweikaempferHtml}</div>
                        <div class="${panelClass('lufthoheit')}" data-itk-panel="lufthoheit">${lufthoheitHtml}</div>
                        <div class="${panelClass('antizipierer')}" data-itk-panel="antizipierer">${antizipiererHtml}</div>
                    </div>
                `;
                return;
            }

            infoRechts.innerHTML = `
                <div class="flex flex-wrap gap-2 mb-2">
                    <button class="${tabBtnClass('ballmagneten')}" data-itk-tab="ballmagneten">Ballmagneten</button>
                    <button class="${tabBtnClass('progressoren')}" data-itk-tab="progressoren">Progressoren</button>
                    <button class="${tabBtnClass('vorbereiter')}" data-itk-tab="vorbereiter">Vorbereiter</button>
                    <button class="${tabBtnClass('1v1-fluegel')}" data-itk-tab="1v1-fluegel">1v1-Flügelspieler</button>
                    <button class="${tabBtnClass('finisher')}" data-itk-tab="finisher">Finisher</button>
                </div>
                <div class="p-1">
                    <div class="${panelClass('ballmagneten')}" data-itk-panel="ballmagneten">${ballmagnetenContentHtml}</div>
                    <div class="${panelClass('progressoren')}" data-itk-panel="progressoren">${progressorenContentHtml}</div>
                    <div class="${panelClass('vorbereiter')}" data-itk-panel="vorbereiter">${vorbereiterContentHtml}</div>
                    <div class="${panelClass('1v1-fluegel')}" data-itk-panel="1v1-fluegel">${oneVOneContentHtml}</div>
                    <div class="${panelClass('finisher')}" data-itk-panel="finisher">${finisherContentHtml}</div>
                </div>
            `;
        }
    }


    // --- HAUPT-RENDER-FUNKTION ---
    let pitchVizInstance = null; // hält ggf. die PassMap-Instanz
    let lastOpenIndividualtaktikTab = 'ballmagneten';

    function applyPhysischLayout() {
        const isPhysisch = (currentPhase === 'physisch');
        const left = document.getElementById('info-links');
        const right = document.getElementById('info-rechts');
        const rightContent = document.getElementById('info-content-rechts');
        const flipCard = document.getElementById('physisch-flip-card');
        const leftBox1 = document.getElementById('left-box-1');
        const leftBox2 = document.getElementById('left-box-2');
        const leftBox3 = document.getElementById('left-box-3');

        // Right side stays visible on Physisch (player list)
        if (right) {
            right.classList.add('phase-fade');
            right.classList.remove('phase-hidden');
        }

        // Left: on Physisch show TWO equal-height boxes (1 = donuts, 2 = placeholder), hide box 3.
        if (left) left.classList.add('phase-fade');

        if (leftBox1 && leftBox2 && leftBox3) {
            [leftBox1, leftBox2, leftBox3].forEach(el => el.classList.add('phase-fade'));

            if (isPhysisch) {
                // layout container
                if (left) {
                    left.style.display = 'flex';
                    left.style.flexDirection = 'column';
                    left.style.gap = '1rem';
                }

                // show boxes 1+2
                [leftBox1, leftBox2].forEach(el => {
                    el.classList.remove('phase-hidden');
                    el.style.display = '';
                    el.style.maxHeight = 'none';
                    el.style.flex = '1 1 0';
                    el.style.minHeight = '0';
                    el.style.overflowY = 'hidden';
                });

                // Remove extra spacing from Tailwind `space-y-4` (otherwise it's gap + margin-top).
                leftBox2.style.marginTop = '0';

                // hide box 3 entirely
                leftBox3.classList.add('phase-hidden');
                leftBox3.style.display = 'none';
            } else {
                // restore defaults
                if (left) {
                    left.style.display = '';
                    left.style.flexDirection = '';
                    left.style.gap = '';
                }
                [leftBox1, leftBox2, leftBox3].forEach(el => {
                    el.classList.remove('phase-hidden');
                    el.style.display = '';
                    el.style.maxHeight = '';
                    el.style.flex = '';
                    el.style.minHeight = '';
                    el.style.overflowY = '';
                });

                // restore spacing behavior
                leftBox2.style.marginTop = '';
            }
        }

        // On Physisch: avoid nested scrolling of the whole right panel; only the player list should scroll.
        if (rightContent) {
            rightContent.style.overflowY = isPhysisch ? 'hidden' : 'auto';
        }

        if (flipCard) {
            flipCard.classList.toggle('is-flipped', isPhysisch);
        }
    }

    function syncPhysischCardHeights() {
        const topPhase = (typeof currentMainPhase === 'string' && currentMainPhase) ? currentMainPhase : currentPhase;
        const isPhysisch = (topPhase === 'physisch');

        const leftBox1 = document.getElementById('left-box-1');
        const leftBox2 = document.getElementById('left-box-2');
        const rightBox1 = document.getElementById('right-box-1');
        const rightBox2 = document.getElementById('right-box-2');

        const cTop = document.getElementById('physisch-distance-chart');
        const cBottom = document.getElementById('physisch-tempo-intense-chart');
        const centerTopCard = cTop ? cTop.closest('div.flex-1') : null;
        const centerBottomCard = cBottom ? cBottom.closest('div.flex-1') : null;

        if (!isPhysisch) {
            [leftBox1, leftBox2, rightBox1, rightBox2].forEach(el => {
                if (!el) return;
                el.style.height = '';
                // restore normal flex behavior
                if (el === leftBox1 || el === leftBox2) el.style.flex = '';
            });
            return;
        }

        const hTop = centerTopCard?.getBoundingClientRect?.().height ? Math.round(centerTopCard.getBoundingClientRect().height) : 0;
        const hBottom = centerBottomCard?.getBoundingClientRect?.().height ? Math.round(centerBottomCard.getBoundingClientRect().height) : 0;
        if (!(hTop > 0 && hBottom > 0)) return;

        // Force exact card heights on the sides to match the center chart cards.
        if (leftBox1) { leftBox1.style.height = `${hTop}px`; leftBox1.style.flex = '0 0 auto'; }
        if (leftBox2) { leftBox2.style.height = `${hBottom}px`; leftBox2.style.flex = '0 0 auto'; }
        if (rightBox1) rightBox1.style.height = `${hTop}px`;
        if (rightBox2) rightBox2.style.height = `${hBottom}px`;
    }

    function syncRightPanelHeightToPitch() {
        const leftCol = document.getElementById('info-links');
        const rightCol = document.getElementById('info-rechts');
        const actionCol = document.getElementById('action-container');
        const pitchBox = document.querySelector('.canvas-container');

        const topPhase = (typeof currentMainPhase === 'string' && currentMainPhase) ? currentMainPhase : currentPhase;
        const isPhysisch = (topPhase === 'physisch');

        // Physisch: match BOTH side columns to the center charts stack.
        if (isPhysisch && actionCol) {
            const rect = actionCol.getBoundingClientRect();
            const h = rect && rect.height ? Math.round(rect.height) : 0;
            if (h > 0) {
                if (leftCol) leftCol.style.height = `${h}px`;
                if (rightCol) rightCol.style.height = `${h}px`;
            }
            // Additionally align top/bottom card heights precisely.
            syncPhysischCardHeights();
            return;
        }

        // Default: keep the right column synced to the pitch box height.
        if (leftCol) leftCol.style.height = '';
        if (rightCol) rightCol.style.height = '';
        syncPhysischCardHeights();
        if (!rightCol || !pitchBox) return;

        const rect = pitchBox.getBoundingClientRect();
        const h = rect && rect.height ? Math.round(rect.height) : 0;
        if (h > 0) {
            rightCol.style.height = `${h}px`;
        }
    }

    function syncCenterViewForPhase() {
        const pitchView = document.getElementById('center-view-pitch');
        const fieldTiltView = document.getElementById('center-view-fieldtilt');
        const globalSwitch = document.getElementById('global-view-switch');
        const coordsDisplay = document.getElementById('coords-display');

        const isFieldTilt = (currentPhase === 'fieldtilt');
        if (pitchView) pitchView.classList.toggle('hidden', isFieldTilt);
        if (fieldTiltView) fieldTiltView.classList.toggle('hidden', !isFieldTilt);
        if (globalSwitch) globalSwitch.classList.toggle('hidden', isFieldTilt);
        if (coordsDisplay && isFieldTilt) coordsDisplay.textContent = '';
    }

    // ===== Übersicht: The Athletic Match Stats (ohne Vergleich) =====
    let _overviewMatchStatsCacheKey = null;
    let _overviewMatchStatsCacheValue = null;
    let _overviewBaselineCacheKey = null;
    let _overviewBaselineCacheValue = null;

    function setOverviewModeLayout(enabled) {
        const mainGrid = document.getElementById('main-grid');
        const overviewOnly = document.getElementById('overview-only-container');
        const regularCenter = document.getElementById('regular-center-container');
        const infoLinks = document.getElementById('info-links');
        const infoRechts = document.getElementById('info-rechts');
        if (mainGrid) mainGrid.classList.toggle('overview-mode', !!enabled);
        if (overviewOnly) {
            overviewOnly.classList.toggle('hidden', !enabled);
            overviewOnly.hidden = !enabled;
        }
        if (regularCenter) {
            regularCenter.classList.toggle('hidden', !!enabled);
            regularCenter.hidden = !!enabled;
        }
        if (infoLinks) infoLinks.hidden = !!enabled;
        if (infoRechts) infoRechts.hidden = !!enabled;
    }

    function renderOverviewBallbesitzPitch(allEvs, teamName, selectedMatchIds) {
        const canvas = document.getElementById('overview-possession-canvas');
        const legend = document.getElementById('overview-possession-legend');
        if (!canvas) return;

        const wrap = canvas.parentElement;
        const wCss = wrap ? wrap.clientWidth : 0;
        const hCss = wrap ? wrap.clientHeight : 0;
        const fallbackW = 240;
        const fallbackH = Math.round(fallbackW * (105 / 68));
        const w = Math.max(1, Math.round(wCss || fallbackW));
        const h = Math.max(1, Math.round(hCss || Math.round(w * (105 / 68)) || fallbackH));
        canvas.width = w;
        canvas.height = h;

        const ctx = canvas.getContext('2d');
        if (!ctx) return;

        const TOUCH_EVENTS = new Set(['Pass', 'Carry', 'TakeOn', 'BallTouch', 'Shot', 'Goal', 'MissedShots', 'SavedShot']);
        const clamp01Local = (v) => Math.max(0, Math.min(1, v));
        const clampInt = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

        const buildGaussianKernel1D = (radius, sigma) => {
            const size = radius * 2 + 1;
            const k = new Float32Array(size);
            const s2 = 2 * sigma * sigma;
            let sum = 0;
            for (let i = -radius; i <= radius; i++) {
                const v = Math.exp(-(i * i) / s2);
                k[i + radius] = v;
                sum += v;
            }
            if (sum > 0) {
                for (let i = 0; i < size; i++) k[i] /= sum;
            }
            return k;
        };

        const blurSeparable = (src, w, h, kernel) => {
            const r = Math.floor(kernel.length / 2);
            const tmp = new Float32Array(w * h);
            const dst = new Float32Array(w * h);

            for (let y = 0; y < h; y++) {
                const row = y * w;
                for (let x = 0; x < w; x++) {
                    let acc = 0;
                    for (let k = -r; k <= r; k++) {
                        const xx = clampInt(x + k, 0, w - 1);
                        acc += src[row + xx] * kernel[k + r];
                    }
                    tmp[row + x] = acc;
                }
            }
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    let acc = 0;
                    for (let k = -r; k <= r; k++) {
                        const yy = clampInt(y + k, 0, h - 1);
                        acc += tmp[yy * w + x] * kernel[k + r];
                    }
                    dst[y * w + x] = acc;
                }
            }
            return dst;
        };

        const drawPitchLinesPortrait = (ctx, w, h) => {
            const lineColor = (typeof LINE_COLOR !== 'undefined') ? LINE_COLOR : 'rgba(156,163,175,0.75)';
            ctx.save();
            ctx.strokeStyle = lineColor;
            ctx.lineWidth = Math.max(1, w * 0.005);
            ctx.lineCap = 'round';

            ctx.strokeRect(0, 0, w, h);
            ctx.beginPath();
            ctx.moveTo(0, h / 2);
            ctx.lineTo(w, h / 2);
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(w / 2, h / 2, w * 0.2, 0, 2 * Math.PI);
            ctx.stroke();

            ctx.fillStyle = lineColor;
            ctx.beginPath();
            ctx.arc(w / 2, h / 2, w * 0.01, 0, 2 * Math.PI);
            ctx.fill();

            const penaltyBoxH = h * (16.5 / 105);
            const penaltyBoxW = w * (40.3 / 68);
            const penaltyBoxX = (w - penaltyBoxW) / 2;
            ctx.strokeRect(penaltyBoxX, 0, penaltyBoxW, penaltyBoxH);
            ctx.strokeRect(penaltyBoxX, h - penaltyBoxH, penaltyBoxW, penaltyBoxH);

            const goalBoxH = h * (5.5 / 105);
            const goalBoxW = w * (18.32 / 68);
            const goalBoxX = (w - goalBoxW) / 2;
            ctx.strokeRect(goalBoxX, 0, goalBoxW, goalBoxH);
            ctx.strokeRect(goalBoxX, h - goalBoxH, goalBoxW, goalBoxH);

            ctx.restore();
        };

        ctx.clearRect(0, 0, w, h);
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, w, h);

        const evs = (allEvs || [])
            .filter(e => e && e.match_id != null && selectedMatchIds.has(String(e.match_id)))
            .filter(e => e.team != null && e.x_coord != null && e.y_coord != null)
            .filter(e => TOUCH_EVENTS.has(String(e.event_type || '')))
            .map(e => ({ team: String(e.team), x: Number(e.x_coord), y: Number(e.y_coord) }))
            .filter(e => Number.isFinite(e.x) && Number.isFinite(e.y));

        const gridW = 48;
        const gridH = 72;
        const teamGrid = new Float32Array(gridW * gridH);
        const oppGrid = new Float32Array(gridW * gridH);

        for (const e of evs) {
            const gx = clampInt(Math.floor((e.y / 100) * gridW), 0, gridW - 1);
            const gy = clampInt(Math.floor(((100 - e.x) / 100) * gridH), 0, gridH - 1);
            const idx = gy * gridW + gx;
            if (e.team === teamName) teamGrid[idx] += 1;
            else oppGrid[idx] += 1;
        }

        const kernel = buildGaussianKernel1D(4, 2.2);
        const teamBlur = blurSeparable(teamGrid, gridW, gridH, kernel);
        const oppBlur = blurSeparable(oppGrid, gridW, gridH, kernel);

        let maxTot = 0;
        for (let i = 0; i < teamBlur.length; i++) {
            const tot = teamBlur[i] + oppBlur[i];
            if (tot > maxTot) maxTot = tot;
        }
        maxTot = Math.max(1e-6, maxTot);

        const off = document.createElement('canvas');
        off.width = gridW;
        off.height = gridH;
        const octx = off.getContext('2d');
        const img = octx.createImageData(gridW, gridH);

        const BLUE = [10, 63, 134];
        const RED = [239, 68, 68];

        for (let gy = 0; gy < gridH; gy++) {
            for (let gx = 0; gx < gridW; gx++) {
                const i = gy * gridW + gx;
                const a = teamBlur[i];
                const b = oppBlur[i];
                const tot = a + b;
                const p = i * 4;

                if (tot <= 0) {
                    img.data[p + 0] = 255;
                    img.data[p + 1] = 255;
                    img.data[p + 2] = 255;
                    img.data[p + 3] = 0;
                    continue;
                }

                const d = (a - b) / tot;
                const mag = Math.abs(d);
                const coverage = Math.sqrt(clamp01Local(tot / maxTot));
                const alpha = clamp01Local(0.04 + 0.92 * mag * coverage);
                const col = d >= 0 ? BLUE : RED;

                img.data[p + 0] = col[0];
                img.data[p + 1] = col[1];
                img.data[p + 2] = col[2];
                img.data[p + 3] = Math.round(alpha * 255);
            }
        }

        octx.putImageData(img, 0, 0);
        ctx.save();
        ctx.imageSmoothingEnabled = true;
        ctx.drawImage(off, 0, 0, w, h);
        ctx.restore();

        drawPitchLinesPortrait(ctx, w, h);

        if (legend) {
            const teamLabel = (teamName != null && String(teamName).trim()) ? String(teamName).trim() : 'Team';
            legend.innerHTML = `
                <span class="inline-flex items-center gap-2">
                    <span class="inline-block w-2.5 h-2.5 rounded-sm" style="background:#0A3F86"></span>
                    <span>${teamLabel}</span>
                    <span class="inline-block w-2.5 h-2.5 rounded-sm ml-3" style="background:#ef4444"></span>
                    <span>Gegner</span>
                </span>
            `;
        }
    }

    function renderOverviewPossessionBar(teamName, selectedMatchIds) {
        const bar = document.getElementById('overview-possession-bar');
        const away = document.getElementById('overview-possession-bar-away');
        const home = document.getElementById('overview-possession-bar-home');
        const awayLabel = document.getElementById('overview-possession-bar-away-label');
        const homeLabel = document.getElementById('overview-possession-bar-home-label');
        if (!bar || !away || !home) return;

        const pct = (() => {
            const rows = (dataset || [])
                .filter(r => r && r.team === teamName && selectedMatchIds.has(String(r.match_id ?? '')) && r.ballbesitz != null);

            const sumByMatch = new Map();
            for (const r of rows) {
                const mid = String(r.match_id ?? '');
                const v = Number(r.ballbesitz);
                if (!mid || !Number.isFinite(v)) continue;
                sumByMatch.set(mid, (sumByMatch.get(mid) || 0) + v);
            }

            if (!sumByMatch.size) return null;
            const vals = Array.from(sumByMatch.values());
            const avg = vals.reduce((a, x) => a + x, 0) / vals.length;
            return Math.max(0, Math.min(100, avg));
        })();

        if (pct == null) {
            bar.style.display = 'none';
            bar.removeAttribute('title');
            return;
        }

        const homePct = Math.max(0, Math.min(100, pct));
        const awayPct = Math.max(0, Math.min(100, 100 - homePct));

        const homeInt = Math.round(homePct);
        const awayInt = 100 - homeInt;

        away.style.height = `${awayPct}%`;
        home.style.height = `${homePct}%`;
        if (awayLabel) awayLabel.textContent = String(awayInt);
        if (homeLabel) homeLabel.textContent = String(homeInt);
        bar.style.display = '';
        bar.title = `Ballbesitz: ${teamName} ${homePct.toFixed(1)}% · Gegner ${awayPct.toFixed(1)}%`;
    }

    function renderOverviewFieldTiltBar(allEvs, teamName, selectedMatchIds) {
        const bar = document.getElementById('overview-fieldtilt-bar');
        const away = document.getElementById('overview-fieldtilt-bar-away');
        const home = document.getElementById('overview-fieldtilt-bar-home');
        const awayLabel = document.getElementById('overview-fieldtilt-bar-away-label');
        const homeLabel = document.getElementById('overview-fieldtilt-bar-home-label');
        if (!bar || !away || !home) return;

        const pct = (() => {
            const ballEvents = new Set(['Pass', 'TakeOn', 'BallTouch', 'Shot', 'Goal', 'BallRecovery', 'Clearance', 'SavedShot', 'MissedShots']);

            const sel = (allEvs || [])
                .filter(e => e && e.match_id != null && selectedMatchIds.has(String(e.match_id)));
            if (!sel.length) return null;

            const byMatch = new Map();
            for (const e of sel) {
                const mid = String(e.match_id ?? '');
                if (!mid) continue;
                if (!byMatch.has(mid)) byMatch.set(mid, []);
                byMatch.get(mid).push(e);
            }

            const perMatchPct = [];
            for (const rows of byMatch.values()) {
                const attThird = rows.filter(e => {
                    const x = Number(e.x_coord);
                    const t = e.event_type;
                    if (!Number.isFinite(x) || x <= 66.6) return false;
                    if (!t || !ballEvents.has(t)) return false;
                    return true;
                });
                if (!attThird.length) continue;
                const teamCount = attThird.filter(e => e.team === teamName).length;
                const oppCount = attThird.filter(e => e.team !== teamName).length;
                const denom = teamCount + oppCount;
                if (!denom) continue;
                perMatchPct.push((teamCount / denom) * 100);
            }

            if (!perMatchPct.length) return null;
            const avgPct = perMatchPct.reduce((a, v) => a + v, 0) / perMatchPct.length;
            return Math.max(0, Math.min(100, Math.round(avgPct * 10) / 10));
        })();

        if (pct == null) {
            bar.style.display = 'none';
            bar.removeAttribute('title');
            return;
        }

        const homePct = Math.max(0, Math.min(100, pct));
        const awayPct = Math.max(0, Math.min(100, 100 - homePct));

        const homeInt = Math.round(homePct);
        const awayInt = 100 - homeInt;

        away.style.height = `${awayPct}%`;
        home.style.height = `${homePct}%`;
        if (awayLabel) awayLabel.textContent = String(awayInt);
        if (homeLabel) homeLabel.textContent = String(homeInt);
        bar.style.display = '';
        bar.title = `Field Tilt: ${teamName} ${homePct.toFixed(1)}% · Gegner ${awayPct.toFixed(1)}%`;
    }

    function renderOverviewPlayerMatrix(teamName, selectedMatchIds) {
        const root = document.getElementById('overview-player-matrix');
        if (!root) return;
        overviewPlayerMatrixLastTeam = teamName;
        overviewPlayerMatrixLastMatchIds = Array.from(selectedMatchIds || []).map(String);

        if (!root.__overviewSortBound) {
            root.addEventListener('click', (ev) => {
                const btn = ev.target && ev.target.closest ? ev.target.closest('[data-overview-sort-key]') : null;
                if (!btn) return;
                const key = String(btn.getAttribute('data-overview-sort-key') || '').trim();
                if (!key) return;

                if (overviewPlayerMatrixSortKey === key) {
                    overviewPlayerMatrixSortDir = (overviewPlayerMatrixSortDir === 'desc') ? 'asc' : 'desc';
                } else {
                    overviewPlayerMatrixSortKey = key;
                    overviewPlayerMatrixSortDir = 'desc';
                }

                const lastTeam = overviewPlayerMatrixLastTeam;
                const lastIds = new Set((overviewPlayerMatrixLastMatchIds || []).map(String));
                if (lastTeam && lastIds.size) renderOverviewPlayerMatrix(lastTeam, lastIds);
            });
            root.__overviewSortBound = true;
        }

        const rows = (dataset || [])
            .filter(r => r && r.team === teamName && selectedMatchIds.has(String(r.match_id ?? '')));
        if (!rows.length) {
            root.innerHTML = '<div class="text-gray-500">Keine Spieler-Daten.</div>';
            return;
        }

        const byPlayer = new Map();
        for (const r of rows) {
            const name = String(r.player ?? '').trim();
            if (!name) continue;
            const mins = Number(r.minutes_played ?? 0);
            if (!Number.isFinite(mins) || mins <= 0) continue;
            const xg = Number(r.xg ?? 0);
            const xt = Number(r.xt ?? 0);
            const goals = Number(r.goals ?? 0);
            const cur = byPlayer.get(name) || { minutes: 0, goals: 0, xg: 0, xt: 0 };
            cur.minutes += mins;
            cur.goals += (Number.isFinite(goals) ? goals : 0);
            cur.xg += (Number.isFinite(xg) ? xg : 0);
            cur.xt += (Number.isFinite(xt) ? xt : 0);
            byPlayer.set(name, cur);
        }

        const list = Array.from(byPlayer.entries())
            .map(([name, v]) => ({ name, ...v }))
            .sort((a, b) => {
                const dir = (overviewPlayerMatrixSortDir === 'asc') ? 1 : -1;
                const key = overviewPlayerMatrixSortKey;
                const num = (v) => {
                    const n = Number(v);
                    return Number.isFinite(n) ? n : -Infinity;
                };
                const diffA = num(a.goals) - num(a.xg);
                const diffB = num(b.goals) - num(b.xg);

                if (key === 'name') {
                    const c = String(a.name).localeCompare(String(b.name));
                    return c * dir;
                }

                let av = 0;
                let bv = 0;
                if (key === 'minutes') { av = num(a.minutes); bv = num(b.minutes); }
                else if (key === 'goals') { av = num(a.goals); bv = num(b.goals); }
                else if (key === 'xg') { av = num(a.xg); bv = num(b.xg); }
                else if (key === 'diff') { av = diffA; bv = diffB; }
                else if (key === 'xt') { av = num(a.xt); bv = num(b.xt); }
                else { av = num(a.minutes); bv = num(b.minutes); }

                if (av !== bv) return (bv - av) * dir;
                const c = String(a.name).localeCompare(String(b.name));
                if (c !== 0) return c;
                return (num(b.minutes) - num(a.minutes));
            });

        const fmt2 = (v) => {
            const n = Number(v);
            return Number.isFinite(n) ? (Math.round(n * 100) / 100).toFixed(2) : '-';
        };
        const fmtMin = (v) => {
            const n = Number(v);
            return Number.isFinite(n) ? String(Math.round(n)) : '-';
        };
        const fmtGoals = (v) => {
            const n = Number(v);
            return Number.isFinite(n) ? String(Math.round(n)) : '-';
        };
        const fmtDiff = (v) => {
            const n = Number(v);
            if (!Number.isFinite(n)) return '-';
            const out = (Math.round(n * 100) / 100).toFixed(2);
            return n > 0 ? `+${out}` : out;
        };

        const sortArrow = (key) => {
            if (overviewPlayerMatrixSortKey !== key) return '<span class="ml-1 text-[9px] text-gray-300">▼</span>';
            const arrow = (overviewPlayerMatrixSortDir === 'asc') ? '▲' : '▼';
            return `<span class="ml-1 text-[9px] text-gray-500">${arrow}</span>`;
        };

        const header = `
            <div class="flex items-center justify-between">
                <div class="text-xs font-semibold text-gray-700">Spieler</div>
            </div>
        `;

        const rowsHtml = list.map(p => {
            const diff = (Number(p.goals) - Number(p.xg));
            return `
                <div class="grid grid-cols-[minmax(0,1fr)_3.25rem_3.25rem_3.25rem_3.25rem_3.25rem] gap-2 py-1 border-b border-gray-100">
                    <div class="truncate text-[11px] text-gray-800 text-left">${p.name}</div>
                    <div class="text-[11px] text-gray-700 text-center w-full">${fmtMin(p.minutes)}</div>
                    <div class="text-[11px] text-gray-700 text-center w-full">${fmtGoals(p.goals)}</div>
                    <div class="text-[11px] text-gray-700 text-center w-full">${fmt2(p.xg)}</div>
                    <div class="text-[11px] text-gray-700 text-center w-full">${fmtDiff(diff)}</div>
                    <div class="text-[11px] text-gray-700 text-center w-full">${fmt2(p.xt)}</div>
                </div>
            `;
        }).join('');

        root.innerHTML = `
            ${header}
            <div class="mt-2 grid grid-cols-[minmax(0,1fr)_3.25rem_3.25rem_3.25rem_3.25rem_3.25rem] gap-2 text-[10px] text-gray-500 pb-1 border-b border-gray-200">
                <button type="button" class="w-full inline-flex items-center justify-start text-left select-none hover:text-gray-700" data-overview-sort-key="name">Spieler${sortArrow('name')}</button>
                <button type="button" class="w-full inline-flex items-center justify-center text-center select-none hover:text-gray-700" data-overview-sort-key="minutes">Min${sortArrow('minutes')}</button>
                <button type="button" class="w-full inline-flex items-center justify-center text-center select-none hover:text-gray-700" data-overview-sort-key="goals">Tore${sortArrow('goals')}</button>
                <button type="button" class="w-full inline-flex items-center justify-center text-center select-none hover:text-gray-700" data-overview-sort-key="xg">xG${sortArrow('xg')}</button>
                <button type="button" class="w-full inline-flex items-center justify-center text-center select-none hover:text-gray-700" data-overview-sort-key="diff">Tore-xG${sortArrow('diff')}</button>
                <button type="button" class="w-full inline-flex items-center justify-center text-center select-none hover:text-gray-700" data-overview-sort-key="xt">xT${sortArrow('xt')}</button>
            </div>
            <div class="mt-1 flex-1 overflow-y-scroll pr-2 min-h-0 pb-3" style="scrollbar-gutter: stable;">
                ${rowsHtml}
            </div>
        `;
    }

    function periodOrder(p) {
        const s = String(p ?? '');
        if (s === 'FirstHalf') return 1;
        if (s === 'SecondHalf') return 2;
        if (s === 'FirstPeriod') return 1;
        if (s === 'SecondPeriod') return 2;
        if (s === 'ThirdPeriod') return 3;
        if (s === 'FourthPeriod') return 4;
        const n = Number(p);
        return Number.isFinite(n) ? n : 0;
    }

    function toNum(v) {
        const n = Number(v);
        return Number.isFinite(n) ? n : null;
    }

    function inOppBox(x, y) {
        if (!Number.isFinite(x) || !Number.isFinite(y)) return false;
        return x >= 83 && y >= 21 && y <= 79;
    }

    function xyToMeters(xPct, yPct) {
        const x = (xPct / 100) * 105;
        const y = (yPct / 100) * 68;
        return { x, y };
    }

    function distToOppGoalMeters(xPct, yPct) {
        const p = xyToMeters(xPct, yPct);
        const gx = 105;
        const gy = 34;
        const dx = gx - p.x;
        const dy = gy - p.y;
        return Math.sqrt(dx * dx + dy * dy);
    }

    function buildFlipMapForTeam(evs, teamName) {
        const flip = new Map();
        const byMatch = new Map();
        for (const e of evs) {
            const mid = String(e.match_id ?? '');
            if (!mid) continue;
            if (!byMatch.has(mid)) byMatch.set(mid, []);
            byMatch.get(mid).push(e);
        }
        for (const [mid, rows] of byMatch.entries()) {
            const byPer = new Map();
            for (const e of rows) {
                const po = periodOrder(e.period);
                const k = String(po);
                if (!byPer.has(k)) byPer.set(k, []);
                byPer.get(k).push(e);
            }
            for (const [perKey, perRows] of byPer.entries()) {
                const shots = perRows.filter(r => r.team === teamName && (r.isShot === true || r.event_type === 'Shot'))
                    .map(r => toNum(r.x_coord))
                    .filter(v => Number.isFinite(v));
                let sample = shots;
                if (!sample.length) {
                    sample = perRows.filter(r => r.team === teamName)
                        .map(r => toNum(r.x_coord))
                        .filter(v => Number.isFinite(v));
                }
                if (!sample.length) {
                    flip.set(`${mid}|${perKey}`, false);
                    continue;
                }
                sample.sort((a, b) => a - b);
                const med = sample[Math.floor(sample.length / 2)];
                const attacksRight = med >= 50;
                flip.set(`${mid}|${perKey}`, !attacksRight);
            }
        }
        return flip;
    }

    function normalizeEventForFlip(e, flipByMatchPeriod) {
        const mid = String(e.match_id ?? '');
        const perKey = String(periodOrder(e.period));
        const doFlip = flipByMatchPeriod.get(`${mid}|${perKey}`) === true;
        const x = toNum(e.x_coord);
        const y = toNum(e.y_coord);
        const ex = toNum(e.end_x);
        const ey = toNum(e.end_y);
        const nx = (x == null ? null : (doFlip ? 100 - x : x));
        const ny = (y == null ? null : y);
        const nex = (ex == null ? null : (doFlip ? 100 - ex : ex));
        const ney = (ey == null ? null : ey);
        return {
            ...e,
            __nx: nx,
            __ny: ny,
            __nex: nex,
            __ney: ney,
            __t: (toNum(e.minute) ?? 0) * 60 + (toNum(e.second) ?? 0),
            __po: periodOrder(e.period)
        };
    }

    function computePossessionsForMatch(allMatchEvents) {
        const evs = allMatchEvents
            .filter(e => e && e.team)
            .map((e, idx) => ({ ...e, __i: idx }))
            .sort((a, b) => (a.__po - b.__po) || (a.__t - b.__t) || (a.__i - b.__i));
        const poss = [];
        let cur = null;
        for (const e of evs) {
            const team = e.team;
            if (!cur || cur.team !== team) {
                if (cur && cur.events.length) poss.push(cur);
                cur = { team, events: [] };
            }
            cur.events.push(e);
            if (e.event_type === 'Goal' || e.isGoal === true) {
                poss.push(cur);
                cur = null;
            }
        }
        if (cur && cur.events.length) poss.push(cur);
        return poss;
    }

    function computeAthleticStatsForTeam(allEvs, teamName, selectedMatchIds) {
        const sel = (allEvs || []).filter(e => e && e.match_id != null && selectedMatchIds.has(String(e.match_id)));
        if (!sel.length) return null;

        const flipMap = buildFlipMapForTeam(sel, teamName);
        const norm = sel.map(e => normalizeEventForFlip(e, flipMap));
        const byMatch = new Map();
        for (const e of norm) {
            const mid = String(e.match_id ?? '');
            if (!mid) continue;
            if (!byMatch.has(mid)) byMatch.set(mid, []);
            byMatch.get(mid).push(e);
        }

        let startDistSum = 0;
        let startDistN = 0;
        let progSum = 0;
        let progN = 0;

        let progPassMeters = 0;
        let totalPassMeters = 0;

        let buildups = 0;
        let fastBreaks = 0;

        let highPressNum = 0;
        let highPressDen = 0;

        const matchesPlayedSet = new Set();
        let totalMatchMinutes = 0;
        for (const [mid, mevs] of byMatch.entries()) {
            if (mevs.some(e => e.team === teamName)) {
                matchesPlayedSet.add(mid);
                const maxT = mevs.reduce((m, e) => (Number.isFinite(e.__t) && e.__t > m ? e.__t : m), 0);
                const mins = maxT > 0 ? (maxT / 60) : 90;
                totalMatchMinutes += mins;
            }
            const possessions = computePossessionsForMatch(mevs);
            for (const p of possessions) {
                if (p.team !== teamName) continue;

                const startEv = p.events.find(ev => Number.isFinite(ev.__nx) && Number.isFinite(ev.__ny));
                const endEv = [...p.events].reverse().find(ev => Number.isFinite(ev.__nx) && Number.isFinite(ev.__ny));
                if (startEv && endEv) {
                    const sd = distToOppGoalMeters(startEv.__nx, startEv.__ny);
                    const ed = distToOppGoalMeters(endEv.__nx, endEv.__ny);
                    if (Number.isFinite(sd) && sd > 0 && Number.isFinite(ed)) {
                        startDistSum += sd;
                        startDistN += 1;
                        const prog = ((sd - ed) / sd) * 100;
                        if (Number.isFinite(prog)) {
                            progSum += prog;
                            progN += 1;
                        }
                    }
                }

                let succPasses = 0;
                let qualifiesBuildUp = false;
                let firstOwn40TouchT = null;
                let qualifiesFastBreak = false;

                for (const ev of p.events) {
                    const x = ev.__nx;
                    const y = ev.__ny;
                    const t = ev.__t;

                    if (firstOwn40TouchT == null && ev.event_type === 'BallTouch' && Number.isFinite(x) && x <= 40) {
                        firstOwn40TouchT = t;
                    }

                    if (ev.event_type === 'Pass' && ev.outcome === 'Successful') {
                        succPasses += 1;
                    }

                    const isShot = (ev.isShot === true || ev.event_type === 'Shot');
                    const isBoxTouch = (ev.event_type === 'BallTouch' && inOppBox(x, y));
                    const isBoxEvent = isShot || isBoxTouch;

                    if (!qualifiesBuildUp && succPasses >= 8 && isBoxEvent) {
                        qualifiesBuildUp = true;
                    }
                    if (!qualifiesFastBreak && firstOwn40TouchT != null && isBoxEvent) {
                        const dt = t - firstOwn40TouchT;
                        if (dt >= 0 && dt <= 15) {
                            qualifiesFastBreak = true;
                        }
                    }
                }

                if (qualifiesBuildUp) buildups += 1;
                if (qualifiesFastBreak) fastBreaks += 1;
            }

            for (const ev of mevs) {
                if (ev.team !== teamName) continue;
                if (ev.event_type !== 'Pass') continue;
                const x = ev.__nx;
                const y = ev.__ny;
                const ex = ev.__nex;
                const ey = ev.__ney;
                if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(ex) || !Number.isFinite(ey)) continue;
                const a = xyToMeters(x, y);
                const b = xyToMeters(ex, ey);
                const dx = b.x - a.x;
                const dy = b.y - a.y;
                const d = Math.sqrt(dx * dx + dy * dy);
                if (!Number.isFinite(d) || d <= 0) continue;
                totalPassMeters += d;
                const prog = Math.max(0, dx);
                progPassMeters += prog;
            }

            for (const ev of mevs) {
                const x = ev.__nx;
                if (!Number.isFinite(x) || x < 40) continue;
                if (ev.team !== teamName) {
                    if (ev.event_type === 'Pass') {
                        highPressDen += 1;
                        if (ev.is_longball === true) highPressNum += 1;
                    }
                    continue;
                }
                if (['Tackle', 'Interception', 'Foul', 'BallRecovery'].includes(ev.event_type)) {
                    highPressNum += 1;
                }
            }
        }

        const startDistance = startDistN ? (startDistSum / startDistN) : null;
        const progression = progN ? (progSum / progN) : null;
        const circulation = totalPassMeters > 0 ? (1 - (progPassMeters / totalPassMeters)) : null;
        const highPress = highPressDen > 0 ? ((highPressNum / highPressDen) * 100) : null;
        const matchesPlayed = matchesPlayedSet.size || 0;
        const buildupsP90 = totalMatchMinutes > 0 ? ((buildups / totalMatchMinutes) * 90) : null;
        const fastBreaksP90 = totalMatchMinutes > 0 ? ((fastBreaks / totalMatchMinutes) * 90) : null;
        return {
            startDistance,
            progression,
            circulation,
            buildups,
            fastBreaks,
            highPress,
            matchesPlayed,
            totalMatchMinutes,
            buildupsP90,
            fastBreaksP90
        };
    }

    function clamp(v, lo, hi) {
        const n = Number(v);
        if (!Number.isFinite(n)) return lo;
        return Math.max(lo, Math.min(hi, n));
    }

    function scoreFromPercentileHalf(p) {
        if (!Number.isFinite(p)) return 0;
        const pts = Math.round((p * 5) * 2) / 2;
        return clamp(pts, 0, 5);
    }

    function startDistanceScore(meters) {
        const m = Number(meters);
        if (!Number.isFinite(m)) return 0;
        const pts = 39.5 - 0.5 * m;
        const snapped = Math.round(pts * 2) / 2;
        return clamp(snapped, 0, 5);
    }

    function highPressScore(value) {
        const v = Number(value);
        if (!Number.isFinite(v)) return 0;
        const pts = 0.1 * (v - 17) + 1.5;
        const snapped = Math.round(pts * 2) / 2;
        return clamp(snapped, 0, 5);
    }

    function fastBreaksScore(value) {
        const v = Number(value);
        if (!Number.isFinite(v)) return 0;
        const pts = v / 3;
        const snapped = Math.round(pts * 2) / 2;
        return clamp(snapped, 0, 5);
    }

    function buildupsScore(value) {
        const v = Number(value);
        if (!Number.isFinite(v)) return 0;
        const pts = 0.5 * v - 0.5;
        const snapped = Math.round(pts * 2) / 2;
        return clamp(snapped, 0, 5);
    }

    function dotsHtmlFromScore(score) {
        const s = clamp(score, 0, 5);
        return Array.from({ length: 5 }).map((_, i) => {
            const level = i + 1;
            const full = s >= level - 1e-9;
            const half = !full && s >= (level - 0.5) - 1e-9;
            const cls = full ? ' filled' : (half ? ' half' : '');
            return `<span class="ms-dot${cls}"></span>`;
        }).join('');
    }

    function buildMatchStatsBaseline(allEvs) {
        const evs = allEvs || [];
        const key = `baseline::${evs.length}`;
        if (_overviewBaselineCacheKey === key && _overviewBaselineCacheValue) return _overviewBaselineCacheValue;

        const byMatch = new Map();
        for (const e of evs) {
            if (!e || e.match_id == null) continue;
            const mid = String(e.match_id);
            if (!mid) continue;
            if (!byMatch.has(mid)) byMatch.set(mid, []);
            byMatch.get(mid).push(e);
        }

        const out = {
            progression: [],
            circulation: [],
            buildupsP90: [],
            fastBreaksP90: []
        };

        for (const [mid, mevs] of byMatch.entries()) {
            const teams = Array.from(new Set(mevs.map(r => r.team).filter(Boolean)));
            const midSet = new Set([mid]);
            for (const t of teams) {
                const s = computeAthleticStatsForTeam(mevs, t, midSet);
                if (!s) continue;
                if (Number.isFinite(s.progression)) out.progression.push(s.progression);
                if (Number.isFinite(s.circulation)) out.circulation.push(s.circulation);
                if (Number.isFinite(s.buildupsP90)) out.buildupsP90.push(s.buildupsP90);
                if (Number.isFinite(s.fastBreaksP90)) out.fastBreaksP90.push(s.fastBreaksP90);
            }
        }

        _overviewBaselineCacheKey = key;
        _overviewBaselineCacheValue = out;
        return out;
    }

    function percentileOfValue(values, value, higherIsBetter = true) {
        const nums = (values || []).map(v => Number(v)).filter(v => Number.isFinite(v));
        if (!nums.length || !Number.isFinite(value)) return null;
        nums.sort((a, b) => a - b);
        let rank = 0;
        for (let i = 0; i < nums.length; i++) {
            if (nums[i] <= value) rank = i;
        }
        const p = nums.length === 1 ? 1 : (rank / (nums.length - 1));
        return higherIsBetter ? p : (1 - p);
    }

    function renderOverviewMatchStats(allEvs, teamName, selectedMatchIds) {
        const root = document.getElementById('overview-matchstats');
        if (!root) return;
        const key = `${teamName}::${Array.from(selectedMatchIds).sort().join('|')}`;
        if (_overviewMatchStatsCacheKey === key && _overviewMatchStatsCacheValue) {
            root.innerHTML = _overviewMatchStatsCacheValue;
            return;
        }

        const sel = (allEvs || []).filter(e => e && e.match_id != null && selectedMatchIds.has(String(e.match_id)));
        const teams = Array.from(new Set(sel.map(e => e.team).filter(Boolean)));

        const statsByTeam = new Map();
        for (const t of teams) {
            const s = computeAthleticStatsForTeam(allEvs, t, selectedMatchIds);
            if (s) statsByTeam.set(t, s);
        }
        const our = statsByTeam.get(teamName) || null;
        if (!our) {
            root.innerHTML = '<div class="text-sm text-gray-500">Keine Eventdaten für Übersicht vorhanden.</div>';
            _overviewMatchStatsCacheKey = key;
            _overviewMatchStatsCacheValue = root.innerHTML;
            return;
        }

        const baseline = buildMatchStatsBaseline(allEvs);
        const values = (field) => {
            if (baseline && baseline[field]) return baseline[field];
            return Array.from(statsByTeam.values()).map(s => s[field]);
        };

        const fmtM = (v) => (Number.isFinite(v) ? String(Math.round(v)) : '-');
        const fmtPct = (v) => (Number.isFinite(v) ? `${Math.round(v)}%` : '-');
        const fmtRatio = (v) => (Number.isFinite(v) ? (Math.round(v * 100) / 100).toFixed(2) : '-');
        const fmtCount = (v) => (Number.isFinite(v) ? String(Math.round(v * 10) / 10) : '-');

        const rows = [
            { key: 'startDistance', label: 'Start distance', valueText: Number.isFinite(our.startDistance) ? fmtM(our.startDistance) : '-', higherIsBetter: false },
            { key: 'progression', label: 'Progression', valueText: Number.isFinite(our.progression) ? fmtPct(our.progression) : '-', higherIsBetter: true },
            { key: 'circulation', label: 'Circulation', valueText: Number.isFinite(our.circulation) ? fmtRatio(our.circulation) : '-', higherIsBetter: true },
            { key: 'buildups', label: 'Build-ups', valueText: fmtCount(our.buildupsP90), higherIsBetter: true },
            { key: 'fastBreaks', label: 'Fast breaks', valueText: fmtCount(our.fastBreaksP90), higherIsBetter: true },
            { key: 'highPress', label: 'High press', valueText: Number.isFinite(our.highPress) ? (Math.round(our.highPress * 10) / 10).toFixed(1) : '-', higherIsBetter: true }
        ];

        const percentileValue = (row) => {
            if (row.key === 'buildups') {
                return percentileOfValue(values('buildupsP90'), our.buildupsP90, row.higherIsBetter);
            }
            if (row.key === 'fastBreaks') {
                return percentileOfValue(values('fastBreaksP90'), our.fastBreaksP90, row.higherIsBetter);
            }
            return percentileOfValue(values(row.key), our[row.key], row.higherIsBetter);
        };

        const html = rows.map(r => {
            let score;
            if (r.key === 'startDistance') score = startDistanceScore(our.startDistance);
            else if (r.key === 'buildups') score = buildupsScore(our.buildupsP90);
            else if (r.key === 'fastBreaks') score = fastBreaksScore(our.fastBreaksP90);
            else if (r.key === 'highPress') score = highPressScore(our.highPress);
            else score = scoreFromPercentileHalf(percentileValue(r));
            const dots = dotsHtmlFromScore(score);
            return `
                <div class="flex items-center justify-start gap-3 w-full" style="max-width: 360px;">
                    <div class="ms-dots">${dots}</div>
                    <div class="px-3 py-0.5 rounded-full border text-sm" style="border-color:#0A3F86; background:#0A3F86; color:#fff; min-width:60px; text-align:center; font-weight:600;">${r.valueText}</div>
                    <div class="text-base font-semibold text-gray-900">${r.label}</div>
                </div>
            `;
        }).join('');

        root.innerHTML = html;
        _overviewMatchStatsCacheKey = key;
        _overviewMatchStatsCacheValue = html;
    }

    function renderOverviewShotEndingSequences(allEvs, teamName, selectedMatchIds) {
        const root = document.getElementById('overview-sequences-chart');
        if (!root) return;

        let rowHeightPx = 24;
        try {
            const refRow = document.querySelector('#overview-player-matrix .mt-1 .grid');
            if (refRow) {
                const h = refRow.getBoundingClientRect().height;
                if (Number.isFinite(h) && h > 0) rowHeightPx = Math.round(h);
            }
        } catch (_) {}
        const barHeightPx = Math.max(10, rowHeightPx - 4);

        const rows = (dataset || [])
            .filter(r => r && r.team === teamName && selectedMatchIds.has(String(r.match_id ?? '')));
        if (!rows.length) {
            root.innerHTML = '';
            return;
        }

        const minutesByName = new Map();
        for (const r of rows) {
            const nm = String(r.player ?? r.player_name ?? '').trim();
            if (!nm) continue;
            const mins = Number(r.minutes_played ?? 0);
            if (!Number.isFinite(mins) || mins <= 0) continue;
            minutesByName.set(nm, (minutesByName.get(nm) || 0) + mins);
        }

        const shotTypes = new Set(['Shot', 'Goal', 'SavedShot', 'MissedShots']);
        const buildTypes = new Set(['Pass', 'Carry', 'TakeOn', 'BallTouch']);

        const isOpenPlayBlocked = (e) => {
            if (!e) return true;
            if (e.is_corner === true) return true;
            if (e.is_freekick === true) return true;
            if (e.is_throwin === true) return true;
            if (e.is_goalkick === true) return true;
            if (e.event_type === 'CornerAwarded') return true;
            if (e.event_type === 'ThrowInAwarded') return true;
            return false;
        };

        const getName = (e) => String(e?.player_name || e?.player || '').trim();

        const sel = (allEvs || [])
            .filter(e => e && e.match_id != null && selectedMatchIds.has(String(e.match_id)))
            .filter(e => e.team != null && !isOpenPlayBlocked(e));

        if (!sel.length) {
            root.innerHTML = '<div class="text-xs text-gray-500">Keine Eventdaten.</div>';
            return;
        }

        const flipMap = buildFlipMapForTeam(sel, teamName);
        const norm = sel.map(e => normalizeEventForFlip(e, flipMap));
        const byMatch = new Map();
        for (const e of norm) {
            const mid = String(e.match_id ?? '');
            if (!mid) continue;
            if (!byMatch.has(mid)) byMatch.set(mid, []);
            byMatch.get(mid).push(e);
        }

        const shotCount = new Map();
        const chanceCount = new Map();
        const buildCount = new Map();

        const inc = (map, name) => {
            if (!name) return;
            map.set(name, (map.get(name) || 0) + 1);
        };

        for (const mevs of byMatch.values()) {
            const possessions = computePossessionsForMatch(mevs);
            for (const p of possessions) {
                if (!p?.events?.length) continue;

                const shotIdx = (() => {
                    for (let i = p.events.length - 1; i >= 0; i--) {
                        const ev = p.events[i];
                        const t = String(ev.event_type || '');
                        if (shotTypes.has(t) || ev.isShot === true) return i;
                    }
                    return -1;
                })();
                if (shotIdx < 0) continue;
                const shotEv = p.events[shotIdx];
                if (String(shotEv.team) !== String(teamName)) continue;

                const shooter = getName(shotEv);
                if (shooter) inc(shotCount, shooter);

                let creator = '';
                for (let i = shotIdx - 1; i >= 0; i--) {
                    const ev = p.events[i];
                    if (String(ev.team) !== String(teamName)) continue;
                    if (String(ev.event_type || '') !== 'Pass') continue;
                    if (ev.outcome !== 'Successful') continue;
                    const nm = getName(ev);
                    if (!nm) continue;
                    creator = nm;
                    break;
                }
                if (creator) inc(chanceCount, creator);

                const involved = new Set();
                for (let i = 0; i <= shotIdx; i++) {
                    const ev = p.events[i];
                    if (String(ev.team) !== String(teamName)) continue;
                    const t = String(ev.event_type || '');
                    if (!buildTypes.has(t)) continue;
                    const nm = getName(ev);
                    if (!nm) continue;
                    if (nm === shooter) continue;
                    if (nm === creator) continue;
                    involved.add(nm);
                }
                for (const nm of involved) inc(buildCount, nm);
            }
        }

        const list = Array.from(minutesByName.entries())
            .map(([name, minutes]) => {
                const mins = Number(minutes);
                const factor = mins > 0 ? (90 / mins) : 0;
                const s = (shotCount.get(name) || 0) * factor;
                const c = (chanceCount.get(name) || 0) * factor;
                const b = (buildCount.get(name) || 0) * factor;
                const total = s + c + b;
                return { name, minutes: mins, shot: s, chance: c, buildup: b, total };
            })
            .filter(r => Number.isFinite(r.total) && r.total > 0)
            .sort((a, b) => (b.total - a.total) || a.name.localeCompare(b.name));

        if (!list.length) {
            root.innerHTML = '<div class="text-xs text-gray-500">Keine Shot-Ending-Sequenzen (Open Play) gefunden.</div>';
            return;
        }

        const topN = list.slice(0, 12);
        const maxTotal = Math.max(...topN.map(r => r.total), 1e-6);
        const axisMax = Math.max(1, Math.ceil(maxTotal));
        const fmt1 = (v) => (Math.round(v * 10) / 10).toFixed(1);

        const header = `
            <div class="text-xs font-semibold text-gray-700 mb-2">Open-Play Shot-Ending Sequences p90</div>
            <div class="flex items-center gap-3 text-[10px] text-gray-600 mb-3">
                <span class="inline-flex items-center gap-1"><span class="inline-block w-2.5 h-2.5 rounded-sm" style="background:#0A3F86"></span>Shot</span>
                <span class="inline-flex items-center gap-1"><span class="inline-block w-2.5 h-2.5 rounded-sm bg-blue-500"></span>Chance created</span>
                <span class="inline-flex items-center gap-1"><span class="inline-block w-2.5 h-2.5 rounded-sm bg-blue-200 border border-gray-300"></span>Build-up</span>
            </div>
        `;

        const rowHtml = topN.map(r => {
            const totalPct = clamp((r.total / axisMax) * 100, 0, 100);
            const denom = r.total > 0 ? r.total : 1;
            const wShot = clamp((r.shot / denom) * 100, 0, 100);
            const wChance = clamp((r.chance / denom) * 100, 0, 100);
            const wBuild = clamp(100 - (wShot + wChance), 0, 100);

            const showShot = wShot >= 12;
            const showChance = wChance >= 12;
            const showBuild = wBuild >= 12;

            return `
                <div class="grid grid-cols-[8.5rem_minmax(0,1fr)] gap-3 items-center border-b border-gray-100 box-border" style="height:${rowHeightPx}px;">
                    <div class="truncate text-[11px] text-gray-800 flex items-center" style="height:${rowHeightPx}px;">${r.name}</div>
                    <div class="w-full flex items-center" style="height:${rowHeightPx}px;">
                        <div class="flex overflow-hidden rounded-sm border border-gray-300 bg-white box-border" style="width:${totalPct}%; height:${barHeightPx}px;">
                            <div class="h-full flex items-center justify-center" style="width:${wShot}%; background:#0A3F86;">
                                <span class="text-[11px] font-semibold text-white">${showShot ? fmt1(r.shot) : ''}</span>
                            </div>
                            <div class="h-full flex items-center justify-center bg-blue-500" style="width:${wChance}%;">
                                <span class="text-[11px] font-semibold text-gray-900">${showChance ? fmt1(r.chance) : ''}</span>
                            </div>
                            <div class="h-full flex items-center justify-center bg-blue-200" style="width:${wBuild}%;">
                                <span class="text-[11px] font-semibold text-gray-900">${showBuild ? fmt1(r.buildup) : ''}</span>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }).join('');

        const ticks = Array.from({ length: axisMax + 1 }, (_, i) => i);
        const ticksHtml = ticks.map(t => {
            const pct = axisMax > 0 ? (t / axisMax) * 100 : 0;
            const left = clamp(pct, 0, 100);
            return `
                <div class="absolute top-1" style="left:${left}%; transform: translateX(-50%);">
                    <div class="w-px h-2 bg-gray-300"></div>
                    <div class="text-[10px] text-gray-600 -mt-0.5">${t}</div>
                </div>
            `;
        }).join('');

        const axisHtml = `
            <div class="grid grid-cols-[8.5rem_minmax(0,1fr)] gap-3 items-start mt-3">
                <div></div>
                <div class="relative h-6">
                    <div class="absolute left-0 right-0 top-1 border-t border-gray-300"></div>
                    ${ticksHtml}
                </div>
            </div>
            <div class="grid grid-cols-[8.5rem_minmax(0,1fr)] gap-3 items-start mt-1">
                <div></div>
                <div class="text-[10px] text-gray-600">Involvements in open-play shot-ending sequences (per 90)</div>
            </div>
        `;

        root.innerHTML = `<div class="w-full">${header}${rowHtml}${axisHtml}</div>`;
    }

    async function updateDashboard() {
        if (isUpdating) return; // vermeide parallele Updates (Flicker)
        isUpdating = true;
        try {
        const topPhase = (typeof currentMainPhase === 'string' && currentMainPhase) ? currentMainPhase : currentPhase;
        const titleEl = document.getElementById('analysis-title');
        if (titleEl) titleEl.textContent = currentTeam;

        // Keep center visualization in sync with the left "Spielkontrolle" tab selection.
        if (activeLeftTabGroup === 'kontrolle') {
            if (lastOpenKontrolleTab === 'ballbesitz') currentPhase = 'ballbesitz';
            else if (lastOpenKontrolleTab === 'fieldtilt') currentPhase = 'fieldtilt';
            else if (lastOpenKontrolleTab === 'switch-rate') currentPhase = 'switch-rate';
        }

        const teamEvents = getEventsForTeam(currentTeam, currentGameCount);
        const selectedMatchIds = new Set((teamEvents || []).map(e => String(e.match_id ?? '')).filter(Boolean));

        // Übersicht: Center-only Match Stats
        if (topPhase === 'uebersicht') {
            setOverviewModeLayout(true);
            renderOverviewBallbesitzPitch(eventDataset || [], currentTeam, selectedMatchIds);
            renderOverviewPossessionBar(currentTeam, selectedMatchIds);
            renderOverviewFieldTiltBar(eventDataset || [], currentTeam, selectedMatchIds);
            renderOverviewMatchStats(eventDataset || [], currentTeam, selectedMatchIds);
            renderOverviewPlayerMatrix(currentTeam, selectedMatchIds);
            renderOverviewShotEndingSequences(eventDataset || [], currentTeam, selectedMatchIds);
            return;
        }
        setOverviewModeLayout(false);

        applyPhysischLayout();
        // Ensure center view is correct even if we don't call updateActionCanvas() for the phase.
        syncCenterViewForPhase();
        // Info-Blöcke zuerst aktualisieren, damit PitchViz-Stats-Targets (z.B. #gk-stats/#pp-stats) existieren.
        updateInfoBlocks(teamEvents);

        // Ensure right column matches pitch height after content/layout updates.
        requestAnimationFrame(() => {
            syncRightPanelHeightToPitch();
        });
        const needsInversion = (currentTeam !== baseTeam);

        // Visualisierungs-Orientierung:
        // - eigenes Team (baseTeam): Spielrichtung unten -> oben
        // - Gegner (currentTeam != baseTeam): Spielrichtung oben -> unten (180° gedreht)
        const invertCoord = (v) => {
            if (v == null) return v;
            const n = Number(v);
            return Number.isFinite(n) ? (100 - n) : v;
        };
        const vizTeamEvents = needsInversion
            ? (teamEvents || []).map(e => ({
                ...e,
                x_coord: invertCoord(e.x_coord),
                y_coord: invertCoord(e.y_coord),
                end_x: invertCoord(e.end_x),
                end_y: invertCoord(e.end_y),
            }))
            : teamEvents;
        
        let allActions = teamEvents
            .filter(e => e.x_coord != null && e.y_coord != null)
            .map(e => ({
                ...e, // Behalte alle Originaldaten für Filterung etc.
                x: needsInversion ? 100 - e.x_coord : e.x_coord, // Überschreibe für die Darstellung
                y: needsInversion ? 100 - e.y_coord : e.y_coord,
                end_x: needsInversion ? 100 - e.end_x : e.end_x,
                end_y: needsInversion ? 100 - e.end_y : e.end_y,
                type: (e.is_corner === true ? 'Corner' : (e.is_throwin === true ? 'ThrowIn' : (e.is_freekick === true ? 'Freekick' : e.event_type))) // Behalte den Typ für die Filterung
            }));
            
        // Filtern basierend auf der Phase
        if (currentPhase === 'abstöße') {
            allActions = allActions.filter(a => a.is_goalkick === true);
        } else if (currentPhase === 'mit-ball') {
            allActions = allActions.filter(a => ['Pass', 'Shot', 'Goal', 'TakeOn'].includes(a.type));
        } else if (currentPhase === 'gegen-ball') {
            allActions = allActions.filter(a => ['Tackle', 'Interception', 'BallRecovery', 'Foul'].includes(a.type));
        } else if (currentPhase === 'standards') {
               allActions = allActions.filter(a => a.is_corner === true || a.is_freekick === true || a.is_throwin === true);
        }

        // Gegen den Ball -> Chance Prevention -> Schüsse / Schüsse Box
        // Visualisierung soll zugelassene Schüsse (Gegner) zeigen, nicht Team-eigene.
        if (
            currentMainPhase === 'gegen-ball' &&
            activeGegenBallGroup === 'chance' &&
            (currentPhase === 'shots' || currentPhase === 'shots-box')
        ) {
            const matchIds = new Set((teamEvents || []).map(e => e.match_id));
            const shotTypesOpp = new Set(['Shot', 'Goal', 'MissedShots', 'SavedShot']);
            let oppShots = (eventDataset || [])
                .filter(e => matchIds.has(e.match_id))
                .filter(e => e && e.team && e.team !== currentTeam)
                .filter(e => shotTypesOpp.has(e.event_type))
                .filter(e => e.x_coord != null && e.y_coord != null);

            // Schüsse Box: nur Abschlüsse aus dem Strafraum (Box)
            if (currentPhase === 'shots-box') {
                const boxDepth = (16.5 / 105) * 100;         // ~15.714 (Tiefe von der Torlinie)
                const boxHalfW = (40.3 / 68) * 50;           // ~29.632 (in %-y)
                const boxMinY = 50 - boxHalfW;               // ~20.368
                const boxMaxY = 50 + boxHalfW;               // ~79.632
                oppShots = oppShots.filter(e => {
                    const x = Number(e.x_coord);
                    const y = Number(e.y_coord);
                    if (!Number.isFinite(x) || !Number.isFinite(y)) return false;
                    // In unseren team-orientierten Events ist das Angriffstor bei x=100.
                    // Box liegt daher bei x in [100-boxDepth, 100].
                    return x >= (100 - boxDepth) && x <= 100 && y >= boxMinY && y <= boxMaxY;
                });
            }

            allActions = oppShots.map(e => ({
                ...e,
                // Zugelassene Schüsse: Rohkoordinaten beibehalten (team-orientiert).
                // Die Visualisierung (bottom->top) wird im Canvas-Mapping erzwungen.
                x: Number(e.x_coord),
                y: Number(e.y_coord),
                end_x: e.end_x == null ? null : Number(e.end_x),
                end_y: e.end_y == null ? null : Number(e.end_y),
                type: e.event_type
            })).filter(p => Number.isFinite(p.x) && Number.isFinite(p.y));
        }

        // Gegen den Ball -> Chance Prevention -> Box Entries
        // Visualisierung soll zugelassene Box-Entries (Gegner) zeigen: erfolgreiche Pässe in die Box.
        if (currentMainPhase === 'gegen-ball' && activeGegenBallGroup === 'chance' && currentPhase === 'box-entries') {
            const matchIds = new Set((teamEvents || []).map(e => e.match_id));
            const boxDepth = (16.5 / 105) * 100;         // ~15.714
            const boxStartX = 100 - boxDepth;            // ~84.3 (Box nahe x=100 aus Sicht des angreifenden Teams)
            const boxHalfW = (40.3 / 68) * 50;           // ~29.632
            const boxMinY = 50 - boxHalfW;               // ~20.368
            const boxMaxY = 50 + boxHalfW;               // ~79.632

            const oppBoxEntries = (eventDataset || [])
                .filter(e => matchIds.has(e.match_id))
                .filter(e => e && e.team && e.team !== currentTeam)
                .filter(e => e.event_type === 'Pass' && e.outcome === 'Successful')
                .filter(e => e.x_coord != null && e.y_coord != null && e.end_x != null && e.end_y != null)
                .filter(e => {
                    const ex = Number(e.end_x);
                    const ey = Number(e.end_y);
                    if (!Number.isFinite(ex) || !Number.isFinite(ey)) return false;
                    return ex >= boxStartX && ex <= 100 && ey >= boxMinY && ey <= boxMaxY;
                });

            allActions = oppBoxEntries.map(e => ({
                ...e,
                // Rohkoordinaten beibehalten (team-orientiert). Visualisierung erzwingt bottom->top.
                x: Number(e.x_coord),
                y: Number(e.y_coord),
                end_x: Number(e.end_x),
                end_y: Number(e.end_y),
                type: e.event_type
            })).filter(p => Number.isFinite(p.x) && Number.isFinite(p.y) && Number.isFinite(p.end_x) && Number.isFinite(p.end_y));
        }

        // Gegen den Ball -> Chance Prevention -> Flanken
        // Visualisierung soll alle zugelassenen Flanken (Gegner) zeigen.
        if (currentMainPhase === 'gegen-ball' && activeGegenBallGroup === 'chance' && currentPhase === 'cross-defense') {
            const matchIds = new Set((teamEvents || []).map(e => e.match_id));

            const oppCrosses = (eventDataset || [])
                .filter(e => matchIds.has(e.match_id))
                .filter(e => e && e.team && e.team !== currentTeam)
                .filter(e => e.event_type === 'Pass' && e.is_cross === true && e.is_corner !== true)
                .filter(e => e.x_coord != null && e.y_coord != null && e.end_x != null && e.end_y != null);

            allActions = oppCrosses.map(e => ({
                ...e,
                x: Number(e.x_coord),
                y: Number(e.y_coord),
                end_x: Number(e.end_x),
                end_y: Number(e.end_y),
                type: e.event_type
            })).filter(p => Number.isFinite(p.x) && Number.isFinite(p.y) && Number.isFinite(p.end_x) && Number.isFinite(p.end_y));
        }

        // Gegen den Ball -> Chance Prevention -> Gegentore (vormals: standards-against)
        // Zeigt die Position des Torschusses (Goal) + bis zu die letzten zwei erfolgreichen Pässe davor,
        // aber nur solange diese Pässe vom Torschützen-Team sind (Stop bei Teamwechsel).
        if (currentMainPhase === 'gegen-ball' && activeGegenBallGroup === 'chance' && currentPhase === 'standards-against') {
            const matchIds = new Set((teamEvents || []).map(e => String(e.match_id)));
            const byMatch = new Map();
            for (let i = 0; i < (eventDataset || []).length; i++) {
                const e = eventDataset[i];
                if (!e || e.match_id == null) continue;
                const mid = String(e.match_id);
                if (!matchIds.has(mid)) continue;
                if (!byMatch.has(mid)) byMatch.set(mid, []);
                const m = Number(e.minute);
                const s = Number(e.second);
                const t = (Number.isFinite(m) ? m : 0) * 60 + (Number.isFinite(s) ? s : 0);
                byMatch.get(mid).push({ ...e, __t: t, __i: i });
            }

            const out = [];
            for (const [mid, rows] of byMatch.entries()) {
                rows.sort((a, b) => (a.__t - b.__t) || (a.__i - b.__i));
                for (let idx = 0; idx < rows.length; idx++) {
                    const e = rows[idx];
                    const t = String(e?.event_type || e?.type || '');
                    const isGoal = (t === 'Goal' || e?.isGoal === true);
                    if (!isGoal) continue;
                    if (!e.team || e.team === currentTeam) continue; // Gegentor: Team != currentTeam

                    const gx = Number(e.x_coord);
                    const gy = Number(e.y_coord);
                    if (!Number.isFinite(gx) || !Number.isFinite(gy)) continue;

                    // Goal point
                    out.push({
                        kind: 'goal',
                        match_id: mid,
                        team: String(e.team),
                        x_coord: gx,
                        y_coord: gy,
                        minute: e.minute,
                        second: e.second,
                        event_type: 'Goal'
                    });

                    // Lookback for up to 2 successful passes by the scoring team (stop on team change)
                    const scoringTeam = String(e.team);
                    const passes = [];
                    for (let j = idx - 1; j >= 0 && passes.length < 2; j--) {
                        const p = rows[j];
                        if (!p?.team) break;
                        if (String(p.team) !== scoringTeam) break;
                        if (String(p.event_type || '') !== 'Pass') continue;
                        if (String(p.outcome || '') !== 'Successful') continue;
                        const sx = Number(p.x_coord), sy = Number(p.y_coord);
                        const ex = Number(p.end_x), ey = Number(p.end_y);
                        if (!Number.isFinite(sx) || !Number.isFinite(sy) || !Number.isFinite(ex) || !Number.isFinite(ey)) continue;
                        passes.push({
                            kind: 'prepass',
                            match_id: mid,
                            team: scoringTeam,
                            x_coord: sx,
                            y_coord: sy,
                            end_x: ex,
                            end_y: ey,
                            event_type: 'Pass',
                            outcome: 'Successful'
                        });
                    }

                    // Draw older pass first
                    passes.reverse();
                    out.push(...passes);
                }
            }
            allActions = out;
        }

        // Gegen den Ball -> Chance Prevention -> Box Defense
        // Visualisierung: Blocks + Clearances im eigenen Strafraum
        if (currentMainPhase === 'gegen-ball' && activeGegenBallGroup === 'chance' && currentPhase === 'box-defense') {
            const boxDepth = (16.5 / 105) * 100;         // ~15.714
            const boxHalfW = (40.3 / 68) * 50;           // ~29.632
            const boxMinY = 50 - boxHalfW;               // ~20.368
            const boxMaxY = 50 + boxHalfW;               // ~79.632

            const inBox = (e) => {
                const x = Number(e?.x_coord);
                const y = Number(e?.y_coord);
                if (!Number.isFinite(x) || !Number.isFinite(y)) return false;
                // Eigener Strafraum liegt bei x in [0, boxDepth]
                return x >= 0 && x <= boxDepth && y >= boxMinY && y <= boxMaxY;
            };

            const isBlock = (e) => {
                const t = String(e?.event_type || '');
                return t === 'Block' || t === 'BlockedPass';
            };
            const isClearance = (e) => String(e?.event_type || '') === 'Clearance';

            const actions = (teamEvents || [])
                .filter(e => e && e.x_coord != null && e.y_coord != null)
                .filter(e => isBlock(e) || isClearance(e))
                .filter(inBox);

            allActions = actions.map(e => ({
                ...e,
                x: Number(e.x_coord),
                y: Number(e.y_coord),
                type: e.event_type
            })).filter(a => Number.isFinite(a.x) && Number.isFinite(a.y));
        }
        document.getElementById('analysis-title').textContent = currentTeam;

        // Spielaufbau: Grundstruktur = Struktur-Linien, Pässe = Passnetz (PitchViz)
        if (currentPhase === 'grundstruktur') {
            const canvas = document.getElementById('action-canvas');
            if (pitchVizInstance) { try { pitchVizInstance.destroy(); } catch(e) {} pitchVizInstance = null; }
            // Mark canvas as 'special map' for coords UI
            pitchVizInstance = { destroy: () => {} };

            const parent = canvas.parentElement;
            canvas.width = parent.clientWidth;
            canvas.height = parent.clientHeight;
            const ctx = canvas.getContext('2d');

            // Pitch (simple)
            (function drawBasePitch(ctx, w, h) {
                ctx.clearRect(0, 0, w, h);
                ctx.strokeStyle = '#6b7280';
                ctx.lineWidth = Math.max(1, w * 0.005);
                ctx.lineCap = 'round';
                ctx.strokeRect(0, 0, w, h);
                ctx.beginPath(); ctx.moveTo(0, h / 2); ctx.lineTo(w, h / 2); ctx.stroke();
                ctx.beginPath(); ctx.arc(w / 2, h / 2, w * 0.2, 0, 2 * Math.PI); ctx.stroke();
                const pbH = h * (16.5 / 105), pbW = w * (40.3 / 68), pbX = (w - pbW) / 2;
                ctx.strokeRect(pbX, 0, pbW, pbH);
                ctx.strokeRect(pbX, h - pbH, pbW, pbH);
                const gbH = h * (5.5 / 105), gbW = w * (18.32 / 68), gbX = (w - gbW) / 2;
                ctx.strokeRect(gbX, 0, gbW, gbH);
                ctx.strokeRect(gbX, h - gbH, gbW, gbH);
            })(ctx, canvas.width, canvas.height);

            // Häufigste Start-Formation (falls vorhanden)
            const topForm = getMostUsedStartingFormation(currentTeam, currentGameCount);

            // Wenn Formation vorhanden: schematische Formation (Spielrichtung oben -> unten) zeichnen
            const formationParts = (topForm && topForm.formation) ? parseFormationParts(topForm.formation) : null;
            if (formationParts && formationParts.length) {
                const w = canvas.width;
                const h = canvas.height;
                const outfieldTotal = formationParts.reduce((a, b) => a + b, 0);
                const addGK = (outfieldTotal <= 10);
                const gkCount = addGK ? 1 : 0;
                const lines = addGK ? [gkCount, ...formationParts] : [...formationParts];

                // Vertikale Abstände dynamisch je nach Ebenenanzahl
                const lineCount = lines.length;
                // Formation bewusst höher platzieren: Stürmer nicht zu tief in der gegnerischen Hälfte
                const areaTop = Math.max(h * 0.16, 34);
                const areaHeight = Math.max(1, Math.min(h * 0.52, h - areaTop - Math.max(18, h * 0.06)));
                const yForLine = (i) => {
                    if (lineCount <= 1) return areaTop + areaHeight / 2;
                    return areaTop + (areaHeight * (i / (lineCount - 1)));
                };

                const sidePad = Math.max(w * 0.12, 18);
                const usableW = Math.max(1, (w - 2 * sidePad));
                const xForPlayer = (n, idx) => sidePad + ((idx + 0.5) * (usableW / n));

                const baseR = Math.min(Math.max(w * 0.016, 5.0), 12.0);
                ctx.save();
                ctx.fillStyle = 'rgba(17,24,39,0.62)';
                ctx.strokeStyle = 'rgba(255,255,255,0.88)';
                ctx.lineWidth = 1.3;

                for (let li = 0; li < lineCount; li++) {
                    const n = Math.max(1, Number(lines[li] || 0));
                    const y = yForLine(li);
                    for (let pi = 0; pi < n; pi++) {
                        const x = xForPlayer(n, pi);
                        ctx.beginPath();
                        ctx.arc(x, y, baseR, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.stroke();
                    }
                }
                ctx.restore();

                // In diesem Modus keine weiteren Struktur-/Ballbesitz-Dots zeichnen
            } else {

                // Ballbesitz-Events (für Struktur + Formation)
                const inPossessionEventTypes = new Set(['Pass', 'Carry', 'TakeOn', 'BallTouch', 'Shot', 'Goal', 'MissedShots', 'SavedShot']);
                const inPossessionEvents = (teamEvents || []).filter(e => inPossessionEventTypes.has(e.event_type));

                // Struktur-Metriken (über erfolgreiche Pässe, damit Ballbesitz stabiler approximiert wird)
                const succPasses = inPossessionEvents
                    .filter(e => e.event_type === 'Pass' && e.outcome === 'Successful' && e.x_coord != null && e.y_coord != null)
                    .map(e => ({
                        x: Number(e.x_coord),
                        y: Number(e.y_coord)
                    }))
                    .filter(p => Number.isFinite(p.x) && Number.isFinite(p.y));

                // Grundformation im Ballbesitz: Ø Spielerpositionen (ohne Namen)
                // Wenn Formationen vorhanden sind: auf Startelf pro Match einschränken
                const matchIdsForFormation = new Set(getMatchIdsForTeam(currentTeam, currentGameCount).map(String));
                const startingXIByMatch = buildStartingXIByMatch(currentTeam, matchIdsForFormation);
                const avgPlayerPositions = (() => {
                    const acc = new Map();
                    for (const e of inPossessionEvents) {
                        const pid = e.playerId;
                        if (pid == null) continue;
                        if (startingXIByMatch && startingXIByMatch.size) {
                            const mid = String(e.match_id ?? '');
                            const allowed = startingXIByMatch.get(mid);
                            if (allowed && !allowed.has(Number(pid))) continue;
                        }
                        if (e.x_coord == null || e.y_coord == null) continue;
                        const x = Number(e.x_coord);
                        const y = Number(e.y_coord);
                        if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
                        const k = Number(pid);
                        const cur = acc.get(k) || { pid: k, sx: 0, sy: 0, n: 0 };
                        cur.sx += x;
                        cur.sy += y;
                        cur.n += 1;
                        acc.set(k, cur);
                    }
                    const arr = [...acc.values()]
                        .filter(o => o.n >= 3)
                        .sort((a, b) => b.n - a.n)
                        .slice(0, 11)
                        .map(o => ({ x: o.sx / o.n, y: o.sy / o.n, n: o.n }));
                    return arr;
                })();

                if (!succPasses.length && !avgPlayerPositions.length) {
                    ctx.save();
                    ctx.fillStyle = '#6b7280';
                    ctx.font = '600 12px Inter, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('Keine Ballbesitz-Daten', canvas.width / 2, canvas.height / 2);
                    ctx.restore();
                } else {
                const mean = (arr) => arr.length ? (arr.reduce((a, b) => a + b, 0) / arr.length) : null;
                const std = (arr) => {
                    if (arr.length < 2) return 0;
                    const m = mean(arr);
                    const v = arr.reduce((a, b) => a + (b - m) * (b - m), 0) / (arr.length - 1);
                    return Math.sqrt(v);
                };
                const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

                const meanX = mean(succPasses.map(p => p.x)); // 0..100 (unten->oben)
                const meanY = mean(succPasses.map(p => p.y)); // 0..100 (links->rechts)
                const stdY = std(succPasses.map(p => p.y));

                const toCanvas = (xRaw, yRaw) => {
                    const x = Number(xRaw);
                    const y = Number(yRaw);
                    if (needsInversion) {
                        // Gegner: oben -> unten, 180° gedreht
                        return {
                            cx: (100 - y) * (canvas.width / 100),
                            cy: x * (canvas.height / 100)
                        };
                    }
                    // eigenes Team: unten -> oben
                    return {
                        cx: y * (canvas.width / 100),
                        cy: (100 - x) * (canvas.height / 100)
                    };
                };

                const heightX = clamp(meanX ?? 50, 0, 100);
                const leftY = clamp((meanY ?? 50) - stdY, 0, 100);
                const rightY = clamp((meanY ?? 50) + stdY, 0, 100);

                const BLUE = 'rgba(10,63,134,0.75)';
                const GREY = 'rgba(107,114,128,0.55)';

                // Ø Höhe: horizontale Linie
                ctx.save();
                ctx.setLineDash([6, 6]);
                ctx.strokeStyle = BLUE;
                ctx.lineWidth = Math.min(Math.max(1.5, canvas.width * 0.0045), 3.5);
                const yPix = toCanvas(heightX, 50).cy;
                ctx.beginPath();
                ctx.moveTo(0, yPix);
                ctx.lineTo(canvas.width, yPix);
                ctx.stroke();
                ctx.restore();

                // Teambreite: zwei vertikale Linien (meanY ± std)
                ctx.save();
                ctx.setLineDash([6, 6]);
                ctx.strokeStyle = GREY;
                ctx.lineWidth = Math.min(Math.max(1.2, canvas.width * 0.0038), 3.0);
                const xLeft = toCanvas(50, leftY).cx;
                const xRight = toCanvas(50, rightY).cx;
                ctx.beginPath(); ctx.moveTo(xLeft, 0); ctx.lineTo(xLeft, canvas.height); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(xRight, 0); ctx.lineTo(xRight, canvas.height); ctx.stroke();
                ctx.restore();

                    // Formation: Ø Spielerpositionen (Dots ohne Namen)
                    if (avgPlayerPositions.length) {
                    ctx.save();
                    const ns = avgPlayerPositions.map(p => Number(p.n || 0)).filter(n => Number.isFinite(n) && n > 0);
                    const nMin = ns.length ? Math.min(...ns) : 1;
                    const nMax = ns.length ? Math.max(...ns) : 1;
                    const baseMinR = Math.min(Math.max(canvas.width * 0.010, 4.0), 7.5);
                    const baseMaxR = Math.min(Math.max(canvas.width * 0.018, 6.0), 12.0);
                    const scaleR = (n) => {
                        if (!Number.isFinite(n) || n <= 0) return baseMinR;
                        if (nMax === nMin) return (baseMinR + baseMaxR) / 2;
                        const t = (Math.sqrt(n) - Math.sqrt(nMin)) / (Math.sqrt(nMax) - Math.sqrt(nMin));
                        return baseMinR + (baseMaxR - baseMinR) * Math.max(0, Math.min(1, t));
                    };
                    ctx.fillStyle = 'rgba(17,24,39,0.55)';
                    ctx.strokeStyle = 'rgba(255,255,255,0.85)';
                    ctx.lineWidth = 1.2;
                    for (const p of avgPlayerPositions) {
                        const pt = toCanvas(p.x, p.y);
                        const r = scaleR(Number(p.n || 0));
                        ctx.beginPath();
                        ctx.arc(pt.cx, pt.cy, r, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.stroke();
                    }
                    ctx.restore();
                }
                }
            }
        } else if (currentPhase === 'paesse') {
            const canvas = document.getElementById('action-canvas');
            const statsEl = null;
            if (pitchVizInstance) { try { pitchVizInstance.destroy(); } catch(e) {} pitchVizInstance = null; }
            if (window.PitchViz) {
                pitchVizInstance = await PitchViz.renderAveragePositionsAndNetwork({
                    canvas,
                    statsEl,
                    teamName: currentTeam,
                    eventsData: vizTeamEvents,
                    formationsPath: null,
                    passNetwork: { enabled: true },
                    label: { lastName: true, color: '#111827', weight: 600 }
                });
            } else {
                updateActionCanvas(allActions);
            }
        } else if (currentPhase === 'abstöße') {
            const canvas = document.getElementById('action-canvas');
            if (pitchVizInstance) { try { pitchVizInstance.destroy(); } catch(e) {} pitchVizInstance = null; }
            if (window.PitchViz) {
                const statsEl = document.getElementById('gk-stats');
                pitchVizInstance = await PitchViz.renderGoalKicksMap({
                    canvas,
                    // coordsEl weglassen, wir nutzen unseren eigenen Listener
                    statsEl,
                    teamName: currentTeam,
                    eventsData: vizTeamEvents,
                    showAvgLength: false
                });
            } else {
                // Fallback: normales Canvas-Update
                updateActionCanvas(allActions);
            }
        } else if (currentPhase === 'progressive-pässe') {
            const canvas = document.getElementById('action-canvas');
            if (pitchVizInstance) { try { pitchVizInstance.destroy(); } catch(e) {} pitchVizInstance = null; }
            // Info-Blöcke bei Progressive Pässe nicht neu aufbauen, um vorhandene Accordion-Zustände zu erhalten.
            const statsEl = document.getElementById('pp-stats');
            const btnZones = document.getElementById('pp-zones');
            const btnArrows = document.getElementById('pp-arrows');
            const setActive = (mode) => {
                if (!btnZones || !btnArrows) return;
                [btnZones, btnArrows].forEach(b => b.classList.remove('bg-[#0A3F86]', 'text-white'));
                if (mode === 'zones') btnZones.classList.add('bg-[#0A3F86]', 'text-white');
                else btnArrows.classList.add('bg-[#0A3F86]', 'text-white');
            };
            if (window.PitchViz) {
                pitchVizInstance = await PitchViz.renderProgressivePassesMap({
                    canvas,
                    statsEl,
                    teamName: currentTeam,
                    // Progressive Passes in PitchViz already do their own coordinate mapping.
                    // Passing pre-rotated events would double-invert the rendering.
                    // Exclude corners from progressive pass visualization.
                    eventsData: teamEvents.filter(e => e.is_corner !== true),
                    viewMode: (globalViewMode === 'zones' ? 'zones' : 'arrows'),
                    orientation: (needsInversion ? 'top-to-bottom' : 'bottom-to-top')
                });
                setActive(globalViewMode === 'zones' ? 'zones' : 'arrows');
                setGlobalViewActive(globalViewMode);
                if (btnZones && btnArrows) {
                    btnZones.onclick = () => { if (pitchVizInstance?.setViewMode) { pitchVizInstance.setViewMode('zones'); setActive('zones'); globalViewMode = 'zones'; setGlobalViewActive('zones'); } };
                    btnArrows.onclick = () => { if (pitchVizInstance?.setViewMode) { pitchVizInstance.setViewMode('arrows'); setActive('arrows'); globalViewMode = 'detail'; setGlobalViewActive('detail'); } };
                }
            } else {
                updateActionCanvas(allActions);
            }
        } else if (currentPhase === 'ballbesitz') {
            // Ballbesitz: Territory Plot wird in updateActionCanvas() (Wide-View) gerendert.
            if (pitchVizInstance) { try { pitchVizInstance.destroy(); } catch(e) {} pitchVizInstance = null; }
            updateActionCanvas(teamEvents);
        } else if (currentPhase === 'switch-rate') {
            // Switch Rate: Spielverlagerungen als Pfeile (erfolgreich blau, sonst rot)
            const canvas = document.getElementById('action-canvas');
            if (pitchVizInstance) { try { pitchVizInstance.destroy(); } catch(e) {} pitchVizInstance = null; }
            pitchVizInstance = { destroy: () => {} };

            const parent = canvas.parentElement;
            canvas.width = parent.clientWidth;
            canvas.height = parent.clientHeight;
            const ctx = canvas.getContext('2d');

            const rows = 16, cols = 12;
            const cellH = canvas.height / rows;
            const cellW = canvas.width / cols;

            // Pitch (simple)
            (function drawBasePitch(ctx, w, h) {
                ctx.clearRect(0, 0, w, h);
                ctx.strokeStyle = '#6b7280';
                ctx.lineWidth = Math.max(1, w * 0.005);
                ctx.lineCap = 'round';
                ctx.strokeRect(0, 0, w, h);
                ctx.beginPath(); ctx.moveTo(0, h / 2); ctx.lineTo(w, h / 2); ctx.stroke();
                ctx.beginPath(); ctx.arc(w / 2, h / 2, w * 0.2, 0, 2 * Math.PI); ctx.stroke();
                const pbH = h * (16.5 / 105), pbW = w * (40.3 / 68), pbX = (w - pbW) / 2;
                ctx.strokeRect(pbX, 0, pbW, pbH);
                ctx.strokeRect(pbX, h - pbH, pbW, pbH);
                const gbH = h * (5.5 / 105), gbW = w * (18.32 / 68), gbX = (w - gbW) / 2;
                ctx.strokeRect(gbX, 0, gbW, gbH);
                ctx.strokeRect(gbX, h - gbH, gbW, gbH);

                // 16x12 Raster
                ctx.save();
                ctx.strokeStyle = 'rgba(156,163,175,0.35)';
                ctx.setLineDash([4, 4]);
                for (let i = 1; i < rows; i++) {
                    ctx.beginPath();
                    ctx.moveTo(0, i * (h / rows));
                    ctx.lineTo(w, i * (h / rows));
                    ctx.stroke();
                }
                for (let j = 1; j < cols; j++) {
                    ctx.beginPath();
                    ctx.moveTo(j * (w / cols), 0);
                    ctx.lineTo(j * (w / cols), h);
                    ctx.stroke();
                }
                ctx.restore();
            })(ctx, canvas.width, canvas.height);

            const BLUE = 'rgba(10,63,134,0.85)';
            const RED = 'rgba(239,68,68,0.85)';
            const GREY = 'rgba(107,114,128,0.35)';
            const ZONE_GREY = 'rgba(156,163,175,0.06)';

            const toCanvas = (xRaw, yRaw) => {
                const x = Number(xRaw);
                const y = Number(yRaw);
                if (needsInversion) {
                    return {
                        cx: (100 - y) * (canvas.width / 100),
                        cy: x * (canvas.height / 100)
                    };
                }
                return {
                    cx: y * (canvas.width / 100),
                    cy: (100 - x) * (canvas.height / 100)
                };
            };

            function drawArrow(sx, sy, ex, ey, color) {
                const dx = ex - sx;
                const dy = ey - sy;
                const ang = Math.atan2(dy, dx);
                const lw = Math.min(Math.max(1.4, canvas.width * 0.004), 3.5);
                const ah = Math.min(10, Math.max(6, canvas.width * 0.02));

                ctx.strokeStyle = color;
                ctx.lineWidth = lw;
                ctx.beginPath();
                ctx.moveTo(sx, sy);
                ctx.lineTo(ex, ey);
                ctx.stroke();

                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.moveTo(ex, ey);
                ctx.lineTo(ex - ah * Math.cos(ang - Math.PI / 7), ey - ah * Math.sin(ang - Math.PI / 7));
                ctx.lineTo(ex - ah * Math.cos(ang + Math.PI / 7), ey - ah * Math.sin(ang + Math.PI / 7));
                ctx.closePath();
                ctx.fill();
            }

            const passes = (teamEvents || [])
                .filter(e => e.event_type === 'Pass')
                .filter(e => e.x_coord != null && e.y_coord != null && e.end_x != null && e.end_y != null);

            const yDisp = (y) => needsInversion ? (100 - Number(y)) : Number(y);
            const isLeft = (y) => yDisp(y) < 33.3;
            const isRight = (y) => yDisp(y) >= 66.6;
            const switches = passes.filter(p => {
                const ys = Number(p.y_coord);
                const ye = Number(p.end_y);
                if (!Number.isFinite(ys) || !Number.isFinite(ye)) return false;
                return (isLeft(ys) && isRight(ye)) || (isRight(ys) && isLeft(ye));
            });

            // Darstellung: Detail = Pfeile farbig + Zonen leicht ausgegraut
            //             Zonen  = Pfeile grau + Zonen blau eingefärbt (Heatmap)
            if (globalViewMode === 'zones') {
                const counts = Array.from({ length: rows }, () => Array(cols).fill(0));
                for (const p of switches) {
                    const end = toCanvas(p.end_x, p.end_y);
                    const r = Math.min(rows - 1, Math.max(0, Math.floor(end.cy / cellH)));
                    const c = Math.min(cols - 1, Math.max(0, Math.floor(end.cx / cellW)));
                    counts[r][c] += 1;
                }
                const maxV = Math.max(1, ...counts.map(row => Math.max(0, ...row)));
                ctx.save();
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        const v = counts[r][c];
                        if (v <= 0) continue;
                        const t = v / maxV;
                        const alpha = 0.10 + 0.55 * t;
                        ctx.fillStyle = `rgba(10,63,134,${alpha.toFixed(3)})`;
                        ctx.fillRect(c * cellW, r * cellH, cellW, cellH);
                    }
                }
                ctx.restore();
            } else {
                // leichte graue Zonen-Hinterlegung
                ctx.save();
                ctx.fillStyle = ZONE_GREY;
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        ctx.fillRect(c * cellW, r * cellH, cellW, cellH);
                    }
                }
                ctx.restore();
            }

            if (!switches.length) {
                ctx.save();
                ctx.fillStyle = '#6b7280';
                ctx.font = '600 12px Inter, sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('Keine Spielverlagerungen', canvas.width / 2, canvas.height / 2);
                ctx.restore();
            } else {
                const succ = switches.filter(s => s.outcome === 'Successful');
                const fail = switches.filter(s => s.outcome !== 'Successful');

                ctx.save();
                ctx.globalAlpha = 0.9;
                if (globalViewMode === 'zones') {
                    // Pfeile grau (ausgegraut)
                    for (const p of switches) {
                        const s = toCanvas(p.x_coord, p.y_coord);
                        const e = toCanvas(p.end_x, p.end_y);
                        drawArrow(s.cx, s.cy, e.cx, e.cy, GREY);
                    }
                } else {
                    // Detail: erst rot, dann blau oben drauf
                    for (const p of fail) {
                        const s = toCanvas(p.x_coord, p.y_coord);
                        const e = toCanvas(p.end_x, p.end_y);
                        drawArrow(s.cx, s.cy, e.cx, e.cy, RED);
                    }
                    for (const p of succ) {
                        const s = toCanvas(p.x_coord, p.y_coord);
                        const e = toCanvas(p.end_x, p.end_y);
                        drawArrow(s.cx, s.cy, e.cx, e.cy, BLUE);
                    }
                }
                ctx.restore();
            }

        } else if (currentPhase === 'angriffsseite') {
            // Mustererkennung-Viz: Eintritte ins letzte Drittel auf Canvas darstellen
            const canvas = document.getElementById('action-canvas');
            // Mark canvas as 'special map' so coords display uses inverted x like pitch maps
            if (pitchVizInstance) { try { pitchVizInstance.destroy(); } catch(e) {} }
            pitchVizInstance = { destroy: () => {} };

            const parent = canvas.parentElement;
            canvas.width = parent.clientWidth;
            canvas.height = parent.clientHeight;
            const ctx = canvas.getContext('2d');

            // Spielfeld zeichnen (eigenes Team: oben = letztes Drittel; Gegner: unten = letztes Drittel)
            (function drawPitch(ctx, w, h) {
                ctx.clearRect(0, 0, w, h);
                ctx.strokeStyle = '#6b7280';
                ctx.lineWidth = Math.max(1, w * 0.005);
                ctx.lineCap = 'round';
                // Außenrahmen
                ctx.strokeRect(0, 0, w, h);
                // Mittellinie
                ctx.beginPath(); ctx.moveTo(0, h/2); ctx.lineTo(w, h/2); ctx.stroke();
                // Mittelkreis
                ctx.beginPath(); ctx.arc(w/2, h/2, w*0.2, 0, 2*Math.PI); ctx.stroke();
                // Strafräume
                const pbH = h*(16.5/105), pbW = w*(40.3/68), pbX = (w-pbW)/2;
                ctx.strokeRect(pbX, 0, pbW, pbH); // oben
                ctx.strokeRect(pbX, h-pbH, pbW, pbH); // unten
                // Letztes Drittel highlight + 12x8 Raster
                const topH = ((100 - 66.6)/100)*h; // 33.4%
                const y0 = needsInversion ? (h - topH) : 0;
                ctx.fillStyle = 'rgba(10,63,134,0.06)';
                ctx.fillRect(0, y0, w, topH);
                // 12x8 Raster nur im letzten Drittel
                ctx.save();
                ctx.strokeStyle = 'rgba(156,163,175,0.35)';
                ctx.setLineDash([4,4]);
                const rws = 8, cls = 12; const cellH = topH / rws; const cellW = w / cls;
                for (let i=1; i<rws; i++) { ctx.beginPath(); ctx.moveTo(0, y0 + i*cellH); ctx.lineTo(w, y0 + i*cellH); ctx.stroke(); }
                ctx.beginPath(); ctx.rect(0, y0, w, topH); ctx.clip();
                for (let j=1; j<cls; j++) { ctx.beginPath(); ctx.moveTo(j*cellW, y0); ctx.lineTo(j*cellW, y0 + topH); ctx.stroke(); }
                ctx.restore();
            })(ctx, canvas.width, canvas.height);

            // Mapping abhängig von Spielrichtung
            const toCanvas = (xRaw, yRaw) => {
                const x = Number(xRaw);
                const y = Number(yRaw);
                if (needsInversion) {
                    return { cx: (100 - y) * (canvas.width/100), cy: x * (canvas.height/100) };
                }
                return { cx: y * (canvas.width/100), cy: (100 - x) * (canvas.height/100) };
            };
            const yDisp = (y) => needsInversion ? (100 - Number(y)) : Number(y);
            const colorForSide = (y) => {
                const yy = yDisp(y);
                return yy < 33.3 ? 'rgba(16,185,129,0.8)' : (yy < 66.6 ? 'rgba(10,63,134,0.85)' : 'rgba(249,115,22,0.85)');
            };
            // Eintritte: end_x >= 66.6 und Start außerhalb
            const entryPasses = teamEvents.filter(e => e.event_type === 'Pass' && e.end_x != null && e.end_y != null && Number(e.end_x) >= 66.6 && Number(e.x_coord) < 66.6);
            ctx.lineCap = 'round';
            const grey = 'rgba(107,114,128,0.35)';
            entryPasses.forEach(p => {
                const { cx: sx, cy: sy } = toCanvas(p.x_coord, p.y_coord);
                const { cx: ex, cy: ey } = toCanvas(p.end_x, p.end_y);
                const dx = ex - sx, dy = ey - sy; const L = Math.max(1, Math.hypot(dx, dy));
                const lw = Math.min(Math.max(1.5, L * 0.004), 4);
                const col = (globalViewMode === 'zones') ? grey : colorForSide(Number(p.end_y));
                ctx.strokeStyle = col; ctx.lineWidth = lw; ctx.globalAlpha = 0.8;
                ctx.beginPath(); ctx.moveTo(sx, sy); ctx.lineTo(ex, ey); ctx.stroke();
                const ang = Math.atan2(ey - sy, ex - sx); const ah = 8;
                ctx.beginPath();
                ctx.moveTo(ex, ey);
                ctx.lineTo(ex - ah * Math.cos(ang - Math.PI/6), ey - ah * Math.sin(ang - Math.PI/6));
                ctx.lineTo(ex - ah * Math.cos(ang + Math.PI/6), ey - ah * Math.sin(ang + Math.PI/6));
                ctx.closePath(); ctx.fillStyle = col; ctx.fill();
                if (globalViewMode !== 'zones') { ctx.beginPath(); ctx.arc(ex, ey, 2.5, 0, 2*Math.PI); ctx.fillStyle = col; ctx.fill(); }
            });

            // In Zonen-Ansicht: Heatmap-Overlay (12x8) im letzten Drittel, basierend auf Endpunkten
            if (globalViewMode === 'zones') {
                const rows = 8, cols = 12;
                const counts = Array.from({ length: rows }, () => Array(cols).fill(0));
                entryPasses.forEach(p => {
                    const ex = Number(p.end_x);
                    const ey = Number(p.end_y);
                    if (!Number.isFinite(ex) || !Number.isFinite(ey)) return;
                    if (ex < 66.6) return;
                    const frac = needsInversion
                        ? ((ex - 66.6) / (100 - 66.6))
                        : ((100 - ex) / (100 - 66.6));
                    let r = Math.floor(frac * rows);
                    r = Math.min(rows - 1, Math.max(0, r));
                    let c = Math.floor((yDisp(ey) / 100) * cols);
                    c = Math.min(cols - 1, Math.max(0, c));
                    counts[r][c]++;
                });
                const maxV = Math.max(1, ...counts.map(row => Math.max(0, ...row)));
                const topH = ((100 - 66.6)/100)*canvas.height;
                const cellH = topH / rows;
                const cellW = canvas.width / cols;
                const y0 = needsInversion ? (canvas.height - topH) : 0;
                for (let r=0; r<rows; r++) {
                    for (let c=0; c<cols; c++) {
                        const v = counts[r][c]; if (v <= 0) continue;
                        const t = v / maxV; const alpha = 0.08 + 0.55 * t;
                        ctx.fillStyle = `rgba(10,63,134,${alpha.toFixed(3)})`;
                        ctx.fillRect(c*cellW, y0 + r*cellH, cellW, cellH);
                    }
                }
            }

            // Legende unten links
            ctx.save(); ctx.globalAlpha = 0.95; ctx.font = '10px Inter, sans-serif'; ctx.textBaseline = 'top';
            const pads = 6; let ly = canvas.height - 48; const lx = pads;
            const items = [ ['Links', 'rgba(16,185,129,0.9)'], ['Zentrum', 'rgba(10,63,134,0.95)'], ['Rechts', 'rgba(249,115,22,0.95)'] ];
            items.forEach(([label, col]) => { ctx.fillStyle = col; ctx.fillRect(lx, ly + 3, 10, 3); ctx.fillStyle = '#111827'; ctx.fillText(label, lx + 16, ly); ly += 14; });
            ctx.restore();
        } else if (currentPhase === 'abschluesse') {
            // Schusskarte: eigenes Team unten->oben (Ziel oben), Gegner oben->unten (Ziel unten)
            const canvas = document.getElementById('action-canvas');
            if (pitchVizInstance) { try { pitchVizInstance.destroy(); } catch(e) {} pitchVizInstance = null; }

            const parent = canvas.parentElement;
            canvas.width = parent.clientWidth;
            canvas.height = parent.clientHeight;
            const ctx = canvas.getContext('2d');

            // Spielfeld zeichnen (wie bei Angriffsseite), inkl. 12x8-Raster im letzten Drittel
            (function drawShotPitch(ctx, w, h) {
                ctx.clearRect(0, 0, w, h);
                ctx.strokeStyle = '#6b7280';
                ctx.lineWidth = Math.max(1, w * 0.005);
                ctx.lineCap = 'round';
                // Außenrahmen
                ctx.strokeRect(0, 0, w, h);
                // Mittellinie
                ctx.beginPath(); ctx.moveTo(0, h/2); ctx.lineTo(w, h/2); ctx.stroke();
                // Mittelkreis
                ctx.beginPath(); ctx.arc(w/2, h/2, w*0.2, 0, 2*Math.PI); ctx.stroke();
                // Strafräume
                const pbH = h*(16.5/105), pbW = w*(40.3/68), pbX = (w-pbW)/2;
                ctx.strokeRect(pbX, 0, pbW, pbH); // oben (Angriffsziel)
                ctx.strokeRect(pbX, h-pbH, pbW, pbH); // unten

                // Letztes Drittel highlight + gestricheltes 12x8-Raster wie bei Angriffsseite
                const topH = ((100 - 66.6)/100)*h; // oberes Drittel
                const y0 = needsInversion ? (h - topH) : 0;
                ctx.fillStyle = 'rgba(10,63,134,0.06)';
                ctx.fillRect(0, y0, w, topH);

                ctx.save();
                ctx.strokeStyle = 'rgba(156,163,175,0.35)';
                ctx.setLineDash([4,4]);
                const rows = 8, cols = 12;
                const cellH = topH / rows;
                const cellW = w / cols;
                // horizontale Linien im letzten Drittel
                for (let i = 1; i < rows; i++) {
                    ctx.beginPath();
                    ctx.moveTo(0, y0 + i * cellH);
                    ctx.lineTo(w, y0 + i * cellH);
                    ctx.stroke();
                }
                // vertikale Linien im letzten Drittel
                for (let j = 1; j < cols; j++) {
                    ctx.beginPath();
                    ctx.moveTo(j * cellW, y0);
                    ctx.lineTo(j * cellW, y0 + topH);
                    ctx.stroke();
                }
                ctx.restore();
            })(ctx, canvas.width, canvas.height);

            const shotEvents = teamEvents.filter(e => ['Shot','Goal','MissedShots','SavedShot'].includes(e.event_type));
            const yDisp = (y) => needsInversion ? (100 - Number(y)) : Number(y);
            const toCanvas = (xRaw, yRaw) => {
                const x = Number(xRaw);
                const y = Number(yRaw);
                if (needsInversion) {
                    return { cx: (100 - y) * (canvas.width/100), cy: x * (canvas.height/100) };
                }
                return { cx: y * (canvas.width/100), cy: (100 - x) * (canvas.height/100) };
            };

            if (globalViewMode === 'zones') {
                // Zonen-Ansicht: Heatmap der Abschlussherkunft im letzten Drittel (12x8 Raster)
                const rows = 8, cols = 12;
                const counts = Array.from({ length: rows }, () => Array(cols).fill(0));

                shotEvents.forEach(e => {
                    if (e.x_coord == null || e.y_coord == null) return;
                    const xRaw = Number(e.x_coord);
                    if (xRaw < 66.6) return; // nur letztes Drittel
                    const frac = needsInversion
                        ? ((xRaw - 66.6) / (100 - 66.6))
                        : ((100 - xRaw) / (100 - 66.6));
                    let r = Math.floor(frac * rows);
                    r = Math.min(rows - 1, Math.max(0, r));
                    let c = Math.floor((yDisp(e.y_coord) / 100) * cols);
                    c = Math.min(cols - 1, Math.max(0, c));
                    counts[r][c]++;
                });

                const maxV = Math.max(1, ...counts.map(row => Math.max(0, ...row)));
                const topH = ((100 - 66.6)/100)*canvas.height;
                const cellH = topH / rows;
                const cellW = canvas.width / cols;
                const y0 = needsInversion ? (canvas.height - topH) : 0;

                ctx.save();
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        const v = counts[r][c];
                        if (v <= 0) continue;
                        const t = v / maxV;
                        const alpha = 0.1 + 0.55 * t;
                        ctx.fillStyle = `rgba(10,63,134,${alpha.toFixed(3)})`;
                        ctx.fillRect(c * cellW, y0 + r * cellH, cellW, cellH);
                    }
                }
                ctx.restore();
            } else {
                // Detail-Ansicht: einzelne Abschlüsse als Punkte (grün/rot)
                ctx.save();
                shotEvents.forEach(e => {
                    if (e.x_coord == null || e.y_coord == null) return;
                    const pt = toCanvas(e.x_coord, e.y_coord);
                    const isGoal = e.event_type === 'Goal' || e.isGoal === true;
                    ctx.fillStyle = isGoal ? 'rgba(16,185,129,0.9)' : 'rgba(239,68,68,0.9)'; // grün / rot
                    ctx.beginPath();
                    ctx.arc(pt.cx, pt.cy, canvas.width * 0.015, 0, 2 * Math.PI);
                    ctx.fill();
                });
                ctx.restore();
            }
        } else if (currentPhase === 'flanken') {
            // Flankenkarte: alle Flanken als Pfeile (erfolgreich blau, erfolglos rot)
            const canvas = document.getElementById('action-canvas');
            if (pitchVizInstance) { try { pitchVizInstance.destroy(); } catch(e) {} pitchVizInstance = null; }

            const parent = canvas.parentElement;
            canvas.width = parent.clientWidth;
            canvas.height = parent.clientHeight;
            const ctx = canvas.getContext('2d');

            // Pitch wie bei Angriffsseite (Highlight + 12x8 Raster im letzten Drittel)
            (function drawCrossPitch(ctx, w, h) {
                ctx.clearRect(0, 0, w, h);
                ctx.strokeStyle = '#6b7280';
                ctx.lineWidth = Math.max(1, w * 0.005);
                ctx.lineCap = 'round';
                ctx.strokeRect(0, 0, w, h);
                ctx.beginPath(); ctx.moveTo(0, h / 2); ctx.lineTo(w, h / 2); ctx.stroke();
                ctx.beginPath(); ctx.arc(w / 2, h / 2, w * 0.2, 0, 2 * Math.PI); ctx.stroke();
                const pbH = h * (16.5 / 105), pbW = w * (40.3 / 68), pbX = (w - pbW) / 2;
                ctx.strokeRect(pbX, 0, pbW, pbH);
                ctx.strokeRect(pbX, h - pbH, pbW, pbH);
                const gbH = h * (5.5 / 105), gbW = w * (18.32 / 68), gbX = (w - gbW) / 2;
                ctx.strokeRect(gbX, 0, gbW, gbH);
                ctx.strokeRect(gbX, h - gbH, gbW, gbH);

                // letztes Drittel highlight + 12x8 Raster (wie Angriffsseite)
                const topH = ((100 - 66.6) / 100) * h;
                const y0 = needsInversion ? (h - topH) : 0;
                ctx.fillStyle = 'rgba(10,63,134,0.06)';
                ctx.fillRect(0, y0, w, topH);

                ctx.save();
                ctx.strokeStyle = 'rgba(156,163,175,0.35)';
                ctx.setLineDash([4, 4]);
                const rws = 8, cls = 12;
                const cellH = topH / rws;
                const cellW = w / cls;
                for (let i = 1; i < rws; i++) {
                    ctx.beginPath();
                    ctx.moveTo(0, y0 + i * cellH);
                    ctx.lineTo(w, y0 + i * cellH);
                    ctx.stroke();
                }
                for (let j = 1; j < cls; j++) {
                    ctx.beginPath();
                    ctx.moveTo(j * cellW, y0);
                    ctx.lineTo(j * cellW, y0 + topH);
                    ctx.stroke();
                }
                ctx.restore();
            })(ctx, canvas.width, canvas.height);

            const crosses = (teamEvents || [])
                .filter(e => e.event_type === 'Pass' && e.is_cross === true && e.is_corner !== true)
                .filter(e => e.x_coord != null && e.y_coord != null && e.end_x != null && e.end_y != null);

            if (!crosses.length) {
                ctx.save();
                ctx.fillStyle = '#6b7280';
                ctx.font = '600 12px Inter, sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('Keine Flanken', canvas.width / 2, canvas.height / 2);
                ctx.restore();
            } else {
                const toCanvas = (xRaw, yRaw) => {
                    const x = Number(xRaw);
                    const y = Number(yRaw);
                    if (needsInversion) {
                        return { cx: (100 - y) * (canvas.width/100), cy: x * (canvas.height/100) };
                    }
                    return { cx: y * (canvas.width/100), cy: (100 - x) * (canvas.height/100) };
                };
                const yBin = (v) => needsInversion ? (100 - Number(v)) : Number(v);
                const BLUE = 'rgba(10,63,134,0.85)';
                const RED = 'rgba(239,68,68,0.85)';
                const GREY = 'rgba(107,114,128,0.35)';

                function drawArrow(sx, sy, ex, ey, color) {
                    const dx = ex - sx;
                    const dy = ey - sy;
                    const ang = Math.atan2(dy, dx);
                    const lw = Math.min(Math.max(1.4, canvas.width * 0.004), 3.5);
                    const ah = Math.min(10, Math.max(6, canvas.width * 0.02));

                    ctx.strokeStyle = color;
                    ctx.lineWidth = lw;
                    ctx.beginPath();
                    ctx.moveTo(sx, sy);
                    ctx.lineTo(ex, ey);
                    ctx.stroke();

                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.moveTo(ex, ey);
                    ctx.lineTo(ex - ah * Math.cos(ang - Math.PI / 7), ey - ah * Math.sin(ang - Math.PI / 7));
                    ctx.lineTo(ex - ah * Math.cos(ang + Math.PI / 7), ey - ah * Math.sin(ang + Math.PI / 7));
                    ctx.closePath();
                    ctx.fill();
                }

                const succ = crosses.filter(c => c.outcome === 'Successful');
                const fail = crosses.filter(c => c.outcome !== 'Successful');

                ctx.save();
                ctx.globalAlpha = 0.9;
                if (globalViewMode === 'zones') {
                    // wie bei Angriffsseite: graue Pfeile + Heatmap nach Endpunkten im letzten Drittel
                    for (const c of crosses) {
                        const s = toCanvas(c.x_coord, c.y_coord);
                        const e = toCanvas(c.end_x, c.end_y);
                        drawArrow(s.cx, s.cy, e.cx, e.cy, GREY);
                    }

                    const rows = 8, cols = 12;
                    const counts = Array.from({ length: rows }, () => Array(cols).fill(0));
                    crosses.forEach(c => {
                        const ex = Number(c.end_x);
                        const ey = Number(c.end_y);
                        if (!Number.isFinite(ex) || !Number.isFinite(ey)) return;
                        if (ex < 66.6) return; // nur letztes Drittel
                        const frac = needsInversion
                            ? ((ex - 66.6) / (100 - 66.6))
                            : ((100 - ex) / (100 - 66.6));
                        let r = Math.floor(frac * rows);
                        r = Math.min(rows - 1, Math.max(0, r));
                        let col = Math.floor((yBin(ey) / 100) * cols);
                        col = Math.min(cols - 1, Math.max(0, col));
                        counts[r][col]++;
                    });

                    const maxV = Math.max(1, ...counts.map(row => Math.max(0, ...row)));
                    const topH = ((100 - 66.6) / 100) * canvas.height;
                    const cellH = topH / rows;
                    const cellW = canvas.width / cols;
                    const y0 = needsInversion ? (canvas.height - topH) : 0;
                    for (let r = 0; r < rows; r++) {
                        for (let c = 0; c < cols; c++) {
                            const v = counts[r][c];
                            if (v <= 0) continue;
                            const t = v / maxV;
                            const alpha = 0.08 + 0.55 * t;
                            ctx.fillStyle = `rgba(10,63,134,${alpha.toFixed(3)})`;
                            ctx.fillRect(c * cellW, y0 + r * cellH, cellW, cellH);
                        }
                    }
                } else {
                    // Detail: erst rot, dann blau oben drauf
                    for (const c of fail) {
                        const s = toCanvas(c.x_coord, c.y_coord);
                        const e = toCanvas(c.end_x, c.end_y);
                        drawArrow(s.cx, s.cy, e.cx, e.cy, RED);
                    }
                    for (const c of succ) {
                        const s = toCanvas(c.x_coord, c.y_coord);
                        const e = toCanvas(c.end_x, c.end_y);
                        drawArrow(s.cx, s.cy, e.cx, e.cy, BLUE);
                    }
                }
                ctx.restore();
            }
        } else {
            // Andere Phasen: ggf. bestehende PassMap zerstören und Standard zeichnen
            if (pitchVizInstance) { try { pitchVizInstance.destroy(); } catch(e) {} pitchVizInstance = null; }
            updateActionCanvas(allActions);
        }
        } finally {
            isUpdating = false;
        }
    }
    
    function updateActionCanvas(dataPoints) {
        const canvas = document.getElementById('action-canvas');
        const container = canvas.parentElement;
        const coordsDisplay = document.getElementById('coords-display');
        const ballbesitzLegend = document.getElementById('ballbesitz-legend');
        const globalSwitch = document.getElementById('global-view-switch');
        const pitchView = document.getElementById('center-view-pitch');
        const fieldTiltView = document.getElementById('center-view-fieldtilt');
        const ftCanvas = document.getElementById('field-tilt-canvas-ga');
        const ftSummary = document.getElementById('field-tilt-summary-ga');
        const ftHeader = document.getElementById('field-tilt-header-ga');
        const ftFooter = document.getElementById('field-tilt-footer-ga');

        const isFieldTilt = (currentPhase === 'fieldtilt');
        if (pitchView) pitchView.classList.toggle('hidden', isFieldTilt);
        if (fieldTiltView) fieldTiltView.classList.toggle('hidden', !isFieldTilt);
        if (globalSwitch) globalSwitch.classList.toggle('hidden', isFieldTilt);
        if (coordsDisplay && isFieldTilt) coordsDisplay.textContent = '';

        // Field Tilt header/footer are only relevant in the Field Tilt view.
        if (ftCanvas) ftCanvas.classList.toggle('hidden', !isFieldTilt);
        if (ftHeader) ftHeader.classList.toggle('hidden', false);
        if (ftFooter) ftFooter.classList.toggle('hidden', false);

        // Ballbesitz legend under the pitch
        if (ballbesitzLegend) ballbesitzLegend.classList.toggle('hidden', currentPhase !== 'ballbesitz');
        
        // Spielkontrolle: Field Tilt (Zeitverlauf) – exakt wie pitch_test (Card + 220px Chart)
        if (currentPhase === 'fieldtilt') {
            if (!ftCanvas) return;

            // Helpers aus pitch_test
            const FIELD_TILT_TOUCH_EVENTS = new Set(['Pass','TakeOn','BallTouch','Shot','Goal','SavedShot','MissedShots','Carry','Dribble']);

            const eventTimeMinute = (e) => {
                const m = Number(e?.minute);
                const s = Number(e?.second);
                if (!Number.isFinite(m)) return null;
                const sec = Number.isFinite(s) ? s : 0;
                return m + (sec / 60);
            };

            const trailingMovingAverage = (values, windowSize = 10) => {
                const out = new Array(values.length).fill(0);
                for (let i = 0; i < values.length; i++) {
                    let sum = 0;
                    let cnt = 0;
                    const start = Math.max(0, i - windowSize + 1);
                    for (let j = start; j <= i; j++) {
                        const v = values[j];
                        if (!Number.isFinite(v)) continue;
                        sum += v;
                        cnt += 1;
                    }
                    out[i] = cnt ? (sum / cnt) : 0;
                }
                return out;
            };

            const quantile = (values, q) => {
                const arr = (values || []).filter(v => Number.isFinite(v)).sort((a, b) => a - b);
                if (!arr.length) return 0;
                if (arr.length === 1) return arr[0];
                const pos = (arr.length - 1) * q;
                const base = Math.floor(pos);
                const rest = pos - base;
                const a = arr[base];
                const b = arr[Math.min(base + 1, arr.length - 1)];
                return a + rest * (b - a);
            };

            const computeFieldTiltSeries = (allEvents, teamName, matchIds, { maxMinutes = 95 } = {}) => {
                const matchSet = new Set((matchIds || []).map(String));
                const evs = (allEvents || [])
                    .filter(e => e && e.match_id != null && matchSet.has(String(e.match_id)))
                    .filter(e => e.team != null && e.x_coord != null && e.y_coord != null)
                    .filter(e => FIELD_TILT_TOUCH_EVENTS.has(String(e.event_type || '')))
                    .map(e => ({
                        match_id: String(e.match_id),
                        team: String(e.team),
                        x: Number(e.x_coord),
                        tmin: eventTimeMinute(e)
                    }))
                    .filter(e => Number.isFinite(e.x) && Number.isFinite(e.tmin));

                const byMatch = new Map();
                for (const e of evs) {
                    if (!byMatch.has(e.match_id)) byMatch.set(e.match_id, []);
                    byMatch.get(e.match_id).push(e);
                }

                const minutes = Array.from({ length: maxMinutes + 1 }, (_, i) => i); // 0..max
                const matchMaSeries = [];
                const perMatchShares = [];

                for (const [mid, rows] of byMatch.entries()) {
                    const teamCounts = new Array(maxMinutes + 1).fill(0);
                    const oppCounts = new Array(maxMinutes + 1).fill(0);
                    let teamTotal = 0;
                    let oppTotal = 0;

                    for (const r of rows) {
                        if (!(r.x > 66.6)) continue; // Angriffsdrittel (team-orientiert)
                        const mi = Math.max(0, Math.min(maxMinutes, Math.floor(r.tmin)));
                        if (r.team === teamName) {
                            teamCounts[mi] += 1;
                            teamTotal += 1;
                        } else {
                            oppCounts[mi] += 1;
                            oppTotal += 1;
                        }
                    }

                    const denomTotal = teamTotal + oppTotal;
                    if (denomTotal > 0) {
                        const teamPct = (teamTotal / denomTotal) * 100;
                        perMatchShares.push(teamPct);
                    }

                    const diffPerMinute = new Array(maxMinutes + 1).fill(0);
                    for (let i = 0; i < minutes.length; i++) {
                        const denom = teamCounts[i] + oppCounts[i];
                        diffPerMinute[i] = denom ? (2 * ((teamCounts[i] / denom) * 100) - 100) : 0;
                    }
                    matchMaSeries.push(trailingMovingAverage(diffPerMinute, 10));
                }

                const q25 = minutes.map((_, i) => quantile(matchMaSeries.map(s => s[i]), 0.25));
                const q50 = minutes.map((_, i) => quantile(matchMaSeries.map(s => s[i]), 0.50));
                const q75 = minutes.map((_, i) => quantile(matchMaSeries.map(s => s[i]), 0.75));

                const teamPctAvg = perMatchShares.length ? (perMatchShares.reduce((a, v) => a + v, 0) / perMatchShares.length) : null;
                const oppPctAvg = teamPctAvg != null ? (100 - teamPctAvg) : null;

                return { minutes, q25, q50, q75, teamPctAvg, oppPctAvg, nMatches: matchMaSeries.length };
            };

            const drawFieldTiltChart = (canvasEl, series, { teamName } = {}) => {
                if (!canvasEl || !series) return;
                const parent = canvasEl.parentElement;
                const w = parent.clientWidth;
                const h = parent.clientHeight;
                canvasEl.width = w;
                canvasEl.height = h;

                const ctx = canvasEl.getContext('2d');
                ctx.clearRect(0, 0, w, h);

                const padL = 34;
                const padR = 10;
                const padT = 10;
                const padB = 22;
                const iw = Math.max(1, w - padL - padR);
                const ih = Math.max(1, h - padT - padB);

                const yToPx = (v) => {
                    const vv = Math.max(-100, Math.min(100, v));
                    const t = (100 - vv) / 200;
                    return padT + t * ih;
                };
                const xToPx = (min) => {
                    const t = series.minutes.length > 1 ? (min / (series.minutes[series.minutes.length - 1] || 1)) : 0;
                    return padL + t * iw;
                };

                // Grid lines
                ctx.save();
                ctx.strokeStyle = 'rgba(156,163,175,0.35)';
                ctx.lineWidth = 1;
                const yTicks = [-100, -50, 0, 50, 100];
                for (const yt of yTicks) {
                    const y = yToPx(yt);
                    ctx.beginPath();
                    ctx.moveTo(padL, y);
                    ctx.lineTo(padL + iw, y);
                    ctx.stroke();
                }
                ctx.restore();

                // 0-line dashed
                const y0 = yToPx(0);
                ctx.save();
                ctx.strokeStyle = 'rgba(17,24,39,0.9)';
                ctx.lineWidth = 2;
                ctx.setLineDash([6, 4]);
                ctx.beginPath();
                ctx.moveTo(padL, y0);
                ctx.lineTo(padL + iw, y0);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.restore();

                // Y-axis labels
                ctx.save();
                ctx.fillStyle = 'rgba(107,114,128,0.9)';
                ctx.font = '10px Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';
                for (const yt of yTicks) {
                    ctx.fillText(String(yt), padL - 6, yToPx(yt));
                }
                ctx.restore();

                const q25 = series.q25 || [];
                const q50 = series.q50 || [];
                const q75 = series.q75 || [];

                const HSV_BLUE = '#0A3F86';
                const RED = '#ef4444';
                const POS_FILL_A = 0.20;
                const NEG_FILL_A = 0.22;
                const POS_BAND_A = 0.14;
                const NEG_BAND_A = 0.14;

                const hasSpread = (() => {
                    if (!q25.length || !q75.length) return false;
                    for (let i = 0; i < q25.length; i++) {
                        if (Math.abs(q75[i] - q25[i]) > 0.01) return true;
                    }
                    return false;
                })();

                // Sign-based band (25–75%)
                if ((series.nMatches || 0) >= 2 && hasSpread && q25.length && q50.length && q75.length) {
                    for (let sign = 0; sign < 2; sign++) {
                        const wantPos = sign === 0;
                        ctx.save();
                        ctx.fillStyle = wantPos ? HSV_BLUE : RED;
                        ctx.globalAlpha = wantPos ? POS_BAND_A : NEG_BAND_A;
                        ctx.beginPath();
                        let started = false;
                        for (let i = 0; i < series.minutes.length; i++) {
                            const isPos = q50[i] >= 0;
                            if (isPos !== wantPos) {
                                if (started) break;
                                continue;
                            }
                            const x = xToPx(series.minutes[i]);
                            const y = yToPx(q75[i]);
                            if (!started) { ctx.moveTo(x, y); started = true; }
                            else ctx.lineTo(x, y);
                        }
                        if (started) {
                            for (let i = series.minutes.length - 1; i >= 0; i--) {
                                const isPos = q50[i] >= 0;
                                if (isPos !== wantPos) continue;
                                const x = xToPx(series.minutes[i]);
                                const y = yToPx(q25[i]);
                                ctx.lineTo(x, y);
                            }
                            ctx.closePath();
                            ctx.fill();
                        }
                        ctx.restore();
                    }
                }

                // Fallback fill between median and 0-line
                if (q50.length) {
                    for (let sign = 0; sign < 2; sign++) {
                        const wantPos = sign === 0;
                        ctx.save();
                        ctx.fillStyle = wantPos ? HSV_BLUE : RED;
                        ctx.globalAlpha = wantPos ? POS_FILL_A : NEG_FILL_A;
                        ctx.beginPath();
                        ctx.moveTo(xToPx(series.minutes[0]), y0);
                        for (let i = 0; i < q50.length; i++) {
                            const isPos = q50[i] >= 0;
                            const v = wantPos ? Math.max(0, q50[i]) : Math.min(0, q50[i]);
                            const x = xToPx(series.minutes[i]);
                            const y = yToPx(v);
                            if (isPos !== wantPos) ctx.lineTo(x, y0);
                            else ctx.lineTo(x, y);
                        }
                        ctx.lineTo(xToPx(series.minutes[q50.length - 1]), y0);
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                    }

                    // Median line
                    ctx.save();
                    ctx.strokeStyle = 'rgba(17,24,39,0.95)';
                    ctx.lineWidth = 2.2;
                    ctx.beginPath();
                    for (let i = 0; i < q50.length; i++) {
                        const x = xToPx(series.minutes[i]);
                        const y = yToPx(q50[i]);
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                    ctx.restore();
                }

                // X-axis labels
                ctx.save();
                ctx.fillStyle = 'rgba(107,114,128,0.9)';
                ctx.font = '10px Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                for (let m = 0; m <= series.minutes[series.minutes.length - 1]; m += 15) {
                    const x = xToPx(m);
                    ctx.fillText(String(m), x, padT + ih + 4);
                }
                ctx.restore();

                if (ftSummary) {
                    if (series.teamPctAvg != null && series.oppPctAvg != null) {
                        const nTxt = (series.nMatches != null) ? ` · n=${series.nMatches}` : '';
                        ftSummary.textContent = `${teamName}: ${series.teamPctAvg.toFixed(1)}% · Gegner: ${series.oppPctAvg.toFixed(1)}%${nTxt}`;
                    } else {
                        ftSummary.textContent = '';
                    }
                }
            };

            // Match-Auswahl: wie in Gegneranalyse üblich (letzte N Spiele des ausgewählten Teams)
            const teamGames = (dataset || []).filter(row => row && row.team === currentTeam);
            const uniqueMatchIds = [...new Set(teamGames.map(row => String(row.match_id)))].filter(Boolean).sort().reverse();
            const matchesToAnalyze = uniqueMatchIds.slice(0, currentGameCount);

            // Referenz-Team: immer das aktuell ausgewählte Analyse-Team
            const referenceTeam = currentTeam;

            const series = computeFieldTiltSeries(eventDataset || [], referenceTeam, matchesToAnalyze, { maxMinutes: 95 });
            drawFieldTiltChart(ftCanvas, series, { teamName: referenceTeam });
            return;
        }

        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;

        // Spielkontrolle: Ballbesitz – Territory Plot (hochkant im normalen Pitch-Format)
        if (currentPhase === 'ballbesitz') {
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;

            const TOUCH_EVENTS = new Set(['Pass', 'Carry', 'TakeOn', 'BallTouch', 'Shot', 'Goal', 'MissedShots', 'SavedShot']);
            const clamp01Local = (v) => Math.max(0, Math.min(1, v));
            const clampInt = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

            const buildGaussianKernel1D = (radius, sigma) => {
                const size = radius * 2 + 1;
                const k = new Float32Array(size);
                const s2 = 2 * sigma * sigma;
                let sum = 0;
                for (let i = -radius; i <= radius; i++) {
                    const v = Math.exp(-(i * i) / s2);
                    k[i + radius] = v;
                    sum += v;
                }
                if (sum > 0) {
                    for (let i = 0; i < size; i++) k[i] /= sum;
                }
                return k;
            };

            const blurSeparable = (src, w, h, kernel) => {
                const r = Math.floor(kernel.length / 2);
                const tmp = new Float32Array(w * h);
                const dst = new Float32Array(w * h);

                for (let y = 0; y < h; y++) {
                    const row = y * w;
                    for (let x = 0; x < w; x++) {
                        let acc = 0;
                        for (let k = -r; k <= r; k++) {
                            const xx = clampInt(x + k, 0, w - 1);
                            acc += src[row + xx] * kernel[k + r];
                        }
                        tmp[row + x] = acc;
                    }
                }
                for (let y = 0; y < h; y++) {
                    for (let x = 0; x < w; x++) {
                        let acc = 0;
                        for (let k = -r; k <= r; k++) {
                            const yy = clampInt(y + k, 0, h - 1);
                            acc += tmp[yy * w + x] * kernel[k + r];
                        }
                        dst[y * w + x] = acc;
                    }
                }
                return dst;
            };

            const drawPitchLinesPortrait = (ctx, w, h) => {
                ctx.save();
                ctx.strokeStyle = LINE_COLOR;
                ctx.lineWidth = Math.max(1, w * 0.005);
                ctx.lineCap = 'round';

                ctx.strokeRect(0, 0, w, h);
                ctx.beginPath();
                ctx.moveTo(0, h / 2);
                ctx.lineTo(w, h / 2);
                ctx.stroke();

                ctx.beginPath();
                ctx.arc(w / 2, h / 2, w * 0.2, 0, 2 * Math.PI);
                ctx.stroke();

                ctx.fillStyle = LINE_COLOR;
                ctx.beginPath();
                ctx.arc(w / 2, h / 2, w * 0.01, 0, 2 * Math.PI);
                ctx.fill();

                const penaltyBoxH = h * (16.5 / 105);
                const penaltyBoxW = w * (40.3 / 68);
                const penaltyBoxX = (w - penaltyBoxW) / 2;
                ctx.strokeRect(penaltyBoxX, 0, penaltyBoxW, penaltyBoxH);
                ctx.strokeRect(penaltyBoxX, h - penaltyBoxH, penaltyBoxW, penaltyBoxH);

                const goalBoxH = h * (5.5 / 105);
                const goalBoxW = w * (18.32 / 68);
                const goalBoxX = (w - goalBoxW) / 2;
                ctx.strokeRect(goalBoxX, 0, goalBoxW, goalBoxH);
                ctx.strokeRect(goalBoxX, h - goalBoxH, goalBoxW, goalBoxH);

                ctx.restore();
            };

            ctx.clearRect(0, 0, w, h);
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, w, h);

            const matchIds = new Set((dataPoints || []).map(e => String(e.match_id ?? '')).filter(Boolean));
            const evs = (eventDataset || [])
                .filter(e => e && e.match_id != null && matchIds.has(String(e.match_id)))
                .filter(e => e.team != null && e.x_coord != null && e.y_coord != null)
                .filter(e => TOUCH_EVENTS.has(String(e.event_type || '')))
                .map(e => ({ team: String(e.team), x: Number(e.x_coord), y: Number(e.y_coord) }))
                .filter(e => Number.isFinite(e.x) && Number.isFinite(e.y));

            // Low-res grid for smoothing
            const gridW = 48;
            const gridH = 72;
            const teamGrid = new Float32Array(gridW * gridH);
            const oppGrid = new Float32Array(gridW * gridH);

            for (const e of evs) {
                // Spielrichtung oben -> unten: Länge (x) -> vertikal, Breite (y) -> horizontal
                const gx = clampInt(Math.floor((e.y / 100) * gridW), 0, gridW - 1);
                const gy = clampInt(Math.floor((e.x / 100) * gridH), 0, gridH - 1);
                const idx = gy * gridW + gx;
                if (e.team === currentTeam) teamGrid[idx] += 1;
                else oppGrid[idx] += 1;
            }

            const kernel = buildGaussianKernel1D(4, 2.2);
            const teamBlur = blurSeparable(teamGrid, gridW, gridH, kernel);
            const oppBlur = blurSeparable(oppGrid, gridW, gridH, kernel);

            let maxTot = 0;
            for (let i = 0; i < teamBlur.length; i++) {
                const tot = teamBlur[i] + oppBlur[i];
                if (tot > maxTot) maxTot = tot;
            }
            maxTot = Math.max(1e-6, maxTot);

            const off = document.createElement('canvas');
            off.width = gridW;
            off.height = gridH;
            const octx = off.getContext('2d');
            const img = octx.createImageData(gridW, gridH);

            const BLUE = [10, 63, 134];
            const RED = [239, 68, 68];

            for (let gy = 0; gy < gridH; gy++) {
                for (let gx = 0; gx < gridW; gx++) {
                    const i = gy * gridW + gx;
                    const a = teamBlur[i];
                    const b = oppBlur[i];
                    const tot = a + b;
                    const p = i * 4;

                    if (tot <= 0) {
                        img.data[p + 0] = 255;
                        img.data[p + 1] = 255;
                        img.data[p + 2] = 255;
                        img.data[p + 3] = 0;
                        continue;
                    }

                    const d = (a - b) / tot; // -1..1
                    const mag = Math.abs(d);
                    const coverage = Math.sqrt(clamp01Local(tot / maxTot));
                    const alpha = clamp01Local(0.04 + 0.92 * mag * coverage);
                    const col = d >= 0 ? BLUE : RED;

                    img.data[p + 0] = col[0];
                    img.data[p + 1] = col[1];
                    img.data[p + 2] = col[2];
                    img.data[p + 3] = Math.round(alpha * 255);
                }
            }

            octx.putImageData(img, 0, 0);
            ctx.save();
            ctx.imageSmoothingEnabled = true;
            ctx.drawImage(off, 0, 0, w, h);
            ctx.restore();

            drawPitchLinesPortrait(ctx, w, h);

            if (ballbesitzLegend) {
                const teamLabel = (currentTeam != null && String(currentTeam).trim()) ? String(currentTeam).trim() : 'Team';
                ballbesitzLegend.innerHTML = `
                    <span class="inline-flex items-center gap-2">
                        <span class="inline-block w-2.5 h-2.5 rounded-sm" style="background:#0A3F86"></span>
                        <span>${teamLabel}</span>
                        <span class="inline-block w-2.5 h-2.5 rounded-sm ml-3" style="background:#ef4444"></span>
                        <span>Gegner</span>
                    </span>
                `;
            }
            return;
        }

        // Gegneranalyse: Spielrichtung/Orientierung für Pitch-Renderings
        // - eigenes Team (baseTeam): unten -> oben
        // - Gegner (currentTeam != baseTeam): oben -> unten (180° Rotation inkl. Seitenwechsel)
        const needsInversion = (currentTeam !== baseTeam);
        const clamp01 = (v) => {
            const n = Number(v);
            if (!Number.isFinite(n)) return null;
            return Math.max(0, Math.min(99.999, n));
        };
        const toCanvas = (xRaw, yRaw, w, h) => {
            const x = clamp01(xRaw);
            const y = clamp01(yRaw);
            if (x == null || y == null) return null;
            if (needsInversion) {
                return { cx: (100 - y) * (w / 100), cy: x * (h / 100) };
            }
            return { cx: y * (w / 100), cy: (100 - x) * (h / 100) };
        };
        const toZoneBin = (xRaw, yRaw) => {
            const x = clamp01(xRaw);
            const y = clamp01(yRaw);
            if (x == null || y == null) return null;
            return needsInversion ? { x: 100 - x, y: 100 - y } : { x, y };
        };

        // Gegen den Ball: Chance Prevention -> Schüsse / Schüsse Box (zugelassen)
        // - Detail: alle zugelassenen Schüsse als Punkte, Gegentore in HSV-blau.
        // - Zonen: 12x8 Raster im letzten Drittel (wie Mit Ball -> Abschlüsse)
        if (
            currentMainPhase === 'gegen-ball' &&
            activeGegenBallGroup === 'chance' &&
            (currentPhase === 'shots' || currentPhase === 'shots-box')
        ) {
            // Sicherstellen, dass keine PitchViz-Instanz (oder Rest-Renderer) auf dem gleichen Canvas weiterzeichnet
            if (pitchVizInstance) { try { pitchVizInstance.destroy(); } catch (e) { } pitchVizInstance = null; }

            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;

            // Spielfeld zeichnen (wie bei Mit Ball -> Abschlüsse), Ziel immer oben
            (function drawShotPitch(ctx, w, h) {
                ctx.clearRect(0, 0, w, h);
                ctx.strokeStyle = '#6b7280';
                ctx.lineWidth = Math.max(1, w * 0.005);
                ctx.lineCap = 'round';
                // Außenrahmen
                ctx.strokeRect(0, 0, w, h);
                // Mittellinie
                ctx.beginPath(); ctx.moveTo(0, h/2); ctx.lineTo(w, h/2); ctx.stroke();
                // Mittelkreis
                ctx.beginPath(); ctx.arc(w/2, h/2, w*0.2, 0, 2*Math.PI); ctx.stroke();
                // Strafräume
                const pbH = h*(16.5/105), pbW = w*(40.3/68), pbX = (w-pbW)/2;
                ctx.strokeRect(pbX, 0, pbW, pbH); // oben (Angriffsziel)
                ctx.strokeRect(pbX, h-pbH, pbW, pbH); // unten

                // Letztes Drittel highlight + gestricheltes 12x8 Raster
                const topH = ((100 - 66.6)/100)*h;
                const y0 = 0;
                ctx.fillStyle = 'rgba(10,63,134,0.06)';
                ctx.fillRect(0, y0, w, topH);

                ctx.save();
                ctx.strokeStyle = 'rgba(156,163,175,0.35)';
                ctx.setLineDash([4,4]);
                const rows = 8, cols = 12;
                const cellH = topH / rows;
                const cellW = w / cols;
                for (let i = 1; i < rows; i++) {
                    ctx.beginPath();
                    ctx.moveTo(0, y0 + i * cellH);
                    ctx.lineTo(w, y0 + i * cellH);
                    ctx.stroke();
                }
                for (let j = 1; j < cols; j++) {
                    ctx.beginPath();
                    ctx.moveTo(j * cellW, y0);
                    ctx.lineTo(j * cellW, y0 + topH);
                    ctx.stroke();
                }
                ctx.restore();
            })(ctx, w, h);

            const BLUE = '#0A3F86';
            const RED = 'rgba(239, 68, 68, 0.70)';
            const r = Math.max(3, w * 0.012);

            ctx.save();
            ctx.globalAlpha = 0.9;
            ctx.strokeStyle = 'rgba(255,255,255,0.85)';
            ctx.lineWidth = Math.max(1, w * 0.0025);

            if (globalViewMode === 'zones') {
                const rows = 8, cols = 12;
                const counts = Array.from({ length: rows }, () => Array(cols).fill(0));
                for (const e of (dataPoints || [])) {
                    const xRaw = Number(e.x_coord);
                    const yRaw = Number(e.y_coord);
                    if (!Number.isFinite(xRaw) || !Number.isFinite(yRaw)) continue;
                    if (xRaw < 66.6) continue; // nur letztes Drittel (vor oberem Tor)
                    const frac = (100 - xRaw) / (100 - 66.6);
                    let rr = Math.floor(frac * rows);
                    rr = Math.min(rows - 1, Math.max(0, rr));
                    let cc = Math.floor((yRaw / 100) * cols);
                    cc = Math.min(cols - 1, Math.max(0, cc));
                    counts[rr][cc]++;
                }

                const maxV = Math.max(1, ...counts.map(row => Math.max(0, ...row)));
                const topH = ((100 - 66.6) / 100) * h;
                const cellH = topH / rows;
                const cellW = w / cols;
                ctx.save();
                for (let rr = 0; rr < rows; rr++) {
                    for (let cc = 0; cc < cols; cc++) {
                        const v = counts[rr][cc];
                        if (v <= 0) continue;
                        const t = v / maxV;
                        const alpha = 0.1 + 0.55 * t;
                        ctx.fillStyle = `rgba(10,63,134,${alpha.toFixed(3)})`;
                        ctx.fillRect(cc * cellW, rr * cellH, cellW, cellH);
                    }
                }
                ctx.restore();
            } else {
                for (const e of (dataPoints || [])) {
                    // Zugelassene Schüsse: immer bottom->top darstellen (vor dem oberen Tor)
                    const x = clamp01(e.x_coord);
                    const y = clamp01(e.y_coord);
                    if (x == null || y == null) continue;
                    const cx = y * (w / 100);
                    const cy = (100 - x) * (h / 100);

                    const isGoal = (e.event_type === 'Goal' || e.type === 'Goal' || e.isGoal === true);
                    ctx.fillStyle = isGoal ? BLUE : RED;
                    ctx.beginPath();
                    ctx.arc(cx, cy, r, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                }
            }

            ctx.restore();
            return;
        }

        // Gegen den Ball: Chance Prevention -> Box Entries (zugelassen)
        // - Detail: erfolgreiche Pässe in die Box als HSV-blaue Pfeile.
        // - Zonen: 12x8 Heatmap im letzten Drittel (wie Schüsse Box), ohne Pfeile.
        if (currentMainPhase === 'gegen-ball' && activeGegenBallGroup === 'chance' && currentPhase === 'box-entries') {
            // Sicherstellen, dass keine PitchViz-Instanz (oder Rest-Renderer) auf dem gleichen Canvas weiterzeichnet
            if (pitchVizInstance) { try { pitchVizInstance.destroy(); } catch (e) { } pitchVizInstance = null; }

            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;

            // Spielfeld zeichnen (wie bei Schüsse Box), Ziel immer oben
            (function drawEntryPitch(ctx, w, h) {
                ctx.clearRect(0, 0, w, h);
                ctx.strokeStyle = '#6b7280';
                ctx.lineWidth = Math.max(1, w * 0.005);
                ctx.lineCap = 'round';
                // Außenrahmen
                ctx.strokeRect(0, 0, w, h);
                // Mittellinie
                ctx.beginPath(); ctx.moveTo(0, h / 2); ctx.lineTo(w, h / 2); ctx.stroke();
                // Mittelkreis
                ctx.beginPath(); ctx.arc(w / 2, h / 2, w * 0.2, 0, 2 * Math.PI); ctx.stroke();
                // Strafräume
                const pbH = h * (16.5 / 105), pbW = w * (40.3 / 68), pbX = (w - pbW) / 2;
                ctx.strokeRect(pbX, 0, pbW, pbH); // oben (Ziel)
                ctx.strokeRect(pbX, h - pbH, pbW, pbH); // unten

                // Letztes Drittel highlight + gestricheltes 12x8 Raster
                const topH = ((100 - 66.6) / 100) * h;
                const y0 = 0;
                ctx.fillStyle = 'rgba(10,63,134,0.06)';
                ctx.fillRect(0, y0, w, topH);

                ctx.save();
                ctx.strokeStyle = 'rgba(156,163,175,0.35)';
                ctx.setLineDash([4, 4]);
                const rows = 8, cols = 12;
                const cellH = topH / rows;
                const cellW = w / cols;
                for (let i = 1; i < rows; i++) {
                    ctx.beginPath();
                    ctx.moveTo(0, y0 + i * cellH);
                    ctx.lineTo(w, y0 + i * cellH);
                    ctx.stroke();
                }
                for (let j = 1; j < cols; j++) {
                    ctx.beginPath();
                    ctx.moveTo(j * cellW, y0);
                    ctx.lineTo(j * cellW, y0 + topH);
                    ctx.stroke();
                }
                ctx.restore();
            })(ctx, w, h);

            const BLUE = 'rgba(10,63,134,0.92)';
            const stroke = 'rgba(255,255,255,0.85)';

            const toBTTC = (xRaw, yRaw) => {
                const x = clamp01(xRaw);
                const y = clamp01(yRaw);
                if (x == null || y == null) return null;
                return { cx: y * (w / 100), cy: (100 - x) * (h / 100) };
            };
            const drawArrow = (sx, sy, ex, ey, color) => {
                const dx = ex - sx;
                const dy = ey - sy;
                const L = Math.max(1, Math.hypot(dx, dy));
                const lw = Math.min(Math.max(1.5, L * 0.004), 4);
                const head = Math.min(10, Math.max(6, L * 0.10));
                const ang = Math.atan2(dy, dx);
                ctx.save();
                ctx.globalAlpha = 0.9;
                ctx.strokeStyle = color;
                ctx.fillStyle = color;
                ctx.lineWidth = lw;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(sx, sy);
                ctx.lineTo(ex, ey);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(ex, ey);
                ctx.lineTo(ex - head * Math.cos(ang - Math.PI / 6), ey - head * Math.sin(ang - Math.PI / 6));
                ctx.lineTo(ex - head * Math.cos(ang + Math.PI / 6), ey - head * Math.sin(ang + Math.PI / 6));
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            };

            if (globalViewMode === 'zones') {
                // Zonen: Heatmap nach Endpunkten (Eintritt in die Box) im letzten Drittel
                const rows = 8, cols = 12;
                const counts = Array.from({ length: rows }, () => Array(cols).fill(0));
                for (const e of (dataPoints || [])) {
                    const xRaw = Number(e.end_x);
                    const yRaw = Number(e.end_y);
                    if (!Number.isFinite(xRaw) || !Number.isFinite(yRaw)) continue;
                    if (xRaw < 66.6) continue;
                    const frac = (100 - xRaw) / (100 - 66.6);
                    let rr = Math.floor(frac * rows);
                    rr = Math.min(rows - 1, Math.max(0, rr));
                    let cc = Math.floor((yRaw / 100) * cols);
                    cc = Math.min(cols - 1, Math.max(0, cc));
                    counts[rr][cc]++;
                }

                const maxV = Math.max(1, ...counts.map(row => Math.max(0, ...row)));
                const topH = ((100 - 66.6) / 100) * h;
                const cellH = topH / rows;
                const cellW = w / cols;
                ctx.save();
                for (let rr = 0; rr < rows; rr++) {
                    for (let cc = 0; cc < cols; cc++) {
                        const v = counts[rr][cc];
                        if (v <= 0) continue;
                        const t = v / maxV;
                        const alpha = 0.1 + 0.55 * t;
                        ctx.fillStyle = `rgba(10,63,134,${alpha.toFixed(3)})`;
                        ctx.fillRect(cc * cellW, rr * cellH, cellW, cellH);
                    }
                }
                ctx.restore();
            } else {
                // Detail: Pfeile in HSV-Blau
                ctx.save();
                ctx.strokeStyle = stroke;
                ctx.lineWidth = Math.max(1, w * 0.0025);
                for (const e of (dataPoints || [])) {
                    const s = toBTTC(e.x_coord ?? e.x, e.y_coord ?? e.y);
                    const en = toBTTC(e.end_x, e.end_y);
                    if (!s || !en) continue;
                    drawArrow(s.cx, s.cy, en.cx, en.cy, BLUE);
                }
                ctx.restore();
            }
            return;
        }

        // Gegen den Ball: Chance Prevention -> Flanken (zugelassen)
        // - Detail: alle zugelassenen Flanken als HSV-blaue Pfeile.
        // - Zonen: 12x8 Heatmap im letzten Drittel (wie Schüsse Box), ohne Pfeile.
        if (currentMainPhase === 'gegen-ball' && activeGegenBallGroup === 'chance' && currentPhase === 'cross-defense') {
            // Sicherstellen, dass keine PitchViz-Instanz (oder Rest-Renderer) auf dem gleichen Canvas weiterzeichnet
            if (pitchVizInstance) { try { pitchVizInstance.destroy(); } catch (e) { } pitchVizInstance = null; }

            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;

            // Spielfeld zeichnen (wie bei Schüsse Box), Ziel immer oben
            (function drawCrossPitchGA(ctx, w, h) {
                ctx.clearRect(0, 0, w, h);
                ctx.strokeStyle = '#6b7280';
                ctx.lineWidth = Math.max(1, w * 0.005);
                ctx.lineCap = 'round';
                ctx.strokeRect(0, 0, w, h);
                ctx.beginPath(); ctx.moveTo(0, h / 2); ctx.lineTo(w, h / 2); ctx.stroke();
                ctx.beginPath(); ctx.arc(w / 2, h / 2, w * 0.2, 0, 2 * Math.PI); ctx.stroke();
                const pbH = h * (16.5 / 105), pbW = w * (40.3 / 68), pbX = (w - pbW) / 2;
                ctx.strokeRect(pbX, 0, pbW, pbH);
                ctx.strokeRect(pbX, h - pbH, pbW, pbH);

                const topH = ((100 - 66.6) / 100) * h;
                const y0 = 0;
                ctx.fillStyle = 'rgba(10,63,134,0.06)';
                ctx.fillRect(0, y0, w, topH);

                ctx.save();
                ctx.strokeStyle = 'rgba(156,163,175,0.35)';
                ctx.setLineDash([4, 4]);
                const rows = 8, cols = 12;
                const cellH = topH / rows;
                const cellW = w / cols;
                for (let i = 1; i < rows; i++) {
                    ctx.beginPath();
                    ctx.moveTo(0, y0 + i * cellH);
                    ctx.lineTo(w, y0 + i * cellH);
                    ctx.stroke();
                }
                for (let j = 1; j < cols; j++) {
                    ctx.beginPath();
                    ctx.moveTo(j * cellW, y0);
                    ctx.lineTo(j * cellW, y0 + topH);
                    ctx.stroke();
                }
                ctx.restore();
            })(ctx, w, h);

            const BLUE = 'rgba(10,63,134,0.92)';

            const toBTTC = (xRaw, yRaw) => {
                const x = clamp01(xRaw);
                const y = clamp01(yRaw);
                if (x == null || y == null) return null;
                return { cx: y * (w / 100), cy: (100 - x) * (h / 100) };
            };

            const drawArrow = (sx, sy, ex, ey, color) => {
                const dx = ex - sx;
                const dy = ey - sy;
                const L = Math.max(1, Math.hypot(dx, dy));
                const lw = Math.min(Math.max(1.5, L * 0.004), 4);
                const head = Math.min(10, Math.max(6, L * 0.10));
                const ang = Math.atan2(dy, dx);
                ctx.save();
                ctx.globalAlpha = 0.9;
                ctx.strokeStyle = color;
                ctx.fillStyle = color;
                ctx.lineWidth = lw;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(sx, sy);
                ctx.lineTo(ex, ey);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(ex, ey);
                ctx.lineTo(ex - head * Math.cos(ang - Math.PI / 6), ey - head * Math.sin(ang - Math.PI / 6));
                ctx.lineTo(ex - head * Math.cos(ang + Math.PI / 6), ey - head * Math.sin(ang + Math.PI / 6));
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            };

            if (globalViewMode === 'zones') {
                // Heatmap nach Cross-Endpunkten im letzten Drittel
                const rows = 8, cols = 12;
                const counts = Array.from({ length: rows }, () => Array(cols).fill(0));
                for (const e of (dataPoints || [])) {
                    const xRaw = Number(e.end_x);
                    const yRaw = Number(e.end_y);
                    if (!Number.isFinite(xRaw) || !Number.isFinite(yRaw)) continue;
                    if (xRaw < 66.6) continue;
                    const frac = (100 - xRaw) / (100 - 66.6);
                    let rr = Math.floor(frac * rows);
                    rr = Math.min(rows - 1, Math.max(0, rr));
                    let cc = Math.floor((yRaw / 100) * cols);
                    cc = Math.min(cols - 1, Math.max(0, cc));
                    counts[rr][cc]++;
                }

                const maxV = Math.max(1, ...counts.map(row => Math.max(0, ...row)));
                const topH = ((100 - 66.6) / 100) * h;
                const cellH = topH / rows;
                const cellW = w / cols;
                ctx.save();
                for (let rr = 0; rr < rows; rr++) {
                    for (let cc = 0; cc < cols; cc++) {
                        const v = counts[rr][cc];
                        if (v <= 0) continue;
                        const t = v / maxV;
                        const alpha = 0.1 + 0.55 * t;
                        ctx.fillStyle = `rgba(10,63,134,${alpha.toFixed(3)})`;
                        ctx.fillRect(cc * cellW, rr * cellH, cellW, cellH);
                    }
                }
                ctx.restore();
            } else {
                // Detail: Pfeile in HSV-Blau
                for (const e of (dataPoints || [])) {
                    const s = toBTTC(e.x_coord ?? e.x, e.y_coord ?? e.y);
                    const en = toBTTC(e.end_x, e.end_y);
                    if (!s || !en) continue;
                    drawArrow(s.cx, s.cy, en.cx, en.cy, BLUE);
                }
            }

            return;
        }

        // Gegen den Ball: Chance Prevention -> Gegentore (standards-against)
        // - Detail: Schuss-Position (Goal) als Punkt + bis zu die letzten 2 erfolgreichen Pässe davor (nur wenn vom Torschützen-Team).
        // - Zonen: 12x8 Heatmap im letzten Drittel basierend auf Goal-Punkten (ohne Pfeile).
        if (currentMainPhase === 'gegen-ball' && activeGegenBallGroup === 'chance' && currentPhase === 'standards-against') {
            // Sicherstellen, dass keine PitchViz-Instanz (oder Rest-Renderer) auf dem gleichen Canvas weiterzeichnet
            if (pitchVizInstance) { try { pitchVizInstance.destroy(); } catch (e) { } pitchVizInstance = null; }

            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;

            // Spielfeld zeichnen (wie bei Schüsse Box), Ziel immer oben
            (function drawGoalsPitch(ctx, w, h) {
                ctx.clearRect(0, 0, w, h);
                ctx.strokeStyle = '#6b7280';
                ctx.lineWidth = Math.max(1, w * 0.005);
                ctx.lineCap = 'round';
                ctx.strokeRect(0, 0, w, h);
                ctx.beginPath(); ctx.moveTo(0, h / 2); ctx.lineTo(w, h / 2); ctx.stroke();
                ctx.beginPath(); ctx.arc(w / 2, h / 2, w * 0.2, 0, 2 * Math.PI); ctx.stroke();
                const pbH = h * (16.5 / 105), pbW = w * (40.3 / 68), pbX = (w - pbW) / 2;
                ctx.strokeRect(pbX, 0, pbW, pbH);
                ctx.strokeRect(pbX, h - pbH, pbW, pbH);

                const topH = ((100 - 66.6) / 100) * h;
                const y0 = 0;
                ctx.fillStyle = 'rgba(10,63,134,0.06)';
                ctx.fillRect(0, y0, w, topH);

                ctx.save();
                ctx.strokeStyle = 'rgba(156,163,175,0.35)';
                ctx.setLineDash([4, 4]);
                const rows = 8, cols = 12;
                const cellH = topH / rows;
                const cellW = w / cols;
                for (let i = 1; i < rows; i++) {
                    ctx.beginPath();
                    ctx.moveTo(0, y0 + i * cellH);
                    ctx.lineTo(w, y0 + i * cellH);
                    ctx.stroke();
                }
                for (let j = 1; j < cols; j++) {
                    ctx.beginPath();
                    ctx.moveTo(j * cellW, y0);
                    ctx.lineTo(j * cellW, y0 + topH);
                    ctx.stroke();
                }
                ctx.restore();
            })(ctx, w, h);

            const BLUE = 'rgba(10,63,134,0.92)';
            const GOAL_DOT = '#0A3F86';
            const STROKE = 'rgba(255,255,255,0.88)';
            const pr = Math.max(4, w * 0.014);

            const toBTTC = (xRaw, yRaw) => {
                const x = clamp01(xRaw);
                const y = clamp01(yRaw);
                if (x == null || y == null) return null;
                return { cx: y * (w / 100), cy: (100 - x) * (h / 100) };
            };
            const drawArrow = (sx, sy, ex, ey, color) => {
                const dx = ex - sx;
                const dy = ey - sy;
                const L = Math.max(1, Math.hypot(dx, dy));
                const lw = Math.min(Math.max(1.6, L * 0.004), 4);
                const head = Math.min(10, Math.max(6, L * 0.10));
                const ang = Math.atan2(dy, dx);
                ctx.save();
                ctx.globalAlpha = 0.9;
                ctx.strokeStyle = color;
                ctx.fillStyle = color;
                ctx.lineWidth = lw;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(sx, sy);
                ctx.lineTo(ex, ey);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(ex, ey);
                ctx.lineTo(ex - head * Math.cos(ang - Math.PI / 6), ey - head * Math.sin(ang - Math.PI / 6));
                ctx.lineTo(ex - head * Math.cos(ang + Math.PI / 6), ey - head * Math.sin(ang + Math.PI / 6));
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            };

            if (globalViewMode === 'zones') {
                // Heatmap nur nach Goal-Punkten
                const rows = 8, cols = 12;
                const counts = Array.from({ length: rows }, () => Array(cols).fill(0));
                for (const e of (dataPoints || [])) {
                    if (String(e.kind || '') !== 'goal') continue;
                    const xRaw = Number(e.x_coord);
                    const yRaw = Number(e.y_coord);
                    if (!Number.isFinite(xRaw) || !Number.isFinite(yRaw)) continue;
                    if (xRaw < 66.6) continue;
                    const frac = (100 - xRaw) / (100 - 66.6);
                    let rr = Math.floor(frac * rows);
                    rr = Math.min(rows - 1, Math.max(0, rr));
                    let cc = Math.floor((yRaw / 100) * cols);
                    cc = Math.min(cols - 1, Math.max(0, cc));
                    counts[rr][cc]++;
                }

                const maxV = Math.max(1, ...counts.map(row => Math.max(0, ...row)));
                const topH = ((100 - 66.6) / 100) * h;
                const cellH = topH / rows;
                const cellW = w / cols;
                ctx.save();
                for (let rr = 0; rr < rows; rr++) {
                    for (let cc = 0; cc < cols; cc++) {
                        const v = counts[rr][cc];
                        if (v <= 0) continue;
                        const t = v / maxV;
                        const alpha = 0.1 + 0.55 * t;
                        ctx.fillStyle = `rgba(10,63,134,${alpha.toFixed(3)})`;
                        ctx.fillRect(cc * cellW, rr * cellH, cellW, cellH);
                    }
                }
                ctx.restore();
            } else {
                // Detail: Pässe (sofern vorhanden) + Goal-Punkt
                // 1) Pässe
                for (const e of (dataPoints || [])) {
                    if (String(e.kind || '') !== 'prepass') continue;
                    const s = toBTTC(e.x_coord, e.y_coord);
                    const en = toBTTC(e.end_x, e.end_y);
                    if (!s || !en) continue;
                    drawArrow(s.cx, s.cy, en.cx, en.cy, BLUE);
                }

                // 2) Goals oben drüber
                ctx.save();
                ctx.globalAlpha = 0.95;
                ctx.strokeStyle = STROKE;
                ctx.lineWidth = Math.max(1, w * 0.0025);
                for (const e of (dataPoints || [])) {
                    if (String(e.kind || '') !== 'goal') continue;
                    const p = toBTTC(e.x_coord, e.y_coord);
                    if (!p) continue;
                    ctx.fillStyle = GOAL_DOT;
                    ctx.beginPath();
                    ctx.arc(p.cx, p.cy, pr, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                }
                ctx.restore();
            }

            return;
        }

        // Gegen den Ball: Chance Prevention -> Box Defense
        // Zeigt Blocks + Clearances im Strafraum als Punkte; in Zonen-Ansicht eine 12x8 Heatmap im letzten Drittel (wie Schüsse Box).
        if (currentMainPhase === 'gegen-ball' && activeGegenBallGroup === 'chance' && currentPhase === 'box-defense') {
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;

            const BLOCK_BLUE = 'rgba(10,63,134,0.85)';
            const CLEAR_GREY = 'rgba(107,114,128,0.70)';
            const STROKE = 'rgba(255,255,255,0.85)';
            const pr = Math.max(3, w * 0.010);

            // Zonen-Modus: Small Pitch (letztes Drittel) + 12x8 Heatmap (wie Schüsse Box)
            if (globalViewMode === 'zones') {
                // Pitch zeichnen (wie bei Schüsse Box), Ziel immer oben
                (function drawBoxDefensePitch(ctx, w, h) {
                    ctx.clearRect(0, 0, w, h);
                    ctx.strokeStyle = '#6b7280';
                    ctx.lineWidth = Math.max(1, w * 0.005);
                    ctx.lineCap = 'round';
                    // Außenrahmen
                    ctx.strokeRect(0, 0, w, h);
                    // Mittellinie
                    ctx.beginPath(); ctx.moveTo(0, h / 2); ctx.lineTo(w, h / 2); ctx.stroke();
                    // Mittelkreis
                    ctx.beginPath(); ctx.arc(w / 2, h / 2, w * 0.2, 0, 2 * Math.PI); ctx.stroke();
                    // Strafräume
                    const pbH = h * (16.5 / 105), pbW = w * (40.3 / 68), pbX = (w - pbW) / 2;
                    ctx.strokeRect(pbX, 0, pbW, pbH); // oben (Ziel)
                    ctx.strokeRect(pbX, h - pbH, pbW, pbH); // unten

                    // Letztes Drittel highlight + gestricheltes 12x8 Raster
                    const topH = ((100 - 66.6) / 100) * h;
                    const y0 = 0;
                    ctx.fillStyle = 'rgba(10,63,134,0.06)';
                    ctx.fillRect(0, y0, w, topH);

                    ctx.save();
                    ctx.strokeStyle = 'rgba(156,163,175,0.35)';
                    ctx.setLineDash([4, 4]);
                    const rows = 8, cols = 12;
                    const cellH = topH / rows;
                    const cellW = w / cols;
                    for (let i = 1; i < rows; i++) {
                        ctx.beginPath();
                        ctx.moveTo(0, y0 + i * cellH);
                        ctx.lineTo(w, y0 + i * cellH);
                        ctx.stroke();
                    }
                    for (let j = 1; j < cols; j++) {
                        ctx.beginPath();
                        ctx.moveTo(j * cellW, y0);
                        ctx.lineTo(j * cellW, y0 + topH);
                        ctx.stroke();
                    }
                    ctx.restore();
                })(ctx, w, h);

                // Heatmap im letzten Drittel: Aktionen (Blocks + Clearances) nach 180° Rotation
                const rows = 8, cols = 12;
                const counts = Array.from({ length: rows }, () => Array(cols).fill(0));
                const clamp = (v) => Math.max(0, Math.min(99.999, Number(v)));

                for (const e of (dataPoints || [])) {
                    const xRaw = clamp(e.x_coord);
                    const yRaw = clamp(e.y_coord);
                    if (!Number.isFinite(xRaw) || !Number.isFinite(yRaw)) continue;
                    // 180° Rotation für Anzeige (damit Aktionen vor dem oberen Tor liegen)
                    const x = 100 - xRaw;
                    const y = 100 - yRaw;

                    if (x < 66.6) continue; // nur letztes Drittel (vor oberem Tor)
                    const frac = (100 - x) / (100 - 66.6);
                    let rr = Math.floor(frac * rows);
                    rr = Math.min(rows - 1, Math.max(0, rr));
                    let cc = Math.floor((y / 100) * cols);
                    cc = Math.min(cols - 1, Math.max(0, cc));
                    counts[rr][cc]++;
                }

                const maxV = Math.max(1, ...counts.map(row => Math.max(0, ...row)));
                const topH = ((100 - 66.6) / 100) * h;
                const cellH = topH / rows;
                const cellW = w / cols;
                ctx.save();
                for (let rr = 0; rr < rows; rr++) {
                    for (let cc = 0; cc < cols; cc++) {
                        const v = counts[rr][cc];
                        if (v <= 0) continue;
                        const t = v / maxV;
                        const alpha = 0.1 + 0.55 * t;
                        ctx.fillStyle = `rgba(10,63,134,${alpha.toFixed(3)})`;
                        ctx.fillRect(cc * cellW, rr * cellH, cellW, cellH);
                    }
                }
                ctx.restore();
            } else {
                drawPitch(canvas, true);
            }

            // Punkte nur im Detail-Modus
            if (globalViewMode !== 'zones') {
                // Punkte (immer bottom->top Mapping: eigener Strafraum unten)
                ctx.save();
                ctx.globalAlpha = 0.9;
                ctx.strokeStyle = STROKE;
                ctx.lineWidth = Math.max(1, w * 0.0025);

                for (const e of (dataPoints || [])) {
                    const x = clamp01(e.x_coord);
                    const y = clamp01(e.y_coord);
                    if (x == null || y == null) continue;
                    // 180° Rotation für Anzeige: x'=100-x, y'=100-y
                    const cx = (100 - y) * (w / 100);
                    const cy = x * (h / 100);

                    const t = String(e.event_type || e.type || '');
                    const isBlock = (t === 'Block' || t === 'BlockedPass');
                    ctx.fillStyle = isBlock ? BLOCK_BLUE : CLEAR_GREY;
                    ctx.beginPath();
                    ctx.arc(cx, cy, pr, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                }

                ctx.restore();
            }
            return;
        }

        // Gegen den Ball: Pressinghöhe Viz
        if (currentPhase === 'pressinghoehe') {
            drawPitch(canvas, false);

            const recoveries = (dataPoints || []).filter(e => {
                if (!e) return false;
                const t = e.event_type;
                if (t === 'Tackle') return e.outcome === 'Successful';
                return (t === 'Interception' || t === 'BallRecovery');
            }).filter(e => e.x_coord != null && e.y_coord != null);

            const xs = recoveries.map(r => Number(r.x_coord)).filter(v => Number.isFinite(v));
            const avgX = xs.length ? (xs.reduce((a, b) => a + b, 0) / xs.length) : null;

            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;

            if (globalViewMode === 'zones') {
                // Zonen: 18er Raster (6x3) einfärben nach Ballgewinn-Häufigkeit
                const counts = Array.from({ length: 18 }, () => 0);
                const clamp = (v) => Math.max(0, Math.min(99.999, Number(v)));

                for (const r of recoveries) {
                    const p = toZoneBin(r.x_coord, r.y_coord);
                    if (!p) continue;
                    const x = p.x;
                    const y = p.y;
                    const rowFromBottom = Math.floor((x / 100) * 6); // 0 unten .. 5 oben
                    const col = Math.floor((y / 100) * 3);          // 0 links .. 2 rechts
                    const zone = rowFromBottom * 3 + col + 1;       // Zone 1 unten links
                    if (zone >= 1 && zone <= 18) counts[zone - 1] += 1;
                }

                const maxV = Math.max(0, ...counts);
                if (maxV > 0) {
                    const zoneW = w / 3;
                    const zoneH = h / 6;
                    ctx.save();
                    for (let z = 1; z <= 18; z++) {
                        const v = counts[z - 1];
                        if (!v) continue;
                        const t = v / maxV;
                        const alpha = 0.08 + 0.55 * t;

                        const rowFromBottom = Math.floor((z - 1) / 3); // 0 unten .. 5 oben
                        const col = (z - 1) % 3;
                        const rowFromTop = 5 - rowFromBottom;

                        ctx.fillStyle = `rgba(10,63,134,${alpha.toFixed(3)})`;
                        ctx.fillRect(col * zoneW, rowFromTop * zoneH, zoneW, zoneH);
                    }
                    ctx.restore();
                }
            } else {
                // Detail: Punkte für jeden Ballgewinn
                const pr = Math.max(3, w * 0.010);
                ctx.save();
                ctx.globalAlpha = 0.75;
                ctx.fillStyle = 'rgba(10,63,134,0.75)';
                ctx.strokeStyle = 'rgba(255,255,255,0.85)';
                ctx.lineWidth = Math.max(1, w * 0.0025);
                for (const r of recoveries) {
                    const pt = toCanvas(r.x_coord, r.y_coord, w, h);
                    if (!pt) continue;
                    const { cx, cy } = pt;
                    ctx.beginPath();
                    ctx.arc(cx, cy, pr, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                }
                ctx.restore();
            }

            // dashed average line + label
            if (avgX != null && Number.isFinite(avgX)) {
                const yLine = toCanvas(avgX, 50, w, h)?.cy;
                if (yLine == null) return;
                ctx.save();
                ctx.strokeStyle = 'rgba(10,63,134,0.95)';
                ctx.lineWidth = Math.max(2, w * 0.004);
                ctx.setLineDash([Math.max(6, w * 0.025), Math.max(4, w * 0.018)]);
                ctx.beginPath();
                ctx.moveTo(0, yLine);
                ctx.lineTo(w, yLine);
                ctx.stroke();
                ctx.setLineDash([]);

                const label = `Ø Ballgewinnhöhe: ${avgX.toFixed(1)}`;
                const padX = 6;
                const padY = 3;
                const fontSize = Math.max(10, Math.min(13, Math.round(w * 0.030)));
                ctx.font = `700 ${fontSize}px Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif`;
                const tw = ctx.measureText(label).width;
                const bx = 8;
                const by = Math.max(8, Math.min(h - (fontSize + padY * 2 + 8), yLine - (fontSize + padY * 2 + 6)));
                ctx.fillStyle = 'rgba(255,255,255,0.88)';
                ctx.fillRect(bx, by, tw + padX * 2, fontSize + padY * 2);
                ctx.fillStyle = '#0A3F86';
                ctx.textBaseline = 'top';
                ctx.fillText(label, bx + padX, by + padY);
                ctx.restore();
            }

            return;
        }

        // Gegen den Ball: Zugriff Viz (Tackles & Interceptions)
        if (currentPhase === 'zugriff') {
            drawPitch(canvas, false);

            const events = (dataPoints || [])
                .filter(e => e && e.x_coord != null && e.y_coord != null)
                .filter(e => e.event_type === 'Tackle' || e.event_type === 'Interception');

            const toNum = (v) => Number(v);
            const clamp = (v) => Math.max(0, Math.min(99.999, toNum(v)));

            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;

            if (globalViewMode === 'zones') {
                const counts = Array.from({ length: 18 }, () => 0);
                for (const e of events) {
                    const p = toZoneBin(e.x_coord, e.y_coord);
                    if (!p) continue;
                    const x = p.x;
                    const y = p.y;
                    const rowFromBottom = Math.floor((x / 100) * 6);
                    const col = Math.floor((y / 100) * 3);
                    const zone = rowFromBottom * 3 + col + 1;
                    if (zone >= 1 && zone <= 18) counts[zone - 1] += 1;
                }
                const maxV = Math.max(0, ...counts);
                if (maxV > 0) {
                    const zoneW = w / 3;
                    const zoneH = h / 6;
                    ctx.save();
                    for (let z = 1; z <= 18; z++) {
                        const v = counts[z - 1];
                        if (!v) continue;
                        const t = v / maxV;
                        const alpha = 0.08 + 0.55 * t;

                        const rowFromBottom = Math.floor((z - 1) / 3);
                        const col = (z - 1) % 3;
                        const rowFromTop = 5 - rowFromBottom;

                        ctx.fillStyle = `rgba(10,63,134,${alpha.toFixed(3)})`;
                        ctx.fillRect(col * zoneW, rowFromTop * zoneH, zoneW, zoneH);
                    }
                    ctx.restore();
                }
            } else {
                const pr = Math.max(3, w * 0.010);
                const lw = Math.max(1, w * 0.0025);

                const BLUE_WON = 'rgba(10,63,134,0.85)';
                const BLUE_INT = 'rgba(59,130,246,0.80)';
                const GREY_LOST = 'rgba(107,114,128,0.55)';

                ctx.save();
                ctx.globalAlpha = 0.85;
                ctx.strokeStyle = 'rgba(255,255,255,0.85)';
                ctx.lineWidth = lw;

                // Draw order: lost tackles -> interceptions -> won tackles (won on top)
                const lostTackles = events.filter(e => e.event_type === 'Tackle' && e.outcome !== 'Successful');
                const interceptions = events.filter(e => e.event_type === 'Interception');
                const wonTackles = events.filter(e => e.event_type === 'Tackle' && e.outcome === 'Successful');

                const drawPts = (arr, fill) => {
                    ctx.fillStyle = fill;
                    for (const e of arr) {
                        const pt = toCanvas(e.x_coord, e.y_coord, w, h);
                        if (!pt) continue;
                        const { cx, cy } = pt;
                        ctx.beginPath();
                        ctx.arc(cx, cy, pr, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.stroke();
                    }
                };

                drawPts(lostTackles, GREY_LOST);
                drawPts(interceptions, BLUE_INT);
                drawPts(wonTackles, BLUE_WON);

                ctx.restore();
            }

            return;
        }

        // Gegen den Ball: Intensität Viz (Defensivaktionen)
        if (currentPhase === 'intensitaet') {
            drawPitch(canvas, false);

            const defActions = (dataPoints || [])
                .filter(e => e && e.x_coord != null && e.y_coord != null)
                .filter(e => ['Tackle', 'Interception', 'BallRecovery', 'Foul'].includes(e.event_type));

            const toNum = (v) => Number(v);
            const clamp = (v) => Math.max(0, Math.min(99.999, toNum(v)));

            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;

            if (globalViewMode === 'zones') {
                const counts = Array.from({ length: 18 }, () => 0);
                for (const e of defActions) {
                    const p = toZoneBin(e.x_coord, e.y_coord);
                    if (!p) continue;
                    const x = p.x;
                    const y = p.y;
                    const rowFromBottom = Math.floor((x / 100) * 6);
                    const col = Math.floor((y / 100) * 3);
                    const zone = rowFromBottom * 3 + col + 1;
                    if (zone >= 1 && zone <= 18) counts[zone - 1] += 1;
                }
                const maxV = Math.max(0, ...counts);
                if (maxV > 0) {
                    const zoneW = w / 3;
                    const zoneH = h / 6;
                    ctx.save();
                    for (let z = 1; z <= 18; z++) {
                        const v = counts[z - 1];
                        if (!v) continue;
                        const t = v / maxV;
                        const alpha = 0.08 + 0.55 * t;

                        const rowFromBottom = Math.floor((z - 1) / 3);
                        const col = (z - 1) % 3;
                        const rowFromTop = 5 - rowFromBottom;

                        ctx.fillStyle = `rgba(10,63,134,${alpha.toFixed(3)})`;
                        ctx.fillRect(col * zoneW, rowFromTop * zoneH, zoneW, zoneH);
                    }
                    ctx.restore();
                }
            } else {
                const pr = Math.max(3, w * 0.010);
                ctx.save();
                ctx.globalAlpha = 0.80;
                ctx.fillStyle = 'rgba(10,63,134,0.70)';
                ctx.strokeStyle = 'rgba(255,255,255,0.85)';
                ctx.lineWidth = Math.max(1, w * 0.0025);
                for (const e of defActions) {
                    const pt = toCanvas(e.x_coord, e.y_coord, w, h);
                    if (!pt) continue;
                    const { cx, cy } = pt;
                    ctx.beginPath();
                    ctx.arc(cx, cy, pr, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                }
                ctx.restore();
            }

            return;
        }

        // Gegen den Ball: Ballgewinne Zonen Viz
        if (currentPhase === 'ballgewinne-zonen') {
            drawPitch(canvas, false);

            const recoveries = (dataPoints || []).filter(e => {
                if (!e) return false;
                const t = e.event_type;
                if (t === 'Tackle') return e.outcome === 'Successful';
                return (t === 'Interception' || t === 'BallRecovery');
            }).filter(e => e.x_coord != null && e.y_coord != null);

            const toNum = (v) => Number(v);
            const clamp = (v) => Math.max(0, Math.min(99.999, toNum(v)));

            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;

            if (globalViewMode === 'zones') {
                const counts = Array.from({ length: 18 }, () => 0);
                for (const r of recoveries) {
                    const p = toZoneBin(r.x_coord, r.y_coord);
                    if (!p) continue;
                    const x = p.x;
                    const y = p.y;
                    const rowFromBottom = Math.floor((x / 100) * 6);
                    const col = Math.floor((y / 100) * 3);
                    const zone = rowFromBottom * 3 + col + 1;
                    if (zone >= 1 && zone <= 18) counts[zone - 1] += 1;
                }
                const maxV = Math.max(0, ...counts);
                if (maxV > 0) {
                    const zoneW = w / 3;
                    const zoneH = h / 6;
                    ctx.save();
                    for (let z = 1; z <= 18; z++) {
                        const v = counts[z - 1];
                        if (!v) continue;
                        const t = v / maxV;
                        const alpha = 0.08 + 0.55 * t;

                        const rowFromBottom = Math.floor((z - 1) / 3);
                        const col = (z - 1) % 3;
                        const rowFromTop = 5 - rowFromBottom;

                        ctx.fillStyle = `rgba(10,63,134,${alpha.toFixed(3)})`;
                        ctx.fillRect(col * zoneW, rowFromTop * zoneH, zoneW, zoneH);
                    }
                    ctx.restore();
                }
            } else {
                const pr = Math.max(3, w * 0.010);
                ctx.save();
                ctx.globalAlpha = 0.80;
                ctx.fillStyle = 'rgba(10,63,134,0.70)';
                ctx.strokeStyle = 'rgba(255,255,255,0.85)';
                ctx.lineWidth = Math.max(1, w * 0.0025);
                for (const r of recoveries) {
                    const pt = toCanvas(r.x_coord, r.y_coord, w, h);
                    if (!pt) continue;
                    const { cx, cy } = pt;
                    ctx.beginPath();
                    ctx.arc(cx, cy, pr, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                }
                ctx.restore();
            }

            return;
        }

        // Gegen den Ball: Block & Raumkontrolle -> Zentrum
        // Zeigt gegnerische erfolgreiche Pässe, deren Endpunkt im Final Third & Zentrum liegt.
        if (currentPhase === 'gb-block-zentrum') {
            drawPitch(canvas, false);

            // Match-IDs analog zu getEventsForTeam
            const teamGames = (dataset || []).filter(row => row && row.team === currentTeam);
            const uniqueMatchIds = [...new Set(teamGames.map(row => row.match_id))].sort().reverse();
            const matchesToAnalyze = uniqueMatchIds.slice(0, currentGameCount);
            const matchSet = new Set(matchesToAnalyze);

            const oppPasses = (eventDataset || [])
                .filter(e => e && matchSet.has(e.match_id) && e.team && e.team !== currentTeam)
                .filter(e => e.event_type === 'Pass' && e.outcome === 'Successful')
                .filter(e => e.x_coord != null && e.y_coord != null && e.end_x != null && e.end_y != null)
                // KPI-Definition: Endpunkt im Final Third (x>=66.6) & Zentrum (y in [33.3, 66.6))
                .filter(e => Number(e.end_x) >= 66.6 && Number(e.end_y) >= 33.3 && Number(e.end_y) < 66.6);

            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            const toNum = (v) => Number(v);
            const clamp = (v) => Math.max(0, Math.min(99.999, toNum(v)));

            // Diese Views zeigen zugelassene Pässe (vom Team, das gegen das Analyse-Team gespielt hat).
            // Darstellung soll immer unten -> oben sein, damit das Angriffsdrittel vor dem oberen Tor liegt.
            const toCanvasAllowed = (x, y) => {
                const xx = clamp(x);
                const yy = clamp(y);
                return {
                    cx: yy * (w / 100),
                    cy: (100 - xx) * (h / 100)
                };
            };

            if (globalViewMode === 'zones') {
                const counts = Array.from({ length: 18 }, () => 0);
                for (const p of oppPasses) {
                    const ex = clamp(p.end_x);
                    const ey = clamp(p.end_y);
                    const rowFromBottom = Math.floor((ex / 100) * 6);
                    const col = Math.floor((ey / 100) * 3);
                    const zone = rowFromBottom * 3 + col + 1;
                    if (zone >= 1 && zone <= 18) counts[zone - 1] += 1;
                }
                const maxV = Math.max(0, ...counts);
                if (maxV > 0) {
                    const zoneW = w / 3;
                    const zoneH = h / 6;
                    ctx.save();
                    for (let z = 1; z <= 18; z++) {
                        const v = counts[z - 1];
                        if (!v) continue;
                        const t = v / maxV;
                        const alpha = 0.08 + 0.55 * t;

                        const rowFromBottom = Math.floor((z - 1) / 3);
                        const col = (z - 1) % 3;
                        const rowFromTop = 5 - rowFromBottom;

                        ctx.fillStyle = `rgba(10,63,134,${alpha.toFixed(3)})`;
                        ctx.fillRect(col * zoneW, rowFromTop * zoneH, zoneW, zoneH);
                    }
                    ctx.restore();
                }
            } else {
                // Detail: Pfeile
                const BLUE = 'rgba(10,63,134,0.55)';
                const lw = Math.min(Math.max(1.2, w * 0.0035), 3.2);
                const ah = Math.min(9, Math.max(6, w * 0.018));

                const drawArrow = (sx, sy, ex, ey) => {
                    const dx = ex - sx;
                    const dy = ey - sy;
                    const ang = Math.atan2(dy, dx);
                    ctx.beginPath();
                    ctx.moveTo(sx, sy);
                    ctx.lineTo(ex, ey);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(ex, ey);
                    ctx.lineTo(ex - ah * Math.cos(ang - Math.PI / 7), ey - ah * Math.sin(ang - Math.PI / 7));
                    ctx.lineTo(ex - ah * Math.cos(ang + Math.PI / 7), ey - ah * Math.sin(ang + Math.PI / 7));
                    ctx.closePath();
                    ctx.fill();
                };

                ctx.save();
                ctx.globalAlpha = 0.95;
                ctx.strokeStyle = BLUE;
                ctx.fillStyle = BLUE;
                ctx.lineWidth = lw;
                ctx.lineCap = 'round';
                for (const p of oppPasses) {
                    const s = toCanvasAllowed(p.x_coord, p.y_coord);
                    const e = toCanvasAllowed(p.end_x, p.end_y);
                    drawArrow(s.cx, s.cy, e.cx, e.cy);
                }
                ctx.restore();
            }

            return;
        }

        // Gegen den Ball: Block & Raumkontrolle -> Halbräume
        // Zeigt gegnerische erfolgreiche Pässe, deren Endpunkt im Final Third & (linker/rechter) Halbraum liegt.
        if (currentPhase === 'gb-block-halbraeume') {
            drawPitch(canvas, false);

            // Match-IDs analog zu getEventsForTeam
            const teamGames = (dataset || []).filter(row => row && row.team === currentTeam);
            const uniqueMatchIds = [...new Set(teamGames.map(row => row.match_id))].sort().reverse();
            const matchesToAnalyze = uniqueMatchIds.slice(0, currentGameCount);
            const matchSet = new Set(matchesToAnalyze);

            const oppPasses = (eventDataset || [])
                .filter(e => e && matchSet.has(e.match_id) && e.team && e.team !== currentTeam)
                .filter(e => e.event_type === 'Pass' && e.outcome === 'Successful')
                .filter(e => e.x_coord != null && e.y_coord != null && e.end_x != null && e.end_y != null)
                // KPI-Definition: Endpunkt im Final Third (x>=66.6) & Halbräume (y in [16.7,33.3) oder [66.6,83.3))
                .filter(e => {
                    const ex = Number(e.end_x);
                    const ey = Number(e.end_y);
                    if (!(ex >= 66.6)) return false;
                    const leftHS = (ey >= 16.7 && ey < 33.3);
                    const rightHS = (ey >= 66.6 && ey < 83.3);
                    return leftHS || rightHS;
                });

            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            const toNum = (v) => Number(v);
            const clamp = (v) => Math.max(0, Math.min(99.999, toNum(v)));

            // Zugelassene Pässe: immer unten -> oben rendern (Angriffsdrittel vor oberem Tor).
            const toCanvasAllowed = (x, y) => {
                const xx = clamp(x);
                const yy = clamp(y);
                return {
                    cx: yy * (w / 100),
                    cy: (100 - xx) * (h / 100)
                };
            };

            if (globalViewMode === 'zones') {
                const counts = Array.from({ length: 18 }, () => 0);
                for (const p of oppPasses) {
                    const ex = clamp(p.end_x);
                    const ey = clamp(p.end_y);
                    const rowFromBottom = Math.floor((ex / 100) * 6);
                    const col = Math.floor((ey / 100) * 3);
                    const zone = rowFromBottom * 3 + col + 1;
                    if (zone >= 1 && zone <= 18) counts[zone - 1] += 1;
                }
                const maxV = Math.max(0, ...counts);
                if (maxV > 0) {
                    const zoneW = w / 3;
                    const zoneH = h / 6;
                    ctx.save();
                    for (let z = 1; z <= 18; z++) {
                        const v = counts[z - 1];
                        if (!v) continue;
                        const t = v / maxV;
                        const alpha = 0.08 + 0.55 * t;

                        const rowFromBottom = Math.floor((z - 1) / 3);
                        const col = (z - 1) % 3;
                        const rowFromTop = 5 - rowFromBottom;

                        ctx.fillStyle = `rgba(10,63,134,${alpha.toFixed(3)})`;
                        ctx.fillRect(col * zoneW, rowFromTop * zoneH, zoneW, zoneH);
                    }
                    ctx.restore();
                }
            } else {
                // Detail: Pfeile
                const BLUE = 'rgba(10,63,134,0.55)';
                const lw = Math.min(Math.max(1.2, w * 0.0035), 3.2);
                const ah = Math.min(9, Math.max(6, w * 0.018));

                const drawArrow = (sx, sy, ex, ey) => {
                    const dx = ex - sx;
                    const dy = ey - sy;
                    const ang = Math.atan2(dy, dx);
                    ctx.beginPath();
                    ctx.moveTo(sx, sy);
                    ctx.lineTo(ex, ey);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(ex, ey);
                    ctx.lineTo(ex - ah * Math.cos(ang - Math.PI / 7), ey - ah * Math.sin(ang - Math.PI / 7));
                    ctx.lineTo(ex - ah * Math.cos(ang + Math.PI / 7), ey - ah * Math.sin(ang + Math.PI / 7));
                    ctx.closePath();
                    ctx.fill();
                };

                ctx.save();
                ctx.globalAlpha = 0.95;
                ctx.strokeStyle = BLUE;
                ctx.fillStyle = BLUE;
                ctx.lineWidth = lw;
                ctx.lineCap = 'round';
                for (const p of oppPasses) {
                    const s = toCanvasAllowed(p.x_coord, p.y_coord);
                    const e = toCanvasAllowed(p.end_x, p.end_y);
                    drawArrow(s.cx, s.cy, e.cx, e.cy);
                }
                ctx.restore();
            }

            return;
        }

        // Gegen den Ball: Block & Raumkontrolle -> Flügel
        // Zeigt gegnerische erfolgreiche Pässe, deren Endpunkt im Final Third & Flügel liegt.
        if (currentPhase === 'gb-block-fluegel') {
            drawPitch(canvas, false);

            // Match-IDs analog zu getEventsForTeam
            const teamGames = (dataset || []).filter(row => row && row.team === currentTeam);
            const uniqueMatchIds = [...new Set(teamGames.map(row => row.match_id))].sort().reverse();
            const matchesToAnalyze = uniqueMatchIds.slice(0, currentGameCount);
            const matchSet = new Set(matchesToAnalyze);

            const oppPasses = (eventDataset || [])
                .filter(e => e && matchSet.has(e.match_id) && e.team && e.team !== currentTeam)
                .filter(e => e.event_type === 'Pass' && e.outcome === 'Successful')
                .filter(e => e.x_coord != null && e.y_coord != null && e.end_x != null && e.end_y != null)
                // KPI-Definition: Endpunkt im Final Third (x>=66.6) & Flügel (y in [0,16.7) oder [83.3,100])
                .filter(e => {
                    const ex = Number(e.end_x);
                    const ey = Number(e.end_y);
                    if (!(ex >= 66.6)) return false;
                    const leftWing = (ey >= 0 && ey < 16.7);
                    const rightWing = (ey >= 83.3 && ey <= 100);
                    return leftWing || rightWing;
                });

            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            const toNum = (v) => Number(v);
            const clamp = (v) => Math.max(0, Math.min(99.999, toNum(v)));

            // Zugelassene Pässe: immer unten -> oben rendern (Angriffsdrittel vor oberem Tor).
            const toCanvasAllowed = (x, y) => {
                const xx = clamp(x);
                const yy = clamp(y);
                return {
                    cx: yy * (w / 100),
                    cy: (100 - xx) * (h / 100)
                };
            };

            if (globalViewMode === 'zones') {
                const counts = Array.from({ length: 18 }, () => 0);
                for (const p of oppPasses) {
                    const ex = clamp(p.end_x);
                    const ey = clamp(p.end_y);
                    const rowFromBottom = Math.floor((ex / 100) * 6);
                    const col = Math.floor((ey / 100) * 3);
                    const zone = rowFromBottom * 3 + col + 1;
                    if (zone >= 1 && zone <= 18) counts[zone - 1] += 1;
                }
                const maxV = Math.max(0, ...counts);
                if (maxV > 0) {
                    const zoneW = w / 3;
                    const zoneH = h / 6;
                    ctx.save();
                    for (let z = 1; z <= 18; z++) {
                        const v = counts[z - 1];
                        if (!v) continue;
                        const t = v / maxV;
                        const alpha = 0.08 + 0.55 * t;

                        const rowFromBottom = Math.floor((z - 1) / 3);
                        const col = (z - 1) % 3;
                        const rowFromTop = 5 - rowFromBottom;

                        ctx.fillStyle = `rgba(10,63,134,${alpha.toFixed(3)})`;
                        ctx.fillRect(col * zoneW, rowFromTop * zoneH, zoneW, zoneH);
                    }
                    ctx.restore();
                }
            } else {
                // Detail: Pfeile
                const BLUE = 'rgba(10,63,134,0.55)';
                const lw = Math.min(Math.max(1.2, w * 0.0035), 3.2);
                const ah = Math.min(9, Math.max(6, w * 0.018));

                const drawArrow = (sx, sy, ex, ey) => {
                    const dx = ex - sx;
                    const dy = ey - sy;
                    const ang = Math.atan2(dy, dx);
                    ctx.beginPath();
                    ctx.moveTo(sx, sy);
                    ctx.lineTo(ex, ey);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(ex, ey);
                    ctx.lineTo(ex - ah * Math.cos(ang - Math.PI / 7), ey - ah * Math.sin(ang - Math.PI / 7));
                    ctx.lineTo(ex - ah * Math.cos(ang + Math.PI / 7), ey - ah * Math.sin(ang + Math.PI / 7));
                    ctx.closePath();
                    ctx.fill();
                };

                ctx.save();
                ctx.globalAlpha = 0.95;
                ctx.strokeStyle = BLUE;
                ctx.fillStyle = BLUE;
                ctx.lineWidth = lw;
                ctx.lineCap = 'round';
                for (const p of oppPasses) {
                    const s = toCanvasAllowed(p.x_coord, p.y_coord);
                    const e = toCanvasAllowed(p.end_x, p.end_y);
                    drawArrow(s.cx, s.cy, e.cx, e.cy);
                }
                ctx.restore();
            }

            return;
        }

        // Gegen den Ball: Block & Raumkontrolle -> Blockhöhe
        // Zeigt alle Defensivaktionen als Punkte + Ø Defensivaktions-Höhe als gestrichelte Linie.
        if (currentPhase === 'gb-block-blockhoehe') {
            drawPitch(canvas, false);

            const defActionTypes = new Set(['Tackle', 'Interception', 'BallRecovery', 'Clearance', 'BlockedPass', 'Block', 'Foul']);
            const defActions = (dataPoints || [])
                .filter(e => e && e.x_coord != null && e.y_coord != null)
                .filter(e => defActionTypes.has(e.event_type));

            const toNum = (v) => Number(v);
            const clamp = (v) => Math.max(0, Math.min(99.999, toNum(v)));

            const xs = defActions.map(a => toNum(a.x_coord)).filter(v => Number.isFinite(v));
            const avgX = xs.length ? (xs.reduce((a, b) => a + b, 0) / xs.length) : null;

            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;

            if (globalViewMode === 'zones') {
                const counts = Array.from({ length: 18 }, () => 0);
                for (const e of defActions) {
                    const p = toZoneBin(e.x_coord, e.y_coord);
                    if (!p) continue;
                    const x = p.x;
                    const y = p.y;
                    const rowFromBottom = Math.floor((x / 100) * 6);
                    const col = Math.floor((y / 100) * 3);
                    const zone = rowFromBottom * 3 + col + 1;
                    if (zone >= 1 && zone <= 18) counts[zone - 1] += 1;
                }
                const maxV = Math.max(0, ...counts);
                if (maxV > 0) {
                    const zoneW = w / 3;
                    const zoneH = h / 6;
                    ctx.save();
                    for (let z = 1; z <= 18; z++) {
                        const v = counts[z - 1];
                        if (!v) continue;
                        const t = v / maxV;
                        const alpha = 0.08 + 0.55 * t;

                        const rowFromBottom = Math.floor((z - 1) / 3);
                        const col = (z - 1) % 3;
                        const rowFromTop = 5 - rowFromBottom;

                        ctx.fillStyle = `rgba(10,63,134,${alpha.toFixed(3)})`;
                        ctx.fillRect(col * zoneW, rowFromTop * zoneH, zoneW, zoneH);
                    }
                    ctx.restore();
                }
            } else {
                const pr = Math.max(3, w * 0.010);
                ctx.save();
                ctx.globalAlpha = 0.80;
                ctx.fillStyle = 'rgba(10,63,134,0.70)';
                ctx.strokeStyle = 'rgba(255,255,255,0.85)';
                ctx.lineWidth = Math.max(1, w * 0.0025);
                for (const e of defActions) {
                    const pt = toCanvas(e.x_coord, e.y_coord, w, h);
                    if (!pt) continue;
                    const { cx, cy } = pt;
                    ctx.beginPath();
                    ctx.arc(cx, cy, pr, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                }
                ctx.restore();
            }

            // dashed average line + label
            if (avgX != null && Number.isFinite(avgX)) {
                const yLine = toCanvas(avgX, 50, w, h)?.cy;
                if (yLine == null) return;
                ctx.save();
                ctx.strokeStyle = 'rgba(10,63,134,0.95)';
                ctx.lineWidth = Math.max(2, w * 0.004);
                ctx.setLineDash([Math.max(6, w * 0.025), Math.max(4, w * 0.018)]);
                ctx.beginPath();
                ctx.moveTo(0, yLine);
                ctx.lineTo(w, yLine);
                ctx.stroke();
                ctx.setLineDash([]);

                const label = `Ø Defensivaktions-Höhe: ${avgX.toFixed(1)}`;
                const padX = 6;
                const padY = 3;
                const fontSize = Math.max(10, Math.min(13, Math.round(w * 0.030)));
                ctx.font = `700 ${fontSize}px Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif`;
                const tw = ctx.measureText(label).width;
                const bx = 8;
                const by = Math.max(8, Math.min(h - (fontSize + padY * 2 + 8), yLine - (fontSize + padY * 2 + 6)));
                ctx.fillStyle = 'rgba(255,255,255,0.88)';
                ctx.fillRect(bx, by, tw + padX * 2, fontSize + padY * 2);
                ctx.fillStyle = '#0A3F86';
                ctx.textBaseline = 'top';
                ctx.fillText(label, bx + padX, by + padY);
                ctx.restore();
            }

            return;
        }

        // Gegen den Ball: Block & Raumkontrolle -> Kompaktheit
        // Visualisiert Breiten-Streuung (Std y) und Tiefen-Streuung (Std x) anhand Defensivaktionen.
        if (currentPhase === 'gb-block-kompaktheit') {
            drawPitch(canvas, false);

            const defActionTypes = new Set(['Tackle', 'Interception', 'BallRecovery', 'Clearance', 'BlockedPass', 'Block', 'Foul']);
            const defActions = (dataPoints || [])
                .filter(e => e && e.x_coord != null && e.y_coord != null)
                .filter(e => defActionTypes.has(e.event_type));

            const toNum = (v) => Number(v);
            const clamp = (v) => Math.max(0, Math.min(99.999, toNum(v)));

            const xs = defActions.map(a => toNum(a.x_coord)).filter(v => Number.isFinite(v));
            const ys = defActions.map(a => toNum(a.y_coord)).filter(v => Number.isFinite(v));
            const mean = (arr) => arr.length ? (arr.reduce((a, b) => a + b, 0) / arr.length) : null;
            const std = (arr, m) => {
                if (!arr.length || m == null) return null;
                const v = arr.reduce((acc, x) => acc + Math.pow(x - m, 2), 0) / arr.length;
                return Math.sqrt(v);
            };

            const meanX = mean(xs);
            const meanY = mean(ys);
            const stdX = std(xs, meanX); // Tiefe
            const stdY = std(ys, meanY); // Breite

            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;

            // Optional: Zonen-Heatmap nach Defensivaktionen
            if (globalViewMode === 'zones') {
                const counts = Array.from({ length: 18 }, () => 0);
                for (const e of defActions) {
                    const p = toZoneBin(e.x_coord, e.y_coord);
                    if (!p) continue;
                    const x = p.x;
                    const y = p.y;
                    const rowFromBottom = Math.floor((x / 100) * 6);
                    const col = Math.floor((y / 100) * 3);
                    const zone = rowFromBottom * 3 + col + 1;
                    if (zone >= 1 && zone <= 18) counts[zone - 1] += 1;
                }
                const maxV = Math.max(0, ...counts);
                if (maxV > 0) {
                    const zoneW = w / 3;
                    const zoneH = h / 6;
                    ctx.save();
                    for (let z = 1; z <= 18; z++) {
                        const v = counts[z - 1];
                        if (!v) continue;
                        const t = v / maxV;
                        const alpha = 0.08 + 0.55 * t;

                        const rowFromBottom = Math.floor((z - 1) / 3);
                        const col = (z - 1) % 3;
                        const rowFromTop = 5 - rowFromBottom;

                        ctx.fillStyle = `rgba(10,63,134,${alpha.toFixed(3)})`;
                        ctx.fillRect(col * zoneW, rowFromTop * zoneH, zoneW, zoneH);
                    }
                    ctx.restore();
                }
            } else {
                // Detail: Punkte für Defensivaktionen (leicht transparent)
                const pr = Math.max(3, w * 0.010);
                ctx.save();
                ctx.globalAlpha = 0.45;
                ctx.fillStyle = 'rgba(10,63,134,0.70)';
                ctx.strokeStyle = 'rgba(255,255,255,0.75)';
                ctx.lineWidth = Math.max(1, w * 0.0022);
                for (const e of defActions) {
                    const pt = toCanvas(e.x_coord, e.y_coord, w, h);
                    if (!pt) continue;
                    const { cx, cy } = pt;
                    ctx.beginPath();
                    ctx.arc(cx, cy, pr, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                }
                ctx.restore();
            }

            // 1σ-Box + Centerpunkt (Breite=2*stdY, Tiefe=2*stdX)
            if (meanX != null && meanY != null && stdX != null && stdY != null && Number.isFinite(meanX) && Number.isFinite(meanY)) {
                const cpt = toCanvas(meanX, meanY, w, h);
                if (!cpt) return;
                const cx = cpt.cx;
                const cy = cpt.cy;
                const boxW = (2 * stdY) * (w / 100);
                const boxH = (2 * stdX) * (h / 100);

                ctx.save();
                ctx.strokeStyle = 'rgba(10,63,134,0.95)';
                ctx.lineWidth = Math.max(2, w * 0.004);
                ctx.setLineDash([Math.max(6, w * 0.025), Math.max(4, w * 0.018)]);
                ctx.strokeRect(cx - boxW / 2, cy - boxH / 2, boxW, boxH);
                ctx.setLineDash([]);

                // Center marker
                const r = Math.max(3, w * 0.010);
                ctx.fillStyle = 'rgba(10,63,134,0.95)';
                ctx.strokeStyle = 'rgba(255,255,255,0.90)';
                ctx.lineWidth = Math.max(1, w * 0.0025);
                ctx.beginPath();
                ctx.arc(cx, cy, r, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();

                // Label
                const label1 = `Breite (Std y): ${stdY.toFixed(1)}`;
                const label2 = `Tiefe (Std x): ${stdX.toFixed(1)}`;
                const padX = 6;
                const padY = 3;
                const fontSize = Math.max(10, Math.min(13, Math.round(w * 0.030)));
                ctx.font = `700 ${fontSize}px Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif`;
                const tw = Math.max(ctx.measureText(label1).width, ctx.measureText(label2).width);
                const boxH2 = fontSize * 2 + padY * 3;
                const bx = 8;
                const by = 8;
                ctx.fillStyle = 'rgba(255,255,255,0.88)';
                ctx.fillRect(bx, by, tw + padX * 2, boxH2);
                ctx.fillStyle = '#0A3F86';
                ctx.textBaseline = 'top';
                ctx.fillText(label1, bx + padX, by + padY);
                ctx.fillText(label2, bx + padX, by + padY + fontSize + padY);
                ctx.restore();
            }

            return;
        }
        
        const drawBallmagnetMarker = () => {
            // Ballmagnet: Grafik im Pitch deaktiviert (nur Liste rechts).
            return;
            const markers = (ballmagnetTopMetas || []).filter(m => m && m.avgX != null && m.avgY != null).slice(0, 3);
            if (!markers.length) return;

            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            const rOuter = Math.max(7, w * 0.022);
            const rInner = Math.max(4, w * 0.013);
            const lw = Math.max(2, w * 0.006);

            ctx.save();
            for (let i = 0; i < markers.length; i++) {
                const m = markers[i];
                const dispX = (currentTeam !== baseTeam) ? (100 - Number(m.avgX)) : Number(m.avgX);
                const dispY = (currentTeam !== baseTeam) ? (100 - Number(m.avgY)) : Number(m.avgY);
                if (!Number.isFinite(dispX) || !Number.isFinite(dispY)) continue;
                const cx = dispY * (w / 100);
                const cy = dispX * (h / 100);

                // outer ring
                ctx.beginPath();
                ctx.arc(cx, cy, rOuter, 0, 2 * Math.PI);
                ctx.fillStyle = 'rgba(255,255,255,0.88)';
                ctx.fill();
                ctx.lineWidth = lw;
                ctx.strokeStyle = '#0A3F86';
                ctx.stroke();

                // inner dot
                ctx.beginPath();
                ctx.arc(cx, cy, rInner, 0, 2 * Math.PI);
                ctx.fillStyle = '#0A3F86';
                ctx.fill();

                // rank label 1..3
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const fs = Math.max(9, Math.min(13, Math.round(w * 0.03)));
                ctx.font = `700 ${fs}px Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif`;
                ctx.fillText(String(i + 1), cx, cy);
            }
            ctx.restore();
        };

        // Fallback-Ansicht: Für Spieltempo und Build-up Attack gibt es aktuell keine eigene Grafik.
        // => Immer nur Pitch + 18-Zonen anzeigen (unabhängig vom Detail/Zonen-Switch).
        if (currentPhase === 'spieltempo' || currentPhase === 'build-up-attack') {
            drawPitch(canvas, false);
            drawBallmagnetMarker();
            return;
        }

        // Standard: nur Feld + 18-Zonen, keine Aktionen
        // Ausnahmen: Standards + Eckball/Einwurf -> wir zeichnen Aktionen als Pfeile
        if (!currentPhase || currentPhase === 'mit-ball' || currentPhase === 'gegen-ball' || (currentPhase === 'standards' && lastOpenCornerTab !== 'eckball' && lastOpenCornerTab !== 'einwurf' && lastOpenCornerTab !== 'freistoss') || currentPhase === 'physisch') {
            drawPitch(canvas, false);
            drawBallmagnetMarker();
            return;
        }

        // Für Analyse-Phasen mit Aktionen: Feld ohne Nummern + Aktionen zeichnen
        // Ausnahme: Standards -> Eckball: Half-View
        // - mit-ball  => nur untere Hälfte sichtbar
        // - gegen-ball => nur obere Hälfte sichtbar
        const isEckballHalf = (currentPhase === 'standards' && lastOpenCornerTab === 'eckball' && (standardsMode === 'mit-ball' || standardsMode === 'gegen-ball'));
        if (!isEckballHalf) {
            drawPitch(canvas, true);
        }

        if (currentPhase === 'abstöße') {
            drawActionLines(canvas.getContext('2d'), dataPoints, canvas.width, canvas.height);
        } else if (currentPhase === 'standards' && lastOpenCornerTab === 'eckball') {
            // Zeichne Eckbälle als Pfeile (Detail) oder als Zonen-Heatmap (Zonen)
            // Wichtig: needsInversion muss hier lokal bestimmt werden (sonst ReferenceError).
            const needsInversion = (currentTeam !== baseTeam);
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;

            // Half-View für Standards-Eckball:
            // - mit-ball: untere Hälfte
            // - gegen-ball: obere Hälfte
            const useHalfView = (standardsMode === 'mit-ball' || standardsMode === 'gegen-ball');
            const halfY0 = useHalfView ? ((standardsMode === 'gegen-ball') ? 0 : (h / 2)) : 0;
            const halfH = useHalfView ? (h / 2) : h;

            if (useHalfView) {
                // Canvas komplett weiß, dann nur die untere Hälfte zeichnen.
                ctx.save();
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.globalAlpha = 1;
                ctx.globalCompositeOperation = 'source-over';
                ctx.setLineDash([]);
                ctx.clearRect(0, 0, w, h);
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, w, h);
                ctx.restore();

                // Pitch-Elemente strikt auf die untere Hälfte clippen
                ctx.save();
                ctx.beginPath();
                ctx.rect(0, halfY0, w, halfH);
                ctx.clip();

                // Rahmen (Mittellinie = obere Kante der sichtbaren Hälfte)
                ctx.strokeStyle = LINE_COLOR;
                ctx.lineWidth = Math.max(1, w * 0.005);
                ctx.lineCap = 'round';
                ctx.setLineDash([]);
                ctx.strokeRect(0, halfY0, w, halfH);

                // Strafraum/Fünfmeterraum an der Torlinie der sichtbaren Hälfte
                const penaltyBoxHeight = halfH * (16.5 / 52.5);
                const penaltyBoxWidth = w * (40.3 / 68);
                const penaltyBoxX = (w - penaltyBoxWidth) / 2;
                const goalBoxHeight = halfH * (5.5 / 52.5);
                const goalBoxWidth = w * (18.32 / 68);
                const goalBoxX = (w - goalBoxWidth) / 2;

                if (standardsMode === 'gegen-ball') {
                    // Tor oben
                    ctx.strokeRect(penaltyBoxX, halfY0, penaltyBoxWidth, penaltyBoxHeight);
                    ctx.strokeRect(goalBoxX, halfY0, goalBoxWidth, goalBoxHeight);
                } else {
                    // Tor unten
                    ctx.strokeRect(penaltyBoxX, halfY0 + (halfH - penaltyBoxHeight), penaltyBoxWidth, penaltyBoxHeight);
                    ctx.strokeRect(goalBoxX, halfY0 + (halfH - goalBoxHeight), goalBoxWidth, goalBoxHeight);
                }

                // Raster innerhalb der sichtbaren Hälfte (Halbspielfeld = 3x3)
                ctx.save();
                ctx.strokeStyle = 'rgba(156, 163, 175, 0.5)';
                ctx.lineWidth = Math.max(1, w * 0.0015);
                ctx.setLineDash([4, 4]);

                const rowsGrid = 3;
                ctx.beginPath();
                for (let i = 1; i < rowsGrid; i++) {
                    const yy = halfY0 + (halfH / rowsGrid) * i;
                    ctx.moveTo(0, yy);
                    ctx.lineTo(w, yy);
                }
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(w / 3, halfY0);
                ctx.lineTo(w / 3, halfY0 + halfH);
                ctx.moveTo((2 * w) / 3, halfY0);
                ctx.lineTo((2 * w) / 3, halfY0 + halfH);
                ctx.stroke();

                ctx.restore();
                // Clip bleibt aktiv bis wir fertig sind
            }

            const toCanvas = (xRaw, yRaw) => {
                const x = Number(xRaw);
                const y = Number(yRaw);
                if (!Number.isFinite(x) || !Number.isFinite(y)) return null;

                // Breite (links/rechts) wie im Haupt-Plot spiegeln, damit Team-Auswahl konsistent bleibt.
                const yAdj = needsInversion ? (100 - y) : y;
                const cx = yAdj * (w / 100);

                // Half-View: Länge (oben/unten) muss zur sichtbaren Hälfte passen.
                // - mit-ball: untere Hälfte zeigt x in [50..100] (Mittellinie -> Tor unten)
                // - gegen-ball: obere Hälfte zeigt x in [0..50] (Tor oben -> Mittellinie)
                if (useHalfView) {
                    let t;
                    if (standardsMode === 'gegen-ball') {
                        t = x / 50;            // 0..1
                    } else {
                        t = (x - 50) / 50;     // 0..1
                    }
                    const tt = Math.max(0, Math.min(1, t));
                    const cy = halfY0 + (tt * halfH);
                    return { cx, cy };
                }

                // Full-pitch Fallback (unverändert)
                const fullCy = needsInversion ? (x * (h / 100)) : ((100 - x) * (h / 100));
                return { cx, cy: fullCy };
            };

            // Sammle Ecken (eigene oder gegen uns) für das aktuelle Team und die gewählten Matches
            const teamEventsForViz = getStandardsEventsForTeam(currentTeam, currentGameCount, standardsMode) || [];
            const corners = teamEventsForViz.filter(e => e && e.is_corner === true);

            const rows = 16, cols = 12;
            const cellH = (useHalfView ? (halfH / rows) : (h / rows));
            const cellW = w / cols;
            const BLUE = 'rgba(10,63,134,0.85)';
            const RED = 'rgba(239,68,68,0.85)';
            const GREY = 'rgba(107,114,128,0.35)';

            function drawArrow(sx, sy, ex, ey, color) {
                const dx = ex - sx;
                const dy = ey - sy;
                const ang = Math.atan2(dy, dx);
                const lw = Math.min(Math.max(1.4, canvas.width * 0.004), 3.5);
                const ah = Math.min(10, Math.max(6, canvas.width * 0.02));

                ctx.strokeStyle = color;
                ctx.lineWidth = lw;
                ctx.beginPath();
                ctx.moveTo(sx, sy);
                ctx.lineTo(ex, ey);
                ctx.stroke();

                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.moveTo(ex, ey);
                ctx.lineTo(ex - ah * Math.cos(ang - Math.PI / 7), ey - ah * Math.sin(ang - Math.PI / 7));
                ctx.lineTo(ex - ah * Math.cos(ang + Math.PI / 7), ey - ah * Math.sin(ang + Math.PI / 7));
                ctx.closePath();
                ctx.fill();
            }

            if (globalViewMode === 'zones') {
                // Heatmap: Zielzonen der Ecken
                const counts = Array.from({ length: rows }, () => Array(cols).fill(0));
                for (const c of corners) {
                    if (c.end_x == null || c.end_y == null) continue;
                    const end = toCanvas(c.end_x, c.end_y);
                    if (!end) continue;
                    const localCy = useHalfView ? (end.cy - halfY0) : end.cy;
                    if (useHalfView && (localCy < 0 || localCy > halfH)) continue;
                    const r = Math.min(rows - 1, Math.max(0, Math.floor(localCy / cellH)));
                    const col = Math.min(cols - 1, Math.max(0, Math.floor(end.cx / cellW)));
                    counts[r][col] += 1;
                }
                const maxV = Math.max(1, ...counts.map(row => Math.max(0, ...row)));
                ctx.save();
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        const v = counts[r][c];
                        if (v <= 0) continue;
                        const t = v / maxV;
                        const alpha = 0.10 + 0.55 * t;
                        ctx.fillStyle = `rgba(10,63,134,${alpha.toFixed(3)})`;
                        ctx.fillRect(c * cellW, halfY0 + (r * cellH), cellW, cellH);
                    }
                }
                ctx.restore();

                // Pfeile grau drüber legen
                ctx.save();
                ctx.globalAlpha = 0.9;
                for (const c of corners) {
                    if (c.x_coord == null || c.y_coord == null || c.end_x == null || c.end_y == null) continue;
                    const s = toCanvas(c.x_coord, c.y_coord);
                    const e = toCanvas(c.end_x, c.end_y);
                    if (!s || !e) continue;
                    drawArrow(s.cx, s.cy, e.cx, e.cy, GREY);
                }
                ctx.restore();
            } else {
                // Detail: Pfeile farbig (Successful -> blau, sonst rot)
                ctx.save();
                ctx.globalAlpha = 0.95;
                for (const c of corners) {
                    if (c.x_coord == null || c.y_coord == null || c.end_x == null || c.end_y == null) continue;
                    const s = toCanvas(c.x_coord, c.y_coord);
                    const e = toCanvas(c.end_x, c.end_y);
                    if (!s || !e) continue;
                    const color = (c.outcome === 'Successful') ? BLUE : RED;
                    drawArrow(s.cx, s.cy, e.cx, e.cy, color);
                }
                ctx.restore();
            }

            // Clip aufheben (nur wenn Half-View aktiv)
            if (useHalfView) {
                ctx.restore();

                // Sicherheits-Wipe: ungenutzte Hälfte immer komplett weiß halten
                // (falls irgendwo versehentlich außerhalb des Clips gezeichnet wurde)
                ctx.save();
                ctx.globalAlpha = 1;
                ctx.globalCompositeOperation = 'source-over';
                ctx.setLineDash([]);
                ctx.fillStyle = '#ffffff';
                if (standardsMode === 'mit-ball') {
                    // obere Hälfte frei
                    ctx.fillRect(0, 0, w, h / 2);
                } else {
                    // untere Hälfte frei
                    ctx.fillRect(0, h / 2, w, h / 2);
                }
                ctx.restore();
            }

            // Zusatz-Visualisierung (nur Mit dem Ball): 4 kleine Felder im freien Bereich (obere Hälfte)
            // Layout:
            //   oben links  = In-Swing links
            //   oben rechts = In-Swing rechts
            //   unten links = Out-Swing links
            //   unten rechts= Out-Swing rechts
            if (useHalfView && standardsMode === 'mit-ball') {
                const freeY0 = 0;
                const freeH = h / 2;
                const m = Math.max(10, Math.round(w * 0.03));

                // Caption-Platz reservieren (kleiner, linksbündig an den Mini-Pitches)
                const capFs = Math.max(9, Math.min(12, Math.round(w * 0.026)));
                const capPad = Math.max(6, Math.round(w * 0.02));
                const capH = capFs + capPad;

                const panelW = (w - (m * 3)) / 2;
                // Wir brauchen zwei Caption-Zeilen (oben + zwischen den Reihen)
                const panelH = (freeH - (m * 3) - (capH * 2)) / 2;

                // Caption-Zeilen (als eigene, freie Zeilen)
                const cap1Y = freeY0 + m;
                const topPanelY = cap1Y + capH;
                const cap2Y = topPanelY + panelH + m;
                const bottomPanelY = cap2Y + capH;

                const panels = {
                    in_left:  { x: m,              y: topPanelY },
                    in_right: { x: m * 2 + panelW, y: topPanelY },
                    out_left: { x: m,              y: bottomPanelY },
                    out_right:{ x: m * 2 + panelW, y: bottomPanelY },
                };

                // Normalisiert Koordinaten so, dass beide Halbzeiten auf derselben Seite abgebildet werden.
                // Wichtig: Unsere Events sind bereits team-normalisiert (bei Ecken liegt x auch in HZ2 ~100).
                // Deshalb KEINE zusätzliche Halbzeit-Rotation durchführen.
                const normalizeCorner = (c) => {
                    const x0 = Number(c.x_coord);
                    const y0 = Number(c.y_coord);
                    const ex0 = (c.end_x == null) ? null : Number(c.end_x);
                    const ey0 = (c.end_y == null) ? null : Number(c.end_y);
                    if (!Number.isFinite(x0) || !Number.isFinite(y0) || !Number.isFinite(ex0) || !Number.isFinite(ey0)) return null;

                    // Align mini-panels with the main corner plot orientation.
                    // Main plot uses y-inversion when needsInversion=true (cx = 100 - y).
                    // Without mirroring y here, mini panels appear mirrored vs the big plot.
                    let x = x0, y = y0, ex = ex0, ey = ey0;
                    if (needsInversion) {
                        y = 100 - y;
                        ey = 100 - ey;
                    }

                    // Seite (links/rechts) immer konsistent
                    const side = (y < 50) ? 'left' : 'right';

                    // In/Out-Swing Heuristik ohne Fußdaten:
                    // - In-Swing: Ball endet eher in Richtung Spielfeldmitte (über die 50%-Breite hinaus)
                    // - Out-Swing: Ball bleibt eher auf der gleichen Seite
                    // (Dadurch sind die Out-Swing-Panels nicht leer und die Gruppierung ist stabil.)
                    const swing = (side === 'left')
                        ? ((ey >= 50) ? 'in' : 'out')
                        : ((ey <= 50) ? 'in' : 'out');

                    return { x, y, ex, ey, side, swing, outcome: c.outcome };
                };

                const inLeft = [];
                const inRight = [];
                const outLeft = [];
                const outRight = [];

                for (const c of corners) {
                    const n = normalizeCorner(c);
                    if (!n) continue;
                    if (n.swing === 'in' && n.side === 'left') inLeft.push(n);
                    else if (n.swing === 'in' && n.side === 'right') inRight.push(n);
                    else if (n.swing === 'out' && n.side === 'left') outLeft.push(n);
                    else if (n.swing === 'out' && n.side === 'right') outRight.push(n);
                }

                const totalMini = inLeft.length + inRight.length + outLeft.length + outRight.length;
                const pctOf = (n) => {
                    if (!totalMini) return 0;
                    return (n / totalMini) * 100;
                };

                const mapToPanel = (panel, xPct, yPct) => {
                    // xPct = Länge (0..100), yPct = Breite (0..100)
                    // Wir zeigen die angreifende Hälfte wie im Haupt-Plot (unten):
                    // x in [50..100] -> Panelhöhe, mit Torlinie unten (x=100 -> unten).
                    const t = (xPct - 50) / 50; // 0..1
                    const tt = Math.max(0, Math.min(1, t));
                    const px = panel.x + (yPct / 100) * panelW;
                    const py = panel.y + tt * panelH;
                    return { px, py };
                };

                const drawMiniPitch = (panel) => {
                    ctx.save();
                    ctx.beginPath();
                    ctx.rect(panel.x, panel.y, panelW, panelH);
                    ctx.clip();

                    ctx.strokeStyle = LINE_COLOR;
                    ctx.lineWidth = Math.max(1, w * 0.0035);
                    ctx.lineCap = 'round';
                    ctx.setLineDash([]);
                    ctx.strokeRect(panel.x, panel.y, panelW, panelH);

                    // Boxen am unteren Ende (Tor unten)
                    const pbH = panelH * (16.5 / 52.5);
                    const pbW = panelW * (40.3 / 68);
                    const pbX = panel.x + (panelW - pbW) / 2;
                    ctx.strokeRect(pbX, panel.y + (panelH - pbH), pbW, pbH);

                    const gbH = panelH * (5.5 / 52.5);
                    const gbW = panelW * (18.32 / 68);
                    const gbX = panel.x + (panelW - gbW) / 2;
                    ctx.strokeRect(gbX, panel.y + (panelH - gbH), gbW, gbH);

                    // Raster (gestrichelt)
                    ctx.save();
                    ctx.strokeStyle = 'rgba(156, 163, 175, 0.45)';
                    ctx.lineWidth = Math.max(1, w * 0.0012);
                    ctx.setLineDash([4, 4]);

                    const rowsGrid = 3;
                    ctx.beginPath();
                    for (let i = 1; i < rowsGrid; i++) {
                        const yy = panel.y + (panelH / rowsGrid) * i;
                        ctx.moveTo(panel.x, yy);
                        ctx.lineTo(panel.x + panelW, yy);
                    }
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(panel.x + panelW / 3, panel.y);
                    ctx.lineTo(panel.x + panelW / 3, panel.y + panelH);
                    ctx.moveTo(panel.x + (2 * panelW) / 3, panel.y);
                    ctx.lineTo(panel.x + (2 * panelW) / 3, panel.y + panelH);
                    ctx.stroke();

                    ctx.restore();
                    ctx.restore();
                };

                const drawMiniArrow = (sx, sy, ex, ey, color) => {
                    const dx = ex - sx;
                    const dy = ey - sy;
                    const ang = Math.atan2(dy, dx);
                    const lw = Math.min(Math.max(1.0, panelW * 0.010), 2.2);
                    const ah = Math.min(9, Math.max(5, panelW * 0.05));

                    ctx.strokeStyle = color;
                    ctx.lineWidth = lw;
                    ctx.beginPath();
                    ctx.moveTo(sx, sy);
                    ctx.lineTo(ex, ey);
                    ctx.stroke();

                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.moveTo(ex, ey);
                    ctx.lineTo(ex - ah * Math.cos(ang - Math.PI / 7), ey - ah * Math.sin(ang - Math.PI / 7));
                    ctx.lineTo(ex - ah * Math.cos(ang + Math.PI / 7), ey - ah * Math.sin(ang + Math.PI / 7));
                    ctx.closePath();
                    ctx.fill();
                };

                // Zeichnen: Mini-Pitches + Pfeile
                const MINI_BLUE = 'rgba(10,63,134,0.75)';
                const MINI_RED = 'rgba(239,68,68,0.75)';

                // Captions (linksbündig am jeweiligen Mini-Pitch)
                ctx.save();
                ctx.fillStyle = LINE_COLOR;
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                ctx.font = `600 ${capFs}px Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif`;
                ctx.fillText('Ecke links (Linksfuß) – zum Tor', panels.in_left.x, cap1Y);
                ctx.fillText('Ecke rechts (Rechtsfuß) – zum Tor', panels.in_right.x, cap1Y);

                ctx.fillText('Ecke links (Rechtsfuß) – vom Tor', panels.out_left.x, cap2Y);
                ctx.fillText('Ecke rechts (Linksfuß) – vom Tor', panels.out_right.x, cap2Y);
                ctx.restore();

                const drawPanelData = (panel, events) => {
                    drawMiniPitch(panel);
                    ctx.save();
                    ctx.beginPath();
                    ctx.rect(panel.x, panel.y, panelW, panelH);
                    ctx.clip();
                    for (const e of events) {
                        const s = mapToPanel(panel, e.x, e.y);
                        const t = mapToPanel(panel, e.ex, e.ey);
                        const color = (e.outcome === 'Successful') ? MINI_BLUE : MINI_RED;
                        drawMiniArrow(s.px, s.py, t.px, t.py, color);
                    }

                    // Prozent-Anteil mittig anzeigen
                    const pct = pctOf(events.length);
                    const pctText = `${Math.round(pct)}%`;
                    ctx.save();
                    ctx.globalAlpha = 0.55;
                    ctx.fillStyle = LINE_COLOR;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    const pctFs = Math.max(12, Math.min(18, Math.round(panelW * 0.10)));
                    ctx.font = `700 ${pctFs}px Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif`;
                    ctx.fillText(pctText, panel.x + panelW / 2, panel.y + panelH / 2);
                    ctx.restore();

                    ctx.restore();
                };

                // Panels nach Fuß (über In/Out-Heuristik gemappt):
                // TL: linke Ecke + linksfuß  => Out-Swing links
                // TR: rechte Ecke + rechtsfuß => Out-Swing rechts
                // BL: linke Ecke + rechtsfuß => In-Swing links
                // BR: rechte Ecke + linksfuß => In-Swing rechts
                drawPanelData(panels.in_left, outLeft);
                drawPanelData(panels.in_right, outRight);
                drawPanelData(panels.out_left, inLeft);
                drawPanelData(panels.out_right, inRight);
            }

            // Zusatz-Visualisierung (Gegen den Ball): 4 kleine Felder im freien Bereich (untere Hälfte)
            // Analog zu "Mit dem Ball" – nur mit gegnerischen Ecken (standardsMode=gegen-ball).
            // Orientierung passend zur sichtbaren Hälfte: Tor oben.
            if (useHalfView && standardsMode === 'gegen-ball') {
                const freeY0 = h / 2;
                const freeH = h / 2;
                const m = Math.max(10, Math.round(w * 0.03));

                // Caption-Platz reservieren (kleiner, linksbündig an den Mini-Pitches)
                const capFs = Math.max(9, Math.min(12, Math.round(w * 0.026)));
                const capPad = Math.max(6, Math.round(w * 0.02));
                const capH = capFs + capPad;

                const panelW = (w - (m * 3)) / 2;
                // Wir brauchen zwei Caption-Zeilen (oben + zwischen den Reihen)
                const panelH = (freeH - (m * 3) - (capH * 2)) / 2;

                // Caption-Zeilen (als eigene, freie Zeilen)
                const cap1Y = freeY0 + m;
                const topPanelY = cap1Y + capH;
                const cap2Y = topPanelY + panelH + m;
                const bottomPanelY = cap2Y + capH;

                const panels = {
                    in_left:  { x: m,              y: topPanelY },
                    in_right: { x: m * 2 + panelW, y: topPanelY },
                    out_left: { x: m,              y: bottomPanelY },
                    out_right:{ x: m * 2 + panelW, y: bottomPanelY },
                };

                const normalizeCorner = (c) => {
                    const x0 = Number(c.x_coord);
                    const y0 = Number(c.y_coord);
                    const ex0 = (c.end_x == null) ? null : Number(c.end_x);
                    const ey0 = (c.end_y == null) ? null : Number(c.end_y);
                    if (!Number.isFinite(x0) || !Number.isFinite(y0) || !Number.isFinite(ex0) || !Number.isFinite(ey0)) return null;

                    // Align mini-panels with the main corner plot orientation.
                    // Main plot uses y-inversion when needsInversion=true (cx = 100 - y).
                    let x = x0, y = y0, ex = ex0, ey = ey0;
                    if (needsInversion) {
                        y = 100 - y;
                        ey = 100 - ey;
                    }

                    const side = (y < 50) ? 'left' : 'right';
                    const swing = (side === 'left')
                        ? ((ey >= 50) ? 'in' : 'out')
                        : ((ey <= 50) ? 'in' : 'out');

                    return { x, y, ex, ey, side, swing, outcome: c.outcome };
                };

                const inLeft = [];
                const inRight = [];
                const outLeft = [];
                const outRight = [];

                for (const c of corners) {
                    const n = normalizeCorner(c);
                    if (!n) continue;
                    if (n.swing === 'in' && n.side === 'left') inLeft.push(n);
                    else if (n.swing === 'in' && n.side === 'right') inRight.push(n);
                    else if (n.swing === 'out' && n.side === 'left') outLeft.push(n);
                    else if (n.swing === 'out' && n.side === 'right') outRight.push(n);
                }

                const totalMini = inLeft.length + inRight.length + outLeft.length + outRight.length;
                const pctOf = (n) => {
                    if (!totalMini) return 0;
                    return (n / totalMini) * 100;
                };

                const mapToPanel = (panel, xPct, yPct) => {
                    // xPct = Länge (0..100), yPct = Breite (0..100)
                    // Gegen den Ball zeigen wir die *obere* Halbzeit: x in [0..50]
                    // Torlinie oben (x=0 -> oben), Mittellinie unten (x=50 -> unten).
                    const t = xPct / 50; // 0..1
                    const tt = Math.max(0, Math.min(1, t));
                    const px = panel.x + (yPct / 100) * panelW;
                    const py = panel.y + tt * panelH;
                    return { px, py };
                };

                const drawMiniPitch = (panel) => {
                    ctx.save();
                    ctx.beginPath();
                    ctx.rect(panel.x, panel.y, panelW, panelH);
                    ctx.clip();

                    ctx.strokeStyle = LINE_COLOR;
                    ctx.lineWidth = Math.max(1, w * 0.0035);
                    ctx.lineCap = 'round';
                    ctx.setLineDash([]);
                    ctx.strokeRect(panel.x, panel.y, panelW, panelH);

                    // Boxen am oberen Ende (Tor oben)
                    const pbH = panelH * (16.5 / 52.5);
                    const pbW = panelW * (40.3 / 68);
                    const pbX = panel.x + (panelW - pbW) / 2;
                    ctx.strokeRect(pbX, panel.y, pbW, pbH);

                    const gbH = panelH * (5.5 / 52.5);
                    const gbW = panelW * (18.32 / 68);
                    const gbX = panel.x + (panelW - gbW) / 2;
                    ctx.strokeRect(gbX, panel.y, gbW, gbH);

                    // Raster (gestrichelt)
                    ctx.save();
                    ctx.strokeStyle = 'rgba(156, 163, 175, 0.45)';
                    ctx.lineWidth = Math.max(1, w * 0.0012);
                    ctx.setLineDash([4, 4]);

                    const rowsGrid = 3;
                    ctx.beginPath();
                    for (let i = 1; i < rowsGrid; i++) {
                        const yy = panel.y + (panelH / rowsGrid) * i;
                        ctx.moveTo(panel.x, yy);
                        ctx.lineTo(panel.x + panelW, yy);
                    }
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(panel.x + panelW / 3, panel.y);
                    ctx.lineTo(panel.x + panelW / 3, panel.y + panelH);
                    ctx.moveTo(panel.x + (2 * panelW) / 3, panel.y);
                    ctx.lineTo(panel.x + (2 * panelW) / 3, panel.y + panelH);
                    ctx.stroke();

                    ctx.restore();
                    ctx.restore();
                };

                const drawMiniArrow = (sx, sy, ex, ey, color) => {
                    const dx = ex - sx;
                    const dy = ey - sy;
                    const ang = Math.atan2(dy, dx);
                    const lw = Math.min(Math.max(1.0, panelW * 0.010), 2.2);
                    const ah = Math.min(9, Math.max(5, panelW * 0.05));

                    ctx.strokeStyle = color;
                    ctx.lineWidth = lw;
                    ctx.beginPath();
                    ctx.moveTo(sx, sy);
                    ctx.lineTo(ex, ey);
                    ctx.stroke();

                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.moveTo(ex, ey);
                    ctx.lineTo(ex - ah * Math.cos(ang - Math.PI / 7), ey - ah * Math.sin(ang - Math.PI / 7));
                    ctx.lineTo(ex - ah * Math.cos(ang + Math.PI / 7), ey - ah * Math.sin(ang + Math.PI / 7));
                    ctx.closePath();
                    ctx.fill();
                };

                const MINI_BLUE = 'rgba(10,63,134,0.75)';
                const MINI_RED = 'rgba(239,68,68,0.75)';

                // Captions
                ctx.save();
                ctx.fillStyle = LINE_COLOR;
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                ctx.font = `600 ${capFs}px Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif`;
                ctx.fillText('Ecke links (Linksfuß) – zum Tor', panels.in_left.x, cap1Y);
                ctx.fillText('Ecke rechts (Rechtsfuß) – zum Tor', panels.in_right.x, cap1Y);
                ctx.fillText('Ecke links (Rechtsfuß) – vom Tor', panels.out_left.x, cap2Y);
                ctx.fillText('Ecke rechts (Linksfuß) – vom Tor', panels.out_right.x, cap2Y);
                ctx.restore();

                const drawPanelData = (panel, events) => {
                    drawMiniPitch(panel);
                    ctx.save();
                    ctx.beginPath();
                    ctx.rect(panel.x, panel.y, panelW, panelH);
                    ctx.clip();
                    for (const e of events) {
                        const s = mapToPanel(panel, e.x, e.y);
                        const t = mapToPanel(panel, e.ex, e.ey);
                        const color = (e.outcome === 'Successful') ? MINI_BLUE : MINI_RED;
                        drawMiniArrow(s.px, s.py, t.px, t.py, color);
                    }

                    // Prozent-Anteil mittig anzeigen
                    const pct = pctOf(events.length);
                    const pctText = `${Math.round(pct)}%`;
                    ctx.save();
                    ctx.globalAlpha = 0.55;
                    ctx.fillStyle = LINE_COLOR;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    const pctFs = Math.max(12, Math.min(18, Math.round(panelW * 0.10)));
                    ctx.font = `700 ${pctFs}px Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif`;
                    ctx.fillText(pctText, panel.x + panelW / 2, panel.y + panelH / 2);
                    ctx.restore();

                    ctx.restore();
                };

                // gleiche Panel-Zuordnung wie bei "Mit dem Ball"
                drawPanelData(panels.in_left, outLeft);
                drawPanelData(panels.in_right, outRight);
                drawPanelData(panels.out_left, inLeft);
                drawPanelData(panels.out_right, inRight);
            }

        } else if (currentPhase === 'standards' && lastOpenCornerTab === 'einwurf') {
            // Zeichne Einwürfe als Pfeile (blau = Successful, rot = Unsuccessful)
            const needsInversion = (currentTeam !== baseTeam);
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;

            const BLUE = 'rgba(10,63,134,0.85)';
            const RED = 'rgba(239,68,68,0.85)';

            const toCanvas = (xRaw, yRaw) => {
                const x = Number(xRaw);
                const y = Number(yRaw);
                if (!Number.isFinite(x) || !Number.isFinite(y)) return null;

                // Mapping wie im Eckball-Plot (Portrait Pitch):
                // Canvas-x folgt der Spielfeld-Breite (y), Canvas-y folgt der Spielfeld-Länge (x).
                const cx = needsInversion ? ((100 - y) * (w / 100)) : (y * (w / 100));
                const cy = needsInversion ? (x * (h / 100)) : ((100 - x) * (h / 100));
                return { cx, cy };
            };

            const drawArrow = (sx, sy, ex, ey, color) => {
                const dx = ex - sx;
                const dy = ey - sy;
                const ang = Math.atan2(dy, dx);
                const lw = Math.min(Math.max(1.4, canvas.width * 0.004), 3.5);
                const ah = Math.min(10, Math.max(6, canvas.width * 0.02));

                ctx.strokeStyle = color;
                ctx.lineWidth = lw;
                ctx.beginPath();
                ctx.moveTo(sx, sy);
                ctx.lineTo(ex, ey);
                ctx.stroke();

                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.moveTo(ex, ey);
                ctx.lineTo(ex - ah * Math.cos(ang - Math.PI / 7), ey - ah * Math.sin(ang - Math.PI / 7));
                ctx.lineTo(ex - ah * Math.cos(ang + Math.PI / 7), ey - ah * Math.sin(ang + Math.PI / 7));
                ctx.closePath();
                ctx.fill();
            };

            const teamEventsForViz = getStandardsEventsForTeam(currentTeam, currentGameCount, standardsMode) || [];
            const throwInsViz = teamEventsForViz.filter(e => e && e.is_throwin === true);

            // Zonen-Darstellung: 18-Zonen-Heatmap (6x3) basierend auf Startpunkten der Einwürfe
            // - Detail: Pfeile blau/rot
            // - Zonen : Heatmap blau + Pfeile grau
            if (globalViewMode === 'zones') {
                const rows = 6;
                const cols = 3;
                const cellH = h / rows;
                const cellW = w / cols;
                const counts = Array.from({ length: rows }, () => Array(cols).fill(0));
                for (const t of throwInsViz) {
                    if (t.x_coord == null || t.y_coord == null) continue;
                    const s = toCanvas(t.x_coord, t.y_coord);
                    if (!s) continue;
                    const r = Math.min(rows - 1, Math.max(0, Math.floor(s.cy / cellH)));
                    const c = Math.min(cols - 1, Math.max(0, Math.floor(s.cx / cellW)));
                    counts[r][c] += 1;
                }
                const maxV = Math.max(1, ...counts.map(row => Math.max(0, ...row)));
                ctx.save();
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        const v = counts[r][c];
                        if (v <= 0) continue;
                        const t = v / maxV;
                        const alpha = 0.10 + 0.55 * t;
                        ctx.fillStyle = `rgba(10,63,134,${alpha.toFixed(3)})`;
                        ctx.fillRect(c * cellW, r * cellH, cellW, cellH);
                    }
                }
                ctx.restore();
            }

            ctx.save();
            ctx.globalAlpha = 0.95;
            for (const t of throwInsViz) {
                if (t.x_coord == null || t.y_coord == null || t.end_x == null || t.end_y == null) continue;
                const s = toCanvas(t.x_coord, t.y_coord);
                const e = toCanvas(t.end_x, t.end_y);
                if (!s || !e) continue;
                const color = (globalViewMode === 'zones')
                    ? 'rgba(107,114,128,0.40)'
                    : ((t.outcome === 'Successful') ? BLUE : RED);
                drawArrow(s.cx, s.cy, e.cx, e.cy, color);
            }
            ctx.restore();
        } else if (currentPhase === 'standards' && lastOpenCornerTab === 'freistoss') {
            // Zeichne Freistöße als Pfeile (blau = Successful, rot = Unsuccessful)
            const needsInversion = (currentTeam !== baseTeam);
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;

            const BLUE = 'rgba(10,63,134,0.85)';
            const RED = 'rgba(239,68,68,0.85)';

            const toCanvas = (xRaw, yRaw) => {
                const x = Number(xRaw);
                const y = Number(yRaw);
                if (!Number.isFinite(x) || !Number.isFinite(y)) return null;

                // Portrait Pitch Mapping (wie Eckball/Einwurf):
                const cx = needsInversion ? ((100 - y) * (w / 100)) : (y * (w / 100));
                const cy = needsInversion ? (x * (h / 100)) : ((100 - x) * (h / 100));
                return { cx, cy };
            };

            const drawArrow = (sx, sy, ex, ey, color) => {
                const dx = ex - sx;
                const dy = ey - sy;
                const ang = Math.atan2(dy, dx);
                const lw = Math.min(Math.max(1.4, canvas.width * 0.004), 3.5);
                const ah = Math.min(10, Math.max(6, canvas.width * 0.02));

                ctx.strokeStyle = color;
                ctx.lineWidth = lw;
                ctx.beginPath();
                ctx.moveTo(sx, sy);
                ctx.lineTo(ex, ey);
                ctx.stroke();

                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.moveTo(ex, ey);
                ctx.lineTo(ex - ah * Math.cos(ang - Math.PI / 7), ey - ah * Math.sin(ang - Math.PI / 7));
                ctx.lineTo(ex - ah * Math.cos(ang + Math.PI / 7), ey - ah * Math.sin(ang + Math.PI / 7));
                ctx.closePath();
                ctx.fill();
            };

            const teamEventsForViz = getStandardsEventsForTeam(currentTeam, currentGameCount, standardsMode) || [];
            const fkViz = teamEventsForViz.filter(e => e && e.is_freekick === true);

            // Zonen-Darstellung: 18-Zonen-Heatmap (6x3) basierend auf Startpunkten der Freistöße
            // - Detail: Pfeile blau/rot
            // - Zonen : Heatmap blau + Pfeile grau
            if (globalViewMode === 'zones') {
                const rows = 6;
                const cols = 3;
                const cellH = h / rows;
                const cellW = w / cols;
                const counts = Array.from({ length: rows }, () => Array(cols).fill(0));
                for (const f of fkViz) {
                    if (f.x_coord == null || f.y_coord == null) continue;
                    const s = toCanvas(f.x_coord, f.y_coord);
                    if (!s) continue;
                    const r = Math.min(rows - 1, Math.max(0, Math.floor(s.cy / cellH)));
                    const c = Math.min(cols - 1, Math.max(0, Math.floor(s.cx / cellW)));
                    counts[r][c] += 1;
                }
                const maxV = Math.max(1, ...counts.map(row => Math.max(0, ...row)));
                ctx.save();
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        const v = counts[r][c];
                        if (v <= 0) continue;
                        const t = v / maxV;
                        const alpha = 0.10 + 0.55 * t;
                        ctx.fillStyle = `rgba(10,63,134,${alpha.toFixed(3)})`;
                        ctx.fillRect(c * cellW, r * cellH, cellW, cellH);
                    }
                }
                ctx.restore();
            }

            ctx.save();
            ctx.globalAlpha = 0.95;
            for (const f of fkViz) {
                if (f.x_coord == null || f.y_coord == null || f.end_x == null || f.end_y == null) continue;
                const s = toCanvas(f.x_coord, f.y_coord);
                const e = toCanvas(f.end_x, f.end_y);
                if (!s || !e) continue;
                const color = (globalViewMode === 'zones')
                    ? 'rgba(107,114,128,0.40)'
                    : ((f.outcome === 'Successful') ? BLUE : RED);
                drawArrow(s.cx, s.cy, e.cx, e.cy, color);
            }
            ctx.restore();
        } else {
            drawActions(canvas.getContext('2d'), dataPoints, canvas.width, canvas.height);
        }
        // Ballmagnet nicht in der Eckball-Half-View (freie Hälfte soll komplett leer bleiben)
        if (!(currentPhase === 'standards' && lastOpenCornerTab === 'eckball' && (standardsMode === 'mit-ball' || standardsMode === 'gegen-ball'))) {
            drawBallmagnetMarker();
        }
    }
    
    // --- INITIALISIERUNG & EVENT LISTENERS ---
    async function initDashboard() {
        const setAppLoading = (isLoading, text) => {
            const overlay = document.getElementById('app-loading');
            const mainGrid = document.getElementById('main-grid');
            const infoLinks = document.getElementById('info-links');
            const infoRechts = document.getElementById('info-rechts');
            const label = overlay ? overlay.querySelector('[data-loading-text]') : null;
            if (label && typeof text === 'string') label.textContent = text;
            if (overlay) {
                overlay.hidden = !isLoading;
                overlay.classList.toggle('hidden', !isLoading);
                overlay.setAttribute('aria-busy', String(!!isLoading));
            }
            if (mainGrid) mainGrid.classList.toggle('loading-mode', !!isLoading);
            if (infoLinks) infoLinks.hidden = !!isLoading;
            if (infoRechts) infoRechts.hidden = !!isLoading;
        };

        // Initial: show loader overlay until first render completes.
        setAppLoading(true, 'Lade Daten…');



        const teamSelect = document.getElementById('team-select');
        const btnUebersicht = document.getElementById('btn-uebersicht');
        const btnMitBall = document.getElementById('btn-mit-ball');
        const btnGegenBall = document.getElementById('btn-gegen-ball');
        const btnStandards = document.getElementById('btn-standards');
        const btnPhysisch = document.getElementById('btn-physisch');
    const canvas = document.getElementById('action-canvas');
    const coordsDisplay = document.getElementById('coords-display');
    const btnGlobalDetail = document.getElementById('btn-global-detail');
    const btnGlobalZones = document.getElementById('btn-global-zones');
        const gameFilterButtons = document.querySelectorAll('.game-filter-btn');
        const dropdownBtn = document.getElementById('gegneranalyse-btn');
        const dropdown = document.getElementById('gegneranalyse-dropdown');
    const infoLinksContainer = document.getElementById('info-links');
    const infoRechtsContent = document.getElementById('info-content-rechts');

        const activeTabClasses = ['bg-[#0A3F86]', 'text-white', 'border-[#0A3F86]', 'hover:bg-[#0A3F86]'];
        const clearAllTabActives = () => {
            document.querySelectorAll('button[data-aufbau-tab], button[data-kontrolle-tab], button[data-zumtor-tab]').forEach(b => {
                activeTabClasses.forEach(c => b.classList.remove(c));
            });
        };

        // Daten laden
        try {
            const [statsResponse, eventsResponse, formationsResponse, dflRunResponse, dflPlayersResponse] = await Promise.all([
                fetch('processed_data.json'),
                fetch('events_data.json'),
                fetch('formations_data.json').catch(() => null),
                fetch('dfl_running_team_matches.json').catch(() => null),
                fetch('dfl_running_players.json').catch(() => null)
            ]);

            if (!statsResponse.ok) throw new Error('processed_data.json konnte nicht geladen werden.');
            if (!eventsResponse.ok) throw new Error('events_data.json konnte nicht geladen werden. Bitte create_events_json.py ausführen.');

            dataset = await statsResponse.json();
            eventDataset = await eventsResponse.json();

            if (formationsResponse && formationsResponse.ok) {
                formationsDataset = await formationsResponse.json();
            } else {
                formationsDataset = [];
            }

            if (dflRunResponse && dflRunResponse.ok) {
                dflRunningTeamMatches = await dflRunResponse.json();
            } else {
                dflRunningTeamMatches = [];
            }

            if (dflPlayersResponse && dflPlayersResponse.ok) {
                dflRunningPlayerMatches = await dflPlayersResponse.json();
            } else {
                dflRunningPlayerMatches = [];
            }

        } catch (error) {
            console.error("Fehler beim Laden der Daten:", error);
            document.getElementById('analysis-title').textContent = "Fehler beim Laden der Daten";
            const msg = `<p class="text-red-500">${error.message}</p>`;
            const elA = document.getElementById('info-content-aufbau');
            const elK = document.getElementById('info-content-kontrolle');
            const elZ = document.getElementById('info-content-zumtor');
            if (elA) elA.innerHTML = msg;
            if (elK) elK.innerHTML = msg;
            if (elZ) elZ.innerHTML = msg;

            // Show error UI (no loader overlay)
            setAppLoading(false);
            return;
        }
        
        dropdownBtn.addEventListener('click', (e) => {
            // Dropdown öffnen/schließen ohne Phase-Reset
            e.stopPropagation();
            dropdown.classList.toggle('hidden');
        });
        
        document.addEventListener('click', (e) => {
            if (!dropdownBtn.contains(e.target) && !dropdown.contains(e.target)) {
                dropdown.classList.add('hidden');
            }
        });

        // Teams extrahieren (Events/KPI-Quelle)
        const teams = [...new Set(dataset.map(row => row.team))].sort();

        // baseTeam = unser Team (HSV) als Referenz für die Spielrichtung.
        // In der Gegneranalyse soll HSV/Hamburg NICHT auswählbar sein (wir analysieren immer den Gegner).
        const pickBaseTeam = (allTeams) => {
            if (!Array.isArray(allTeams) || !allTeams.length) return null;
            const exact = allTeams.find(t => String(t).trim().toLowerCase() === 'hamburger sv');
            if (exact) return exact;
            const containsHSV = allTeams.find(t => {
                const s = String(t).toLowerCase();
                return s.includes('hamburger') && s.includes('sv');
            });
            if (containsHSV) return containsHSV;
            const hamburg = allTeams.find(t => String(t).trim().toLowerCase() === 'hamburg');
            if (hamburg) return hamburg;
            return allTeams[0];
        };

        baseTeam = pickBaseTeam(teams) || null;

        // Gegneranalyse: Nur diese Teams sollen auswählbar sein
        const ALLOWED_DATASET_TEAMS = new Set(['Leverkusen', 'Freiburg']);
        const ALLOWED_DFL_TEAMS = new Set(['Bayer 04 Leverkusen', 'Sport-Club Freiburg']);
        const filterAllowedTeams = (list, allowedSet) => (Array.isArray(list) ? list : [])
            .map(t => String(t))
            .filter(t => allowedSet.has(t));

        const datasetOpponents = (() => {
            const opps = (!baseTeam) ? [...teams] : teams.filter(t => t !== baseTeam);
            return filterAllowedTeams(opps, ALLOWED_DATASET_TEAMS);
        })();

        const opponentLabelMap = new Map([
            ['Leverkusen', 'Leverkusen'],
            ['Freiburg', 'Freiburg'],
            ['Bayer 04 Leverkusen', 'Leverkusen'],
            ['Sport-Club Freiburg', 'Freiburg'],
        ]);
        const getOpponentLabel = (teamValue) => opponentLabelMap.get(String(teamValue)) || String(teamValue);

        const setTeamSelectOptions = (options, { disableIfEmpty } = { disableIfEmpty: true }) => {
            const prev = String(currentTeam || '').trim();
            const opts = Array.isArray(options) ? options.filter(Boolean) : [];

            teamSelect.innerHTML = '';
            for (const team of opts) {
                const option = document.createElement('option');
                option.value = team;
                option.textContent = getOpponentLabel(team);
                teamSelect.appendChild(option);
            }

            if (!opts.length) {
                teamSelect.value = '';
                teamSelect.disabled = !!disableIfEmpty;
                currentTeam = '';
                return;
            }

            const keep = opts.includes(prev) ? prev : opts[0];
            teamSelect.value = keep;
            teamSelect.disabled = false;
            currentTeam = keep;
        };

        const refreshTeamSelectForPhase = () => {
            const topPhase = (typeof currentMainPhase === 'string' && currentMainPhase) ? currentMainPhase : currentPhase;
            const isPhysisch = (topPhase === 'physisch');

            if (isPhysisch) {
                const dflOpps = _dflOpponentsForBaseTeam(baseTeam);
                const dflAllowed = filterAllowedTeams(dflOpps, ALLOWED_DFL_TEAMS);
                const opts = (Array.isArray(dflAllowed) && dflAllowed.length) ? dflAllowed : datasetOpponents;
                if (opts && opts.length) {
                    setTeamSelectOptions(opts, { disableIfEmpty: true });
                    return;
                }
            }

            // Default: show opponent teams from processed_data.json (events/kpi scope)
            setTeamSelectOptions(datasetOpponents, { disableIfEmpty: true });
        };

        // Initial fill
        refreshTeamSelectForPhase();

        // Event Listeners
        teamSelect.addEventListener('change', (e) => {
            currentTeam = e.target.value;
            updateDashboard();
            dropdown.classList.add('hidden'); // Dropdown schließen
        });
        
        // Phasen-Buttons (Top-Level)
        const phaseButtons = [btnUebersicht, btnMitBall, btnGegenBall, btnStandards, btnPhysisch].filter(Boolean);
        phaseButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                phaseButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentMainPhase = btn.id.replace('btn-', '');
                // Default selections per top-level phase
                if (currentMainPhase === 'gegen-ball') {
                    activeGegenBallGroup = 'pressing';
                    lastOpenPressingTab = 'pressinghoehe';
                    currentPhase = 'pressinghoehe';
                } else if (currentMainPhase === 'mit-ball') {
                    activeLeftTabGroup = 'aufbau';
                    lastOpenAufbauTab = 'grundstruktur';
                    currentPhase = 'grundstruktur';
                    lastOpenIndividualtaktikTab = null;
                } else if (currentMainPhase === 'uebersicht') {
                    currentPhase = 'uebersicht';
                } else {
                    currentPhase = currentMainPhase;
                }
                applyPhysischLayout();
                refreshTeamSelectForPhase();
                updateDashboard();
            });
        });
        
        // Event Listeners für Game Filter
        gameFilterButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                gameFilterButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentGameCount = parseInt(btn.dataset.count);
                updateDashboard();
            });
        });

        // Event Listeners for Standards-Mode Toggle (Mit Ball / Gegen Ball)
        const standardsModeToggle = document.getElementById('standards-mode-toggle');
        const setStandardsModeActive = (mode) => {
            const a = standardsModeToggle?.querySelector('button[data-standards-mode="mit-ball"]');
            const b = standardsModeToggle?.querySelector('button[data-standards-mode="gegen-ball"]');
            if (!a || !b) return;
            const active = ['bg-[#0A3F86]', 'text-white', 'hover:bg-[#0A3F86]', 'hover:text-white'];
            const inactive = ['bg-white', 'text-gray-700', 'hover:bg-gray-50', 'hover:text-gray-700'];
            [a, b].forEach(btn => btn.classList.remove(...active, ...inactive));
            a.classList.add(...inactive);
            b.classList.add(...inactive);
            if (mode === 'gegen-ball') {
                b.classList.remove(...inactive);
                b.classList.add(...active);
            } else {
                a.classList.remove(...inactive);
                a.classList.add(...active);
            }
        };
        if (standardsModeToggle) {
            standardsModeToggle.addEventListener('click', (e) => {
                const btn = e.target.closest('button[data-standards-mode]');
                if (!btn) return;
                const mode = btn.getAttribute('data-standards-mode');
                standardsMode = (mode === 'gegen-ball') ? 'gegen-ball' : 'mit-ball';
                setStandardsModeActive(standardsMode);
                updateDashboard();
            });
            // initial sync
            setStandardsModeActive(standardsMode);
        }

        // Event Listeners for Standards-Sub-Buttons
        const standardsButtonsContainer = document.querySelector('#standards-info-box .grid');
        if (standardsButtonsContainer) {
            standardsButtonsContainer.addEventListener('click', (e) => {
                const button = e.target.closest('button[data-corner-tab]');
                if (button) {
                    standardsButtonsContainer.querySelectorAll('button[data-corner-tab]').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    button.classList.add('active');
                    lastOpenCornerTab = button.dataset.cornerTab;
                    updateDashboard(); // Ruft die Haupt-Update-Funktion auf, um die Ansicht zu aktualisieren
                }
            });
        }

        // Event Listener für das Akkordeon in der Info-Box (nur verschachtelte Items)
        infoLinksContainer.addEventListener('click', async (e) => {
            // Gegen den Ball: Pressing & Zugriff Tabs
            const pressingTabBtn = e.target.closest('button[data-pressing-tab]');
            if (pressingTabBtn) {
                const tabKey = pressingTabBtn.getAttribute('data-pressing-tab');
                if (!tabKey) return;
                // Links selektiert -> Rechts (Individualtaktik) deaktivieren
                lastOpenIndividualtaktikTab = null;
                activeGegenBallGroup = 'pressing';
                lastOpenPressingTab = tabKey;
                // Pressing & Zugriff: Mittel-Viz
                if (tabKey === 'pressinghoehe') currentPhase = 'pressinghoehe';
                else if (tabKey === 'zugriff') currentPhase = 'zugriff';
                else if (tabKey === 'intensitaet') currentPhase = 'intensitaet';
                else if (tabKey === 'ballgewinne-zonen') currentPhase = 'ballgewinne-zonen';
                else currentPhase = currentMainPhase;
                await updateDashboard();
                return;
            }

            // Gegen den Ball: Block & Raumkontrolle Tabs
            const blockTabBtn = e.target.closest('button[data-block-tab]');
            if (blockTabBtn) {
                const tabKey = blockTabBtn.getAttribute('data-block-tab');
                if (!tabKey) return;
                // Links selektiert -> Rechts (Individualtaktik) deaktivieren
                lastOpenIndividualtaktikTab = null;
                activeGegenBallGroup = 'block';
                lastOpenBlockTab = tabKey;
                // Zentrum soll die Mittel-Viz schalten (Gegnerpässe ins Zentrum im Final Third)
                if (tabKey === 'zentrum') currentPhase = 'gb-block-zentrum';
                else if (tabKey === 'halb') currentPhase = 'gb-block-halbraeume';
                else if (tabKey === 'fluegel') currentPhase = 'gb-block-fluegel';
                else if (tabKey === 'blockhoehe') currentPhase = 'gb-block-blockhoehe';
                else if (tabKey === 'kompaktheit') currentPhase = 'gb-block-kompaktheit';
                else currentPhase = currentMainPhase;
                await updateDashboard();
                return;
            }

            // Gegen den Ball: Chance Prevention Tabs
            const chanceTabBtn = e.target.closest('button[data-chance-tab]');
            if (chanceTabBtn) {
                const tabKey = chanceTabBtn.getAttribute('data-chance-tab');
                if (!tabKey) return;
                // Links selektiert -> Rechts (Individualtaktik) deaktivieren
                lastOpenIndividualtaktikTab = null;
                activeGegenBallGroup = 'chance';
                lastOpenChanceTab = tabKey;
                // Mittel-Viz: Schüsse / Schüsse Box / Box Defense / Box Entries haben eigene Grafiken.
                if (tabKey === 'shots' || tabKey === 'shots-box' || tabKey === 'box-defense' || tabKey === 'box-entries' || tabKey === 'cross-defense' || tabKey === 'standards-against') currentPhase = tabKey;
                else currentPhase = currentMainPhase;
                await updateDashboard();
                return;
            }

            // Standards: Eckbälle Tabs
            const cornerTabBtn = e.target.closest('button[data-corner-tab]');
            if (cornerTabBtn) {
                const tabKey = cornerTabBtn.getAttribute('data-corner-tab');
                if (!tabKey) return;
                // Links selektiert -> Rechts (Individualtaktik) deaktivieren
                lastOpenIndividualtaktikTab = null;
                lastOpenCornerTab = tabKey;
                await updateDashboard();
                return;
            }

            // Spielaufbau: Tabs (Grundstruktur / Progressive Pässe / Abstöße)
            const tabBtn = e.target.closest('button[data-aufbau-tab]');
            if (tabBtn) {
                const phaseAttr = tabBtn.getAttribute('data-aufbau-tab');
                if (!phaseAttr) return;
                // Links selektiert -> Rechts (Individualtaktik) deaktivieren
                lastOpenIndividualtaktikTab = null;
                activeLeftTabGroup = 'aufbau';
                clearAllTabActives();
                lastOpenAufbauTab = phaseAttr;
                currentPhase = phaseAttr;
                await updateDashboard();
                return;
            }

            // Spielkontrolle: Tabs – Ballbesitz schaltet Mittel-Viz (Heatmap), sonst nur Content
            const kontrolleTabBtn = e.target.closest('button[data-kontrolle-tab]');
            if (kontrolleTabBtn) {
                const tabKey = kontrolleTabBtn.getAttribute('data-kontrolle-tab');
                if (!tabKey) return;
                // Links selektiert -> Rechts (Individualtaktik) deaktivieren
                lastOpenIndividualtaktikTab = null;
                activeLeftTabGroup = 'kontrolle';
                lastOpenKontrolleTab = tabKey;

                clearAllTabActives();

                const root = document.getElementById('info-content-kontrolle');
                if (!root) return;

                root.querySelectorAll('button[data-kontrolle-tab]').forEach(b => {
                    activeTabClasses.forEach(c => b.classList.remove(c));
                });
                activeTabClasses.forEach(c => kontrolleTabBtn.classList.add(c));

                root.querySelectorAll('[data-kontrolle-panel]').forEach(p => p.classList.add('hidden'));
                const panel = root.querySelector(`[data-kontrolle-panel="${tabKey}"]`);
                if (panel) panel.classList.remove('hidden');

                if (tabKey === 'ballbesitz') {
                    currentPhase = 'ballbesitz';
                    await updateDashboard();
                }
                if (tabKey === 'fieldtilt') {
                    currentPhase = 'fieldtilt';
                    await updateDashboard();
                }
                if (tabKey === 'switch-rate') {
                    currentPhase = 'switch-rate';
                    await updateDashboard();
                }
                return;
            }

            // Zum Tor: Tabs (Angriffsseite / Abschlüsse) – schaltet die Mittel-Viz
            const zumTorTabBtn = e.target.closest('button[data-zumtor-tab]');
            if (zumTorTabBtn) {
                const tabKey = zumTorTabBtn.getAttribute('data-zumtor-tab');
                if (!tabKey) return;
                // Links selektiert -> Rechts (Individualtaktik) deaktivieren
                lastOpenIndividualtaktikTab = null;
                lastOpenZumTorTab = tabKey;

                activeLeftTabGroup = 'zumtor';
                clearAllTabActives();

                currentPhase = tabKey;
                await updateDashboard();
                return;
            }

            const header = e.target.closest('.accordion-header');
            if (!header) return;

            const parentItem = header.parentElement; // .accordion-item (mit data-phase)
            const phaseAttr = parentItem.getAttribute('data-phase');

            // Nur verschachtelte Analysen sind klickbar; Top-Level sind statisch
            if (!phaseAttr) return;

            const isOpen = parentItem.classList.contains('open');

            // Toggle Open-State: Bei erneutem Klick nur schließen, ohne Dashboard-Re-Render
            if (isOpen) {
                parentItem.classList.remove('open');
                return;
            }

            // Mehrfach-Öffnen erlauben: nur den aktuellen Eintrag öffnen, andere bleiben wie sie sind
            parentItem.classList.add('open');

            // Spielkontrolle: Ballbesitz soll nur auf/zu klappen (keine Mittel-Viz-Phase)
            if (phaseAttr === 'ballbesitz') return;

            // Links selektiert -> Rechts (Individualtaktik) deaktivieren
            lastOpenIndividualtaktikTab = null;

            lastOpenNestedPhase = phaseAttr;

            // Mittelbereich auf die angeklickte Analyse umschalten und nur dort neu zeichnen
            currentPhase = phaseAttr;
            await updateDashboard();
        });

        // Rechtes Panel: Individualtaktik Tabs
        infoRechtsContent.addEventListener('click', (e) => {
            const tabBtn = e.target.closest('button[data-itk-tab]');
            if (!tabBtn) return;

            const key = tabBtn.getAttribute('data-itk-tab');
            if (!key) return;

            // Rechts selektiert -> Links (Analyse-Tabs) deaktivieren und Mittelbereich zurück auf Top-Level
            activeLeftTabGroup = null;
            currentPhase = currentMainPhase;

            lastOpenIndividualtaktikTab = key;

            // Buttons
            infoRechtsContent.querySelectorAll('button[data-itk-tab]').forEach(btn => btn.classList.remove('active'));
            tabBtn.classList.add('active');

            // Panels
            infoRechtsContent.querySelectorAll('[data-itk-panel]').forEach(p => p.classList.add('hidden'));
            const panel = infoRechtsContent.querySelector(`[data-itk-panel="${key}"]`);
            if (panel) panel.classList.remove('hidden');

            // Update center pitch marker immediately (Ballmagnet)
            updateDashboard();
        });
        
        // Maus-Koordinaten auf Canvas anzeigen
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const w = canvas.width;
            const h = canvas.height;
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // In der Eckball-Halbfeldansicht soll der freie Bereich (weiß) keine Pitch-Koordinaten anzeigen.
            // mit-ball  => aktive Hälfte unten
            // gegen-ball => aktive Hälfte oben
            const isEckballHalf = (currentPhase === 'standards' && lastOpenCornerTab === 'eckball' && (standardsMode === 'mit-ball' || standardsMode === 'gegen-ball'));
            if (isEckballHalf) {
                const activeY0 = (standardsMode === 'gegen-ball') ? 0 : (h / 2);
                const activeY1 = activeY0 + (h / 2);
                const insideActiveHalf = (mouseY >= activeY0 && mouseY <= activeY1);
                if (!insideActiveHalf) {
                    coordsDisplay.textContent = '';
                    canvas.style.cursor = 'default';
                    return;
                }
                canvas.style.cursor = 'crosshair';
            }

            const y_coord = (mouseX / w * 100).toFixed(1); // x auf Canvas ist y in Daten
            // Wenn PassMap aktiv (gedrehte Achse), invertiere x-Anzeige
            const x_val = pitchVizInstance ? (1 - (mouseY / h)) * 100 : (mouseY / h) * 100;
            const x_coord = x_val.toFixed(1);
            coordsDisplay.textContent = `x: ${x_coord}, y: ${y_coord}`;
        });
        canvas.addEventListener('mouseleave', () => {
            coordsDisplay.textContent = '';
        });

        // Globaler View-Switch: Events
        if (btnGlobalDetail && btnGlobalZones) {
            btnGlobalDetail.addEventListener('click', () => { globalViewMode = 'detail'; setGlobalViewActive('detail'); updateDashboard(); });
            btnGlobalZones.addEventListener('click', () => { globalViewMode = 'zones'; setGlobalViewActive('zones'); updateDashboard(); });
            // Initial aktiv setzen
            setGlobalViewActive(globalViewMode);
        }

        await updateDashboard();
        setAppLoading(false);
        
        let resizeDebounce = null;
        new ResizeObserver(() => {
            if (resizeDebounce) clearTimeout(resizeDebounce);
            resizeDebounce = setTimeout(() => {
                syncRightPanelHeightToPitch();
                if (!isUpdating) updateDashboard();
            }, 150);
        }).observe(document.getElementById('action-container'));
    }

    document.addEventListener('DOMContentLoaded', initDashboard);

</script>
<!-- ### ENDE JAVASCRIPT LOGIK ### -->

</body>
</html>